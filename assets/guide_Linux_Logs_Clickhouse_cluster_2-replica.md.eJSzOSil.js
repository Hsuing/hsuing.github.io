import{_ as e,o as a,c as r,R as o}from"./chunks/framework.zUbWieqp.js";const u=JSON.parse('{"title":"1. ck副本机制","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/Logs/Clickhouse/cluster/2-replica.md","filePath":"guide/Linux/Logs/Clickhouse/cluster/2-replica.md","lastUpdated":1730888659000}'),t={name:"guide/Linux/Logs/Clickhouse/cluster/2-replica.md"},c=o('<h1 id="_1-ck副本机制" tabindex="-1">1. ck副本机制 <a class="header-anchor" href="#_1-ck副本机制" aria-label="Permalink to &quot;1. ck副本机制&quot;">​</a></h1><h2 id="_1-1-介绍" tabindex="-1">1.1 介绍 <a class="header-anchor" href="#_1-1-介绍" aria-label="Permalink to &quot;1.1 介绍&quot;">​</a></h2><p>副本功能只支持 MergeTree Family 的<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/replication" target="_blank" rel="noreferrer">表引擎</a></p><p>ClickHouse 副本的目的主要是保障数据的<code>高可用性</code>，即使一台 ClickHouse 节点宕机，那么也可以从其他服务器获得相同的数据。</p><h2 id="_1-2-基于zookeeper" tabindex="-1">1.2 基于zookeeper <a class="header-anchor" href="#_1-2-基于zookeeper" aria-label="Permalink to &quot;1.2 基于zookeeper&quot;">​</a></h2><p>主要依赖 Zookeeper 来进行多个 ClickHouse 节点间数据的同步，各节点间没有主从关系</p><h2 id="_1-3-基于ck-keeper" tabindex="-1">1.3 基于ck-keeper <a class="header-anchor" href="#_1-3-基于ck-keeper" aria-label="Permalink to &quot;1.3 基于ck-keeper&quot;">​</a></h2>',7),i=[c];function s(l,n,_,d,p,h){return a(),r("div",null,i)}const m=e(t,[["render",s]]);export{u as __pageData,m as default};
