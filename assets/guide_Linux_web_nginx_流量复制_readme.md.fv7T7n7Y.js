import{_ as e,o as t,c as m,R as a}from"./chunks/framework.zUbWieqp.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/web/nginx/流量复制/readme.md","filePath":"guide/Linux/web/nginx/流量复制/readme.md","lastUpdated":1701684699000}'),p={name:"guide/Linux/web/nginx/流量复制/readme.md"},r=a("<p>我们可以使用诸如 <em>ab</em>, <em>wrk</em>, <em>httperf</em>, <em>locust</em>, <em>JMeter</em> 等工具模拟用户请求，但是这些模拟请求不 足以还原真实场景，同时它们的请求模式也过于单一和理想化。</p><p>为了更贴近真实场景，我们可以使用诸如 <em>httperf</em>, <em>vanishreplay</em>, <em>tcpreplay</em>, <em>log-replay</em> 等「离线 回放」工具重放生产环境请求日志，也可以使用 <em>goreplay</em> ，<em>tcpcopy</em> 等「流量复制」工具，实时捕捉生产环境 流量并导向目标测试系统。同时，这些「流量复制」工具甚至可以对真实流量进行放大或缩小。</p><p>流量复制工具一般分成两类：</p><p>{% em %} 基于应用层的流量复制工具和基于网络栈的流量复制工具 {% endem %}。前者实现简单，但会挤 占线上应用的资源（比如连接资源，内存资源等），还可能会因为耦合度高而影响正常业务。而基于网络栈的流 量复制工具，直接从链路层抓取数据包，对应用影响较小，但是其实现也就相对复杂一些</p><p>相比tcp-copy的优势：无需录制流量，实时可用；配置相当简单</p>",5),n=[r];function o(_,c,s,d,i,l){return t(),m("div",null,n)}const g=e(p,[["render",o]]);export{f as __pageData,g as default};
