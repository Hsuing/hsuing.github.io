import{_ as s,o as l,c as a,R as n}from"./chunks/framework.zUbWieqp.js";const h=JSON.parse('{"title":"1.Redis缓存击穿、雪崩、穿透的解决方案","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/Redis/7-cache.md","filePath":"guide/Database/Redis/7-cache.md","lastUpdated":1720533756000}'),p={name:"guide/Database/Redis/7-cache.md"},e=n(`<h1 id="_1-redis缓存击穿、雪崩、穿透的解决方案" tabindex="-1">1.Redis缓存击穿、雪崩、穿透的解决方案 <a class="header-anchor" href="#_1-redis缓存击穿、雪崩、穿透的解决方案" aria-label="Permalink to &quot;1.Redis缓存击穿、雪崩、穿透的解决方案&quot;">​</a></h1><h3 id="缓存雪崩" tabindex="-1">缓存雪崩 <a class="header-anchor" href="#缓存雪崩" aria-label="Permalink to &quot;缓存雪崩&quot;">​</a></h3><ul><li>什么是缓存雪崩？你有什么解决方案来防止缓存雪崩？ <ul><li>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。 由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU 和内存造成巨大压力，严重的会造成数据库宕机</li><li>你有什么解决方案来防止缓存雪崩？ <ul><li>加锁排队 <ul><li>key： whiltList value：1000w个uid 指定setNx whiltList value nullValue mutex互斥锁解决，Redis的SETNX去set一个mutex key， 当操作返回成功时，再进行load db的操作并回设缓存； 否则，就重试整个get缓存的方法</li></ul></li><li>数据预热 <ul><li>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题!用户直接查询事先被预热的缓存数据!可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key</li></ul></li><li>双层缓存策略 <ul><li>C1为原始缓存，C2为拷贝缓存，C1失效时，可以访问C2，C1缓存失效时间设置为短期，C2设置为长期。</li></ul></li><li>定时更新缓存策略 <ul><li>失效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存</li></ul></li><li>设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ul></li></ul></li></ul><hr><h3 id="缓存穿透" tabindex="-1">缓存穿透 <a class="header-anchor" href="#缓存穿透" aria-label="Permalink to &quot;缓存穿透&quot;">​</a></h3><ul><li>什么是缓存穿透？你有什么解决方案来防止缓存穿透？ <ul><li>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候， 在缓存中找不到对应key的value，每次都要去数据库再查询一遍，然后返回空(相当于进行了两次 无用的查询)。这样请求就绕过缓存直接查数据库</li></ul></li><li>你有什么解决方案来防止缓存穿透？ <ul><li>采用布隆过滤器BloomFilter <ul><li>将所有可能存在的数据哈 希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li></ul></li><li>缓存空值 <ul><li>如果一个查询返回的数据为空(不管是数据不 存在，还是系统故障)我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库</li></ul></li></ul></li></ul><h3 id="概念简述" tabindex="-1">概念简述 <a class="header-anchor" href="#概念简述" aria-label="Permalink to &quot;概念简述&quot;">​</a></h3><ul><li>缓存击穿 <ul><li>某个热点key缓存失效了</li></ul></li><li>缓存雪崩 <ul><li>多个热点key都过期</li></ul></li><li>缓存穿透 <ul><li>查询不存在数据</li></ul></li></ul><h3 id="缓存击穿-解决方案" tabindex="-1">缓存击穿+解决方案 <a class="header-anchor" href="#缓存击穿-解决方案" aria-label="Permalink to &quot;缓存击穿+解决方案&quot;">​</a></h3><ul><li><p>缓存击穿 (某个热点key缓存失效了)</p><ul><li>缓存中没有但数据库中有的数据，假如是热点数据，那key在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力增大。</li><li>和缓存雪崩的区别在于这里针对某一key缓存，后者则是很多key。</li></ul></li><li><p>预防</p><ul><li>设置热点数据不过期</li><li>定时任务定时更新缓存</li><li>设置互斥锁</li></ul></li><li><p>SpringCache解决方案</p><ul><li>缓存的同步 sync</li><li>sync 可以指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Cacheable</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#9ECBFF;">&quot;product&quot;</span><span style="color:#E1E4E8;">},</span><span style="color:#79B8FF;">key</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;#root.args[0]&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cacheManager</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;customCacheManager&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">sync</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Cacheable</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span><span style="color:#032F62;">&quot;product&quot;</span><span style="color:#24292E;">},</span><span style="color:#005CC5;">key</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;#root.args[0]&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">cacheManager</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;customCacheManager&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">sync</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span></code></pre></div></li></ul><h3 id="缓存雪崩-解决方案" tabindex="-1">缓存雪崩+解决方案 <a class="header-anchor" href="#缓存雪崩-解决方案" aria-label="Permalink to &quot;缓存雪崩+解决方案&quot;">​</a></h3><ul><li><p>缓存雪崩 (多个热点key都过期)</p><ul><li><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩</p></li><li><p>预防</p><ul><li>存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li><li>设置热点数据永远不过期，定时任务定时更新</li></ul></li><li><p>SpringCache解决方案</p><ul><li>设置差别的过时时间</li><li>比如CacheManager配置多个过期时间维度</li><li>配置文件 time-to-live 配置</li></ul><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#85E89D;">cache</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">#使用的缓存类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">type</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">redis</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">#过时时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">redis</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">time-to-live</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">3600000</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;"># 开启前缀，默以为true</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">use-key-prefix</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;"># 键的前缀,默认就是缓存名cacheNames</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">key-prefix</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">WYL_CACHE</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;"># 是否缓存空结果，防止缓存穿透，默以为true</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">cache-null-values</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#22863A;">cache</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">#使用的缓存类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">type</span><span style="color:#24292E;">: </span><span style="color:#032F62;">redis</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">#过时时间</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">redis</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">time-to-live</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">3600000</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;"># 开启前缀，默以为true</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">use-key-prefix</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;"># 键的前缀,默认就是缓存名cacheNames</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">key-prefix</span><span style="color:#24292E;">: </span><span style="color:#032F62;">WYL_CACHE</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;"># 是否缓存空结果，防止缓存穿透，默以为true</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">cache-null-values</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span></span></code></pre></div></li></ul></li></ul><h3 id="缓存穿透-解决方案" tabindex="-1">缓存穿透+解决方案 <a class="header-anchor" href="#缓存穿透-解决方案" aria-label="Permalink to &quot;缓存穿透+解决方案&quot;">​</a></h3><ul><li><p>缓存穿透（查询不存在数据）</p><ul><li><p>查询一个不存在的数据，由于缓存是不命中的，并且出于容错考虑，如发起为id为“-1”不存在的数据</p></li><li><p>如果从存储层查不到数据则不写入缓存这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。存在大量查询不存在的数据，可能DB就挂掉了，这也是黑客利用不存在的key频繁攻击应用的一种方式。</p></li><li><p>预防</p><ul><li>接口层增加校验，数据合理性校验</li><li>缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置短点的过期时间，防止同个key被一直攻击</li></ul></li><li><p>使用布隆过滤器解决</p><p>将已存在的缓存到布隆过滤器中，当访问不存在的缓存时迅速返回避免缓存及DB挂掉</p><blockquote><p>并不能完全解决， 只能将其控制在一个可以容忍的范围内</p></blockquote></li><li><p>SpringCache解决方案</p><ul><li>空结果也缓存，默认不配置condition或者unless就行</li></ul><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#85E89D;">cache</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">#使用的缓存类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">type</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">redis</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">#过时时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">redis</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">time-to-live</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">3600000</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;"># 开启前缀，默以为true</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">use-key-prefix</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;"># 键的前缀,默认就是缓存名cacheNames</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">key-prefix</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">WYL</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;"># 是否缓存空结果，防止缓存穿透，默以为true</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#85E89D;">cache-null-values</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#22863A;">cache</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">#使用的缓存类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">type</span><span style="color:#24292E;">: </span><span style="color:#032F62;">redis</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">#过时时间</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">redis</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">time-to-live</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">3600000</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;"># 开启前缀，默以为true</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">use-key-prefix</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;"># 键的前缀,默认就是缓存名cacheNames</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">key-prefix</span><span style="color:#24292E;">: </span><span style="color:#032F62;">WYL</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;"># 是否缓存空结果，防止缓存穿透，默以为true</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#22863A;">cache-null-values</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span></span></code></pre></div></li></ul></li></ul>`,14),o=[e];function c(t,r,i,y,E,u){return l(),a("div",null,o)}const C=s(p,[["render",c]]);export{h as __pageData,C as default};
