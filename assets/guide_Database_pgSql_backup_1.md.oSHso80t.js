import{_ as a,o as e,c as p,R as t}from"./chunks/framework.zUbWieqp.js";const n=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/pgSql/backup/1.md","filePath":"guide/Database/pgSql/backup/1.md","lastUpdated":1703063387000}'),r={name:"guide/Database/pgSql/backup/1.md"},d=t('<h2 id="一、postgresql-最佳实践-在线逻辑备份与恢复介绍" tabindex="-1">一、PostgreSQL 最佳实践 - 在线逻辑备份与恢复介绍 <a class="header-anchor" href="#一、postgresql-最佳实践-在线逻辑备份与恢复介绍" aria-label="Permalink to &quot;一、PostgreSQL 最佳实践 - 在线逻辑备份与恢复介绍&quot;">​</a></h2><p>PostgreSQL 逻辑备份, 指在线备份数据库数据, DDL以SQL语句形式输出, 数据则可以以SQL语句或者固定分隔符(row格式)的形式输出.</p><p>备份时不影响其他用户对备份对象的DML操作.</p><p>逻辑备份工具pg_dump, pg_dumpall, 以及数据库的COPY命令的备份方法</p><h2 id="_1-pg-dump" tabindex="-1">1. pg_dump <a class="header-anchor" href="#_1-pg-dump" aria-label="Permalink to &quot;1. pg_dump&quot;">​</a></h2><p>使用pg_dump进行备份时, 其他用户可以同时进行DML(SELECT, UPDATE, DELETE, INSERT)操作, 相互之间没有干扰.</p><h3 id="pg-dump备份程序的逻辑" tabindex="-1">pg_dump备份程序的逻辑 <a class="header-anchor" href="#pg-dump备份程序的逻辑" aria-label="Permalink to &quot;pg_dump备份程序的逻辑&quot;">​</a></h3><p>1.pg_dump的一次完整的备份是在一个事务中完成的, 事务隔离级别为serializable 或者 repeatable read</p><p>2.pg_dump在备份数据开始前, 需要对进行备份的对象加ACCESS SHARE锁</p><p>pg_dump加的锁与DDL冲突, 例如TRUNCATE, DROP, ALTER, VACUUM FULL, 以及以及unqualified LOCK TABLE冲突, 所以备份开始后是不能进行这些操作的. 可以防止备份过程中数据结构改变, 或者数据被物理的删除掉了</p><p>正因为pg_dump在备份数据前要对备份对象加锁, 所以为了防止pg_dump无休止的的锁等待, pg_dump支持锁超时</p><p><a href="https://github.com/digoal/blog/blob/master/201702/20170201_01.md" target="_blank" rel="noreferrer">https://github.com/digoal/blog/blob/master/201702/20170201_01.md</a></p>',12),o=[d];function _(s,l,u,g,i,m){return e(),p("div",null,o)}const h=a(r,[["render",_]]);export{n as __pageData,h as default};
