import{_ as e,o as a,c as t,R as o}from"./chunks/framework.zUbWieqp.js";const m=JSON.parse('{"title":"1. ck介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/Logs/Clickhouse/1-architecture.md","filePath":"guide/Linux/Logs/Clickhouse/1-architecture.md","lastUpdated":1731157838000}'),c={name:"guide/Linux/Logs/Clickhouse/1-architecture.md"},r=o('<p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411081614148.jpeg" alt="img"></p><p><a href="https://clickhouse.com/docs/zh/development/architecture" target="_blank" rel="noreferrer">https://clickhouse.com/docs/zh/development/architecture</a></p><h1 id="_1-ck介绍" tabindex="-1">1. ck介绍 <a class="header-anchor" href="#_1-ck介绍" aria-label="Permalink to &quot;1. ck介绍&quot;">​</a></h1><p>ClickHouse 是一款由俄罗斯 Yandex 公司开发的 <code>C++</code> 开源高性能 OLAP 组件，是一个<strong>列式存储</strong>数据库管理系统(DBMS)。Yandex是俄罗斯最大的搜索引擎,主要用于在线分析处理查询（OLAP），能够使用SQL查询实时生成分析数据报告。</p><h2 id="_1-1-ck特点" tabindex="-1">1.1 ck特点 <a class="header-anchor" href="#_1-1-ck特点" aria-label="Permalink to &quot;1.1 ck特点&quot;">​</a></h2><h3 id="_1-列式存储" tabindex="-1">1.列式存储 <a class="header-anchor" href="#_1-列式存储" aria-label="Permalink to &quot;1.列式存储&quot;">​</a></h3><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411081635372.png" alt="image-20241108163540359"></p><p>列式存储好处：</p><p>1.对于列的聚合、计数、求和等统计操作原因优于行式存储；</p><p>2.由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列选择更优的数据压缩算法，大大提高了数据的压缩比重；</p><p>3.由于数据压缩比更好，一方面节省了磁盘空间</p><h3 id="_2-dbms的功能" tabindex="-1">2.DBMS的功能 <a class="header-anchor" href="#_2-dbms的功能" aria-label="Permalink to &quot;2.DBMS的功能&quot;">​</a></h3><p>覆盖了标准SQL的大部分语法，包括DDL和DML，以及配套的各种函数，用户管理及权限管理，数据的备份与恢复；</p><h3 id="_3-多样化引擎" tabindex="-1">3.多样化引擎 <a class="header-anchor" href="#_3-多样化引擎" aria-label="Permalink to &quot;3.多样化引擎&quot;">​</a></h3><p>ClickHouse和MySQL类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同的存储引擎。目前包括<code>合并树(用的最多)</code>、日志、接口和其他四大类20多种引擎；</p><h3 id="_4-高吞吐写入能力" tabindex="-1">4.高吞吐写入能力 <a class="header-anchor" href="#_4-高吞吐写入能力" aria-label="Permalink to &quot;4.高吞吐写入能力&quot;">​</a></h3><p>ClickHouse采用类<code>LSM Tree</code>的结构，数据写入后<code>定期</code>在后台Compaction。通过类LSM tree的结构，</p><p>ClickHouse在数据导入时全部是<code>顺序</code>append写，写入后数据段不可更改，在后台compaction时也是多个段merge</p><p>sort后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在HDD上也有着优异的写入性能</p><h3 id="_5-数据分区与线程级并行" tabindex="-1">5.数据分区与线程级并行 <a class="header-anchor" href="#_5-数据分区与线程级并行" aria-label="Permalink to &quot;5.数据分区与线程级并行&quot;">​</a></h3><p>ClickHouse将数据划分为多个partition，每个partition再进一步划分为多个index granularity（索引粒度），然后通过多个<code>CPU</code>核心分别处理其中的一部分来实现并行数据处理。在这种设计下，单条Query就能利用整机所有CPU。极致的并行处理能力，极大的降低了查询延时</p><p>所以，ClickHouse即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端就是对于单条查询使用多cpu，就不利于同时并发多条查询。所以对于高qps的查询业务，ClickHouse并不是强项</p><p><a href="https://blog.csdn.net/chuige2013/article/details/141537131?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;spm=1018.2226.3001.4187" target="_blank" rel="noreferrer">https://blog.csdn.net/chuige2013/article/details/141537131?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;spm=1018.2226.3001.4187</a></p>',23),i=[r];function s(n,p,d,h,l,u){return a(),t("div",null,i)}const k=e(c,[["render",s]]);export{m as __pageData,k as default};
