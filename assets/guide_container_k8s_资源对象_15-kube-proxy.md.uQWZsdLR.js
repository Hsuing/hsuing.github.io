import{_ as e,o as r,c as o,R as i}from"./chunks/framework.zUbWieqp.js";const g=JSON.parse('{"title":"1. kube-proxy","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/资源对象/15-kube-proxy.md","filePath":"guide/container/k8s/资源对象/15-kube-proxy.md","lastUpdated":1734344767000}'),t={name:"guide/container/k8s/资源对象/15-kube-proxy.md"},l=i('<h1 id="_1-kube-proxy" tabindex="-1">1. kube-proxy <a class="header-anchor" href="#_1-kube-proxy" aria-label="Permalink to &quot;1. kube-proxy&quot;">​</a></h1><h2 id="_1-1-什么是kube-proxy" tabindex="-1">1.1 什么是kube-proxy <a class="header-anchor" href="#_1-1-什么是kube-proxy" aria-label="Permalink to &quot;1.1 什么是kube-proxy&quot;">​</a></h2><h2 id="_1-2-kube-proxy-作用是什么" tabindex="-1">1.2 kube-proxy 作用是什么? <a class="header-anchor" href="#_1-2-kube-proxy-作用是什么" aria-label="Permalink to &quot;1.2 kube-proxy 作用是什么?&quot;">​</a></h2><ol><li><strong>服务代理</strong>： kube-proxy将Kubernetes的服务抽象（Service）转换为实际的网络路由规则，使得Pod可以相互通信，并且外部流量可以正确地流入到服务背后的一组Pod中。例如，当创建一个Service时，kube-proxy会确保所有匹配该Service标签选择器的Pod能够通过Service的虚拟IP地址（ClusterIP）或NodePort、LoadBalancer类型的外部IP地址进行访问。</li><li><strong>网络模式支持</strong>： <ul><li>在iptables模式下，kube-proxy通过监控Kubernetes API服务器的变化，动态更新节点上的iptables规则，从而将流入服务IP或端口的流量转发到后端对应的Pod实例。</li><li>在IPVS模式下，kube-proxy使用内核中的IP Virtual Server（IPVS）模块来提供更高效、更灵活的负载均衡策略，比如轮询、最少连接数、会话亲和性等。</li><li>用户空间模式已经不再推荐使用，在早期版本中，kube-proxy会在用户态实现类似的负载均衡功能，但性能较低且复杂度较高。</li></ul></li><li><strong>网络策略实施</strong>： kube-proxy虽然不直接管理网络策略，但它通过配置相应的网络规则间接实现了网络策略的一部分，允许或拒绝来自特定源到特定目标的服务请求。</li></ol><h2 id="_1-3-kube-proxy-ipvs-和-iptables-有何异同" tabindex="-1">1.3 kube-proxy ipvs 和 iptables 有何异同？ <a class="header-anchor" href="#_1-3-kube-proxy-ipvs-和-iptables-有何异同" aria-label="Permalink to &quot;1.3 kube-proxy ipvs 和 iptables 有何异同？&quot;">​</a></h2><h3 id="相同点" tabindex="-1">相同点： <a class="header-anchor" href="#相同点" aria-label="Permalink to &quot;相同点：&quot;">​</a></h3><ol><li><strong>目标</strong>：无论是iptables还是IPVS模式，kube-proxy的目标都是将流入集群的服务请求透明地转发到后端Pod，并且根据Service的定义提供负载均衡。</li><li><strong>基于内核</strong>：两种模式都依赖于Linux内核的功能进行网络数据包处理。</li><li><strong>服务发现与更新</strong>：kube-proxy都会监听Kubernetes API服务器，动态地响应Service和Endpoints的变化，并更新相应的规则以保持与集群状态同步。</li></ol><h3 id="不同点" tabindex="-1">不同点： <a class="header-anchor" href="#不同点" aria-label="Permalink to &quot;不同点：&quot;">​</a></h3><ol><li><strong>设计定位</strong>： <ul><li><strong>iptables</strong>：最初设计用于包过滤、网络地址转换（NAT）以及基础的负载均衡，它基于Netfilter框架，是Linux系统中的通用防火墙和网络管理工具。</li><li><strong>IPVS</strong>：专门针对高性能负载均衡而设计，提供了更高级的负载均衡算法（如加权轮询、最少连接等）和更好的可扩展性，尤其是在大规模集群和服务数量增加的情况下。</li></ul></li><li><strong>性能与效率</strong>： <ul><li><strong>iptables</strong>：对于大量服务和频繁变化的场景，iptables可能因为每次变更都需要重新计算和刷新整个规则链而导致性能开销较大。</li><li><strong>IPVS</strong>：采用哈希表存储和查找服务规则，具有较低的延迟和更高的吞吐量，尤其适合大规模集群环境下对性能要求较高的应用场景。</li></ul></li><li><strong>复杂度与灵活性</strong>： <ul><li><strong>iptables</strong>：虽然灵活但规则相对复杂，当规则数量增长时，管理和维护成本可能上升。</li><li><strong>IPVS</strong>：由于专为负载均衡优化，其内部结构更加简洁，管理起来通常更为高效。</li></ul></li><li><strong>功能特性</strong>： <ul><li><strong>iptables</strong>：支持基本的SNAT/DNAT转换以及简单的会话保持功能，但在高并发和长连接场景下可能表现欠佳。</li><li><strong>IPVS</strong>：除了基本的负载均衡外，还支持丰富的会话持久化策略（如源IP、目的IP、客户端cookie等），并且对TCP/UDP协议的长连接有更好的支持。</li></ul></li></ol><h2 id="_1-4-kube-proxy-ipvs-原理是什么" tabindex="-1">1.4 kube-proxy ipvs 原理是什么？ <a class="header-anchor" href="#_1-4-kube-proxy-ipvs-原理是什么" aria-label="Permalink to &quot;1.4 kube-proxy ipvs 原理是什么？&quot;">​</a></h2><ol><li><strong>监听API服务器</strong>： kube-proxy启动后会持续监听Kubernetes API服务器上的Service资源对象的变化。每当有新的Service创建、更新或删除时，kube-proxy都会收到通知。</li><li><strong>配置IPVS规则</strong>： 当一个新的Service被创建时，kube-proxy会根据Service的定义信息，在内核中的IPVS（IP Virtual Server）表中创建相应的虚拟服务（Virtual Server）。这个虚拟服务对应的是Service的Cluster IP和端口。</li><li><strong>后端Endpoint管理</strong>： 同样地，kube-proxy会关注Endpoints资源的变化，即Pod的IP地址和端口集合。当匹配Service选择器的Pod发生变化时（例如Pod创建或销毁），kube-proxy会动态地将这些Pod的实际IP和端口添加到或从IPVS的Real Server列表中移除，确保虚拟服务与实际后端Pod保持同步。</li><li><strong>负载均衡策略</strong>： IPVS提供了多种负载均衡算法，如轮询、最少连接、源哈希等。kube-proxy可以根据Service配置选择合适的负载均衡策略，并将其应用于IPVS规则中。</li><li><strong>数据包转发</strong>： 网络流量到达Service的Cluster IP时，内核中的IPVS模块会根据已配置的虚拟服务和真实服务器列表进行负载均衡处理，将流量透明地转发至正确的后端Pod</li></ol><h2 id="_1-5-kube-proxy-iptables-原理是什么" tabindex="-1">1.5 kube-proxy iptables 原理是什么？ <a class="header-anchor" href="#_1-5-kube-proxy-iptables-原理是什么" aria-label="Permalink to &quot;1.5 kube-proxy iptables 原理是什么？&quot;">​</a></h2><ol><li><strong>监听API Server</strong>： kube-proxy在每个集群节点上运行，并持续监听Kubernetes API服务器中的Service和Endpoints资源的变化。</li><li><strong>创建NAT规则</strong>： 当一个新的Service被创建或已有Service的Endpoints发生变化时，kube-proxy会根据Service的定义为其生成相应的iptables NAT规则。这些规则通常包括： <ul><li><strong>SNAT（源地址转换）</strong>：当集群内部的Pod尝试访问一个ClusterIP类型的Service时，iptables规则将源Pod的IP地址转换为Service IP，确保请求能够到达Service对应的负载均衡器。</li><li><strong>DNAT（目标地址转换）</strong>：对于从外部流入集群或者集群内部流向ClusterIP的服务流量，iptables规则将目标地址（即Service ClusterIP）转换为实际后端Pod的IP地址，并转发到选定的Pod实例上。这种转换通过kube-proxy维护的随机或轮询等策略来选择具体的目标Pod。</li></ul></li><li><strong>维护Session亲和性（如果需要）</strong>： 根据Service配置，kube-proxy可能还会设置额外的iptables规则以保持客户端与后端Pod之间的会话亲和性，确保同一客户端的后续请求会被转发到先前处理该请求的同一个Pod上。</li><li><strong>健康检查和负载均衡</strong>： 虽然kube-proxy不直接进行健康检查，但其依赖于Endpoints控制器提供的信息，仅将流量导向已标记为“健康”的Pod。此外，通过动态更新iptables规则，kube-proxy可以实现基本的负载均衡功能。</li></ol>',13),s=[l];function a(n,u,p,b,P,d){return r(),o("div",null,s)}const k=e(t,[["render",a]]);export{g as __pageData,k as default};
