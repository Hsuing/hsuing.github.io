import{_ as a,o as e,c as o,R as r}from"./chunks/framework.zUbWieqp.js";const g=JSON.parse('{"title":"1. go学习线路","description":"","frontmatter":{},"headers":[],"relativePath":"guide/go/index.md","filePath":"guide/go/index.md","lastUpdated":1733478481000}'),t={name:"guide/go/index.md"},i=r('<h1 id="_1-go学习线路" tabindex="-1">1. go学习线路 <a class="header-anchor" href="#_1-go学习线路" aria-label="Permalink to &quot;1. go学习线路&quot;">​</a></h1><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202312010941043.png" alt="golang-developer-roadmap-zh-CN"></p><h1 id="_2-go社区" tabindex="-1">2. go社区 <a class="header-anchor" href="#_2-go社区" aria-label="Permalink to &quot;2. go社区&quot;">​</a></h1><p><a href="http://learnku.com" target="_blank" rel="noreferrer">http://learnku.com</a></p><p>go语言基础，<a href="https://learnku.com/go/wikis/38122" target="_blank" rel="noreferrer">https://learnku.com/go/wikis/38122</a></p><h1 id="_3-程序开发通用思想" tabindex="-1">3. 程序开发通用思想 <a class="header-anchor" href="#_3-程序开发通用思想" aria-label="Permalink to &quot;3. 程序开发通用思想&quot;">​</a></h1><h2 id="_3-1-认识开发语言" tabindex="-1">3.1 认识开发语言 <a class="header-anchor" href="#_3-1-认识开发语言" aria-label="Permalink to &quot;3.1 认识开发语言&quot;">​</a></h2><h2 id="_3-2-开发语言对比和擅长领域分析" tabindex="-1">3.2 开发语言对比和擅长领域分析 <a class="header-anchor" href="#_3-2-开发语言对比和擅长领域分析" aria-label="Permalink to &quot;3.2 开发语言对比和擅长领域分析&quot;">​</a></h2><h2 id="_3-3-理解编译型和解释型语言" tabindex="-1">3.3 理解编译型和解释型语言 <a class="header-anchor" href="#_3-3-理解编译型和解释型语言" aria-label="Permalink to &quot;3.3 理解编译型和解释型语言&quot;">​</a></h2><p>编译型和解释型的区别</p><p><code>编译型</code>：将源代码通过编译器转化为一个可以运行的“包”（机器码，二进制），然后在计算机上直接执行。因为机器码是计算机能够直接理解的，所以其运行速度通常比解释型语言快。</p><p><code>解释型</code>：不需要编译成机器码，而是由解释器逐行解释执行程序代码。由于解释器需要动态翻译代码，所以其运行速度通常比编译型语言慢一些，但开发效率较高，更加易于调试和修改。</p><p><strong>编译型和解释型的优缺点</strong></p><p>编译型：</p><p>​ 优点：运行速度快、执行效率高、可移植性强。</p><p>​ 缺点：需要编译成机器码，开发和调试时间通常较长；程序在不同的平台上需要重新编译。</p><p>解释型：</p><p>​ 优点：开发效率高、调试方便，</p><p>​ 缺点：执行效率低、运行速度慢、可移植性弱；程序在不同的平台上需要重新安装依赖包。</p><h2 id="_3-4-理解常量和变量" tabindex="-1">3.4 理解常量和变量 <a class="header-anchor" href="#_3-4-理解常量和变量" aria-label="Permalink to &quot;3.4 理解常量和变量&quot;">​</a></h2><p>变量和常量的含义</p><p>数学中的变量和常量</p><h2 id="_3-5-理解数据类型" tabindex="-1">3.5 理解数据类型 <a class="header-anchor" href="#_3-5-理解数据类型" aria-label="Permalink to &quot;3.5 理解数据类型&quot;">​</a></h2><p>整型</p><p>浮点型</p><p>布尔值</p><p>字符串</p><h2 id="_3-6-理解数据结构" tabindex="-1">3.6 理解数据结构 <a class="header-anchor" href="#_3-6-理解数据结构" aria-label="Permalink to &quot;3.6 理解数据结构&quot;">​</a></h2><p>数组</p><p>切片/列表</p><p>对象/字典</p><p>数据嵌套</p><h2 id="_3-7-理解强类型语言和弱类型语言" tabindex="-1">3.7 理解强类型语言和弱类型语言 <a class="header-anchor" href="#_3-7-理解强类型语言和弱类型语言" aria-label="Permalink to &quot;3.7 理解强类型语言和弱类型语言&quot;">​</a></h2><p>强类型：编译或运行时会更严格地检查变量的类型一致性(定义string类型,var s string=10,会导致编译失败)</p><p>弱类型：编译器会自动进行类型转换(var s=&quot;han&quot;)</p><h2 id="_3-8-理解运算符" tabindex="-1">3.8 理解运算符 <a class="header-anchor" href="#_3-8-理解运算符" aria-label="Permalink to &quot;3.8 理解运算符&quot;">​</a></h2><p>算术/比较/逻辑运算符</p><h2 id="_3-9-理解逻辑控制" tabindex="-1">3.9 理解逻辑控制 <a class="header-anchor" href="#_3-9-理解逻辑控制" aria-label="Permalink to &quot;3.9 理解逻辑控制&quot;">​</a></h2><p>if-else/switch</p><p>for/while</p><h2 id="_4-0-理解函数" tabindex="-1">4.0 理解函数 <a class="header-anchor" href="#_4-0-理解函数" aria-label="Permalink to &quot;4.0 理解函数&quot;">​</a></h2><h2 id="_4-1-理解代码风格规范" tabindex="-1">4.1 理解代码风格规范 <a class="header-anchor" href="#_4-1-理解代码风格规范" aria-label="Permalink to &quot;4.1 理解代码风格规范&quot;">​</a></h2><p>代码开发规范的重要性</p><p>变量命名规范</p><p>函数命名规范</p><p>代码注释规范</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202412061127094.png" alt=""></p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202412041519222.png" alt=""></p>',48),n=[i];function h(p,l,s,d,c,_){return e(),o("div",null,n)}const m=a(t,[["render",h]]);export{g as __pageData,m as default};
