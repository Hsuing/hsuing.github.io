import{_ as e,o as n,c as i,R as s}from"./chunks/framework.zUbWieqp.js";const c=JSON.parse('{"title":"1. Jenkins slave简述","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/CICD/base_jenkins/index.md","filePath":"guide/container/k8s/CICD/base_jenkins/index.md","lastUpdated":1722954450000}'),l={name:"guide/container/k8s/CICD/base_jenkins/index.md"},a=s('<h1 id="_1-jenkins-slave简述" tabindex="-1">1. Jenkins slave简述 <a class="header-anchor" href="#_1-jenkins-slave简述" aria-label="Permalink to &quot;1. Jenkins slave简述&quot;">​</a></h1><p>Jenkins基于&quot;kubernetes plugin&quot;与k8s集成，可以使Jenkins slave以pod的形式在k8s集群内部动态构建、运行、销毁等。</p><p>通过<a href="https://github.com/jenkinsci/kubernetes-plugin" target="_blank" rel="noreferrer"> jenkinsci/kubernetes-plugin </a>了解到，Jenkins master既可以运行在k8s集群内，也可运行在k8s集群外，但是Jenkins slave的整个生命周期都是在k8s集群内，并且通过JNLP与Jenkins master连接。</p><p>Jenkins 具有以下特点：</p><ul><li>开源：Jenkins 是一个开源软件，可以免费使用。</li><li>易用：Jenkins 提供了丰富的插件和模板，可以快速地搭建自动化构建和部署流程。</li><li>可扩展：Jenkins 支持插件扩展，可以满足不同项目的需求。</li><li>支持多种编程语言：Jenkins 支持多种编程语言，如 Java、Python、Ruby 等。</li><li>支持多种构建工具：Jenkins 支持多种构建工具，如 Maven、Gradle、Ansible 等。</li><li>支持多种部署方式：Jenkins 支持多种部署方式，如 SCM 仓库、Git 仓库、SVN 仓库等。</li><li>支持多种测试工具：Jenkins 支持多种测试工具，如 Selenium、JUnit、SonarQube 等。</li></ul><p>在生产环境中我们往往会在物理机或者虚拟机上部署jenkins，但是这种部署方式会有一些痛点，如下：</p><ul><li>主 Master 发生单点故障时，整个流程都不可用了</li><li>每个 Slave 的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置导致管理起来非常不方便，维护起来也是比较费劲</li><li>资源分配不均衡，有的 Slave 要运行的 job 出现排队等待，而有的 Slave 处于空闲状态</li><li>资源有浪费，每台 Slave 可能是物理机或者虚拟机，当 Slave 处于空闲状态时，也不会完全释放掉资源。</li><li>扩展性差：在物理机或虚拟机上部署 Jenkins，当 Jenkins 需要扩展时，需要购买更多的服务器或虚拟机，扩展性较差。</li></ul><h2 id="_1-1-基于k8s动态slave模式" tabindex="-1">1.1 基于K8s动态Slave模式 <a class="header-anchor" href="#_1-1-基于k8s动态slave模式" aria-label="Permalink to &quot;1.1 基于K8s动态Slave模式&quot;">​</a></h2><p>优点：</p><ul><li>基于云原生现有K8s集群来解决问题，充分的利用现有资源，无需再申请新虚机；</li><li>Slave可在构建任务来之时动态创建，工作结束后自动销毁，释放资源；</li><li>可通过K8s原生来管理Jenkins的调度策略，防止Slave调度分配不均匀；</li><li>通过云原生控制器来管理Jenkins配置，后期比较利于维护、扩展；</li><li>Jenkins 小概率意外宕机场景，通过K8s的机制可以自愈；</li></ul><p>缺点：</p><ul><li>增加了系统复杂度；</li><li>有一定技术壁垒；</li><li>实现需要时间；</li></ul><h2 id="_1-2-master-slave原理" tabindex="-1">1.2 Master-Slave原理 <a class="header-anchor" href="#_1-2-master-slave原理" aria-label="Permalink to &quot;1.2 Master-Slave原理&quot;">​</a></h2><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407311511092.png" alt="img"></p><p>从上图中可以看出，Jenkins Master和Jenkins Slave以Pod的形式运行在Kubernetes集群的节点上。Master运行在其中的一个节点上，并将其配置数据存储到一个Volume中，而Slave运行在各个节点上，并且它并不总是处于运行状态，它会根据需求动态地创建并自动删除。</p><p>这种方法的工作流程大致如下：当Jenkins Master收到一个构建请求时，它会根据配置的Label动态地创建一个运行在Pod中的Jenkins Slave并将其注册到Master上。在运行完Job之后，这个Slave会被注销，Pod也会自动删除，恢复到原始状态。</p><p><strong>设计优势</strong></p><ul><li><p>动态伸缩</p><p>合理的使用资源，每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后， Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高， 还排队等待在该节点的情况。</p></li><li><p>服务高可用</p><p>当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。</p></li><li><p>扩展性好</p><p>当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一 个 Kubernetes Node 到集群中，从而实现扩展。</p></li></ul>',18),t=[a];function r(o,k,p,u,d,_){return n(),i("div",null,t)}const v=e(l,[["render",r]]);export{c as __pageData,v as default};
