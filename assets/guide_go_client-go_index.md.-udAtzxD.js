import{_ as e,o as n,c as s,R as a}from"./chunks/framework.zUbWieqp.js";const y=JSON.parse('{"title":"1. Client-go介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/go/client-go/index.md","filePath":"guide/go/client-go/index.md","lastUpdated":1721805479000}'),l={name:"guide/go/client-go/index.md"},t=a(`<h1 id="_1-client-go介绍" tabindex="-1">1. Client-go介绍 <a class="header-anchor" href="#_1-client-go介绍" aria-label="Permalink to &quot;1. Client-go介绍&quot;">​</a></h1><ul><li><code>client-go</code>是<code>kubernetes</code>官方提供的go语言的客户端库，go应用使用该库可以访问<code>kubernetes</code>的<code>API Server</code>，这样我们就能通过编程来对<code>kubernetes</code>资源进行增删改查操作。</li><li>除了提供丰富的<code>API</code>用于操作<code>kubernetes</code>资源，<code>client-go</code>还为<code>controller</code>和<code>operator</code>提供了重要支持，如下图，<code>client-go</code>的<code>informer</code>机制可以将<code>controller</code>关注的资源变化及时带给此<code>controller</code>，使<code>controller</code>能够及时响应变化：</li></ul><p>架构图:</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407191127679.png" alt="client-go-image.png"></p><h1 id="_2-client-go代码结构" tabindex="-1">2. Client-go代码结构 <a class="header-anchor" href="#_2-client-go代码结构" aria-label="Permalink to &quot;2. Client-go代码结构&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ tree -L 2 client-go</span></span>
<span class="line"><span style="color:#e1e4e8;">client-go</span></span>
<span class="line"><span style="color:#e1e4e8;">├── discovery    # 包含dicoveryClient，用于发现k8s所支持GVR(Group/Version,/Resource),&#39;kubectl api-resources&#39;命令正是使用它来列出cluster中的各种资源。</span></span>
<span class="line"><span style="color:#e1e4e8;">├── dynamic  # 包含dynamicClient，它封装了 RESTClient，可以动态的指定api资源的GVR，结合unstructured.Unstructured类型来访问各种类型的k8s资源(如: Pod,Deploy...)，也可以访问用户自定义资源(CRD)。</span></span>
<span class="line"><span style="color:#e1e4e8;">├── informers # 为了减少client对于apiserver的频繁访问，需要informer来缓存apiserver中资源，只有当api资源对象发生变化的时候才收到通知。每种api资源会有自己的informer实现，也是按照api分组与版本来区分。</span></span>
<span class="line"><span style="color:#e1e4e8;">├── kubernetes # 主要定义ClientSet，它也对restClient进行了封装，并且包含对各种k8s资源和版本的管理方法。每个api资源有单独的client，而ClientSet则是多个客户端的集合。ClientSet以及每种k8s内置资源的client的所有请求最终还是由restClient发出的；在typed目录包括具体每种k8s内置资源的client实现，也是按照api分组与版本来区分。</span></span>
<span class="line"><span style="color:#e1e4e8;">│   ├── clientset.go</span></span>
<span class="line"><span style="color:#e1e4e8;">│   └── typed</span></span>
<span class="line"><span style="color:#e1e4e8;">├── listers # 包含各种k8s内置资源的只读客户端。每种lister都有Get()和List()方法，并且结果都是从缓存中读取的。</span></span>
<span class="line"><span style="color:#e1e4e8;">├── rest # 包含真正给apiserver发请求的client，实现了Restful的API，同时支持Protobuf和JSON格式数据。</span></span>
<span class="line"><span style="color:#e1e4e8;">├── scale # 只要包含scalClient用于Deploy, RS等的扩/缩容。</span></span>
<span class="line"><span style="color:#e1e4e8;">├── tools # 各种类型的工具包，常见的比如获取kubeconfig的方法，以SharedInformer、Reflector、DealtFIFO和Indexer等工具，这些工具主要用于实现client查询和缓存机制，减轻apiserver的负载等。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ tree -L 2 client-go</span></span>
<span class="line"><span style="color:#24292e;">client-go</span></span>
<span class="line"><span style="color:#24292e;">├── discovery    # 包含dicoveryClient，用于发现k8s所支持GVR(Group/Version,/Resource),&#39;kubectl api-resources&#39;命令正是使用它来列出cluster中的各种资源。</span></span>
<span class="line"><span style="color:#24292e;">├── dynamic  # 包含dynamicClient，它封装了 RESTClient，可以动态的指定api资源的GVR，结合unstructured.Unstructured类型来访问各种类型的k8s资源(如: Pod,Deploy...)，也可以访问用户自定义资源(CRD)。</span></span>
<span class="line"><span style="color:#24292e;">├── informers # 为了减少client对于apiserver的频繁访问，需要informer来缓存apiserver中资源，只有当api资源对象发生变化的时候才收到通知。每种api资源会有自己的informer实现，也是按照api分组与版本来区分。</span></span>
<span class="line"><span style="color:#24292e;">├── kubernetes # 主要定义ClientSet，它也对restClient进行了封装，并且包含对各种k8s资源和版本的管理方法。每个api资源有单独的client，而ClientSet则是多个客户端的集合。ClientSet以及每种k8s内置资源的client的所有请求最终还是由restClient发出的；在typed目录包括具体每种k8s内置资源的client实现，也是按照api分组与版本来区分。</span></span>
<span class="line"><span style="color:#24292e;">│   ├── clientset.go</span></span>
<span class="line"><span style="color:#24292e;">│   └── typed</span></span>
<span class="line"><span style="color:#24292e;">├── listers # 包含各种k8s内置资源的只读客户端。每种lister都有Get()和List()方法，并且结果都是从缓存中读取的。</span></span>
<span class="line"><span style="color:#24292e;">├── rest # 包含真正给apiserver发请求的client，实现了Restful的API，同时支持Protobuf和JSON格式数据。</span></span>
<span class="line"><span style="color:#24292e;">├── scale # 只要包含scalClient用于Deploy, RS等的扩/缩容。</span></span>
<span class="line"><span style="color:#24292e;">├── tools # 各种类型的工具包，常见的比如获取kubeconfig的方法，以SharedInformer、Reflector、DealtFIFO和Indexer等工具，这些工具主要用于实现client查询和缓存机制，减轻apiserver的负载等。</span></span></code></pre></div><h1 id="_3-client-go版本" tabindex="-1">3. Client-go版本 <a class="header-anchor" href="#_3-client-go版本" aria-label="Permalink to &quot;3. Client-go版本&quot;">​</a></h1><p>client-go官方提供了多个版本，并且给出了和kubernetes版本的匹配列表，具体访问官方 <a href="https://github.com/kubernetes/client-go" target="_blank" rel="noreferrer">github</a> 查看</p><h1 id="_4-client-go客户端对象" tabindex="-1">4. Client-go客户端对象 <a class="header-anchor" href="#_4-client-go客户端对象" aria-label="Permalink to &quot;4. Client-go客户端对象&quot;">​</a></h1><p>Client-go 提供了以下四种客户端对象与kubernetes的API Server进行交互</p><h2 id="_4-1-restclient" tabindex="-1">4.1 RESTClient <a class="header-anchor" href="#_4-1-restclient" aria-label="Permalink to &quot;4.1 RESTClient&quot;">​</a></h2><p>这是最基础的客户端对象，仅对HTTPRequest进行了封装，实现RESTFul风格API，这个对象的使用并不方便，因为很多参数都要使用者来设置，于是client-go基于RESTClient又实现了三种新的客户端对象</p><h2 id="_4-2-clientset" tabindex="-1">4.2 ClientSet <a class="header-anchor" href="#_4-2-clientset" aria-label="Permalink to &quot;4.2 ClientSet&quot;">​</a></h2><p>把Resource和Version也封装成方法了，用起来更简单直接，一个资源是一个客户端，多个资源就对应了多个客户端，所以ClientSet就是多个客户端的集合了，这样就好理解了，不过ClientSet只能访问内置资源，访问不了自定义资源。</p><h2 id="_4-3-dynamicclient" tabindex="-1">4.3 DynamicClient <a class="header-anchor" href="#_4-3-dynamicclient" aria-label="Permalink to &quot;4.3 DynamicClient&quot;">​</a></h2><p>可以访问内置资源和自定义资源，拿出的内容是Object类型，按实际情况自己去做强制转换，当然了也会有强转失败的风险。</p><h2 id="_4-4-discoveryclient" tabindex="-1">4.4 DiscoveryClient <a class="header-anchor" href="#_4-4-discoveryclient" aria-label="Permalink to &quot;4.4 DiscoveryClient&quot;">​</a></h2><p>用于发现kubernetes的API Server支持的Group、Version、Resources等信息</p><h2 id="_4-5-各模块的依赖关系" tabindex="-1">4.5 各模块的依赖关系 <a class="header-anchor" href="#_4-5-各模块的依赖关系" aria-label="Permalink to &quot;4.5 各模块的依赖关系&quot;">​</a></h2><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407191133686.jpeg" alt="client-go-module.jpg"></p><p>从上面可以看到，不管是各种静态类型的客户端 <code>ClientSet</code> ，动态客户端 <code>DynamicClient</code> 还是资源发现客户端 <code>DiscoveryClient</code> 都封装了 <code>RESTClient</code>，也就是说最后请求的发送都是有 <code>RESTClient</code> 发送给 <code>kube-apiserver</code> 的。而 <code>k8s.io/api-machinery</code> 中 <code>API</code> 资源的分组与版本是所有类型客户端的基础，具体每种 <code>API</code> 资源的定义则是包含在 <code>k8s.io/api</code> 模块</p>`,21),o=[t];function i(c,r,p,d,u,h){return n(),s("div",null,o)}const C=e(l,[["render",i]]);export{y as __pageData,C as default};
