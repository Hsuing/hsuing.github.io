import{_ as e,o as r,c as t,R as o}from"./chunks/framework.zUbWieqp.js";const h=JSON.parse('{"title":"1. Kubernetes的控制平面包括哪些核心组件？它们各自的作用是什么？","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/interview/index.md","filePath":"guide/container/k8s/interview/index.md","lastUpdated":1715940689000}'),n={name:"guide/container/k8s/interview/index.md"},s=o('<h1 id="_1-kubernetes的控制平面包括哪些核心组件-它们各自的作用是什么" tabindex="-1">1. Kubernetes的控制平面包括哪些核心组件？它们各自的作用是什么？ <a class="header-anchor" href="#_1-kubernetes的控制平面包括哪些核心组件-它们各自的作用是什么" aria-label="Permalink to &quot;1. Kubernetes的控制平面包括哪些核心组件？它们各自的作用是什么？&quot;">​</a></h1><p><strong>A1.</strong> 控制平面包括：</p><ul><li><strong>API Server</strong>：提供集群的前端接口，处理REST请求，存储数据到etcd，并与其他组件通信。</li><li><strong>etcd</strong>：分布式键值存储，保存集群的配置数据和状态。</li><li><strong>Controller Manager</strong>：管理控制器，如ReplicationController、Deployment Controller，确保实际状态与期望状态一致。</li><li><strong>Scheduler</strong>：根据资源情况，将待调度的Pod分配到合适的节点上。</li></ul><h1 id="_2-kubernetes的数据平面涉及哪些组件-它们如何协作" tabindex="-1">2. Kubernetes的数据平面涉及哪些组件？它们如何协作？ <a class="header-anchor" href="#_2-kubernetes的数据平面涉及哪些组件-它们如何协作" aria-label="Permalink to &quot;2. Kubernetes的数据平面涉及哪些组件？它们如何协作？&quot;">​</a></h1><p><strong>A2.</strong> 数据平面主要包括：</p><ul><li><strong>kubelet</strong>：在每个节点上运行，负责Pod的创建、启停等生命周期管理。</li><li><strong>kube-proxy</strong>：实现服务的网络代理功能，如负载均衡，确保 Pod 间通讯。</li><li><strong>容器运行时</strong>（如Docker或containerd）：在节点上执行容器。</li></ul><h1 id="_3-什么是pod-为什么它是kubernetes的基本单元" tabindex="-1">3. 什么是Pod？为什么它是Kubernetes的基本单元？ <a class="header-anchor" href="#_3-什么是pod-为什么它是kubernetes的基本单元" aria-label="Permalink to &quot;3. 什么是Pod？为什么它是Kubernetes的基本单元？&quot;">​</a></h1><p><strong>A3.</strong> Pod是最小的可部署单元，可以包含一个或多个紧密相关的容器，共享存储和网络命名空间。Pod设计允许容器间紧密交互，简化配置管理，因此成为部署和管理的最小单位</p><h1 id="_4-service如何实现服务发现和负载均衡" tabindex="-1">4. Service如何实现服务发现和负载均衡？ <a class="header-anchor" href="#_4-service如何实现服务发现和负载均衡" aria-label="Permalink to &quot;4. Service如何实现服务发现和负载均衡？&quot;">​</a></h1><p><strong>A4.</strong> Service定义了访问一组Pod的方式，通过Cluster IP、NodePort、LoadBalancer或Ingress等，提供稳定的访问地址和负载均衡，确保请求均匀分配到后端Pod。</p><h1 id="_5-kubernetes网络模型的核心原则是什么" tabindex="-1">5. Kubernetes网络模型的核心原则是什么？ <a class="header-anchor" href="#_5-kubernetes网络模型的核心原则是什么" aria-label="Permalink to &quot;5. Kubernetes网络模型的核心原则是什么？&quot;">​</a></h1><p><strong>A5.</strong> 核心原则是 “每个Pod一个IP”，确保Pod间通信像在同一局域网内一样简单，且不依赖于Pod所在的节点。网络插件（如Flannel、Calico）实现此模型。</p><h1 id="_6-kubernetes如何管理持久化存储" tabindex="-1">6. Kubernetes如何管理持久化存储？ <a class="header-anchor" href="#_6-kubernetes如何管理持久化存储" aria-label="Permalink to &quot;6. Kubernetes如何管理持久化存储？&quot;">​</a></h1><p><strong>A6.</strong> 通过Persistent Volumes (PV) 和 Persistent Volume Claims (PVC)。PV代表集群中的一块存储资源，而PVC是用户对存储的请求。Kubernetes自动或手动匹配PV和PVC，实现存储资源的动态分配和回收。</p><h1 id="_7-kubernetes如何实现访问控制和权限管理" tabindex="-1">7. Kubernetes如何实现访问控制和权限管理？ <a class="header-anchor" href="#_7-kubernetes如何实现访问控制和权限管理" aria-label="Permalink to &quot;7. Kubernetes如何实现访问控制和权限管理？&quot;">​</a></h1><p><strong>A7.</strong> 使用Role-Based Access Control (RBAC)，通过角色和角色绑定来控制用户或服务账户对资源的操作权限，确保最小权限原则。</p><p><strong>1）Role（角色）</strong>：Role 定义了一组操作权限的集合，可以授予指定命名空间内的用户或用户组。Role 只能用于授予命名空间内资源的权限，如 Pod、Service、Deployment 等。</p><p><strong>2）RoleBinding（角色绑定）</strong>：RoleBinding 将 Role 与用户或用户组之间进行绑定，指定了哪些用户或用户组具有特定的权限。一个 RoleBinding 可以将多个用户或用户组与一个 Role 相关联。</p><p><strong>3）ClusterRole（集群角色）</strong>：ClusterRole 类似于 Role，但作用范围更广泛，可以授予集群范围内资源的权限，如节点、命名空间、PersistentVolume 等。ClusterRole 不限于单个命名空间。</p><p><strong>4）ClusterRoleBinding（集群角色绑定）</strong>：ClusterRoleBinding 将 ClusterRole 与用户或用户组之间进行绑定，指定了哪些用户或用户组具有特定的集群级别权限。一个 ClusterRoleBinding 可以将多个用户或用户组与一个 ClusterRole 相关联。</p><h1 id="_8-如何确保kubernetes集群的安全性" tabindex="-1">8. 如何确保Kubernetes集群的安全性？ <a class="header-anchor" href="#_8-如何确保kubernetes集群的安全性" aria-label="Permalink to &quot;8. 如何确保Kubernetes集群的安全性？&quot;">​</a></h1><p><strong>A8.</strong> 安全措施包括：使用安全网络策略限制Pod间通信，加密通信（如TLS），使用安全的容器运行时，定期安全扫描，管理好Secrets和ConfigMaps，以及启用网络策略和Pod安全策略等。</p><h1 id="_9-在kubernetes中-你如何管理持久化存储" tabindex="-1">9. 在Kubernetes中，你如何管理持久化存储？ <a class="header-anchor" href="#_9-在kubernetes中-你如何管理持久化存储" aria-label="Permalink to &quot;9. 在Kubernetes中，你如何管理持久化存储？&quot;">​</a></h1><p><strong>A9.</strong> 在Kubernetes中，管理持久化存储通常使用PersistentVolumes (PV) 和 PersistentVolumeClaims (PVC)。PV是集群中一块可用的网络存储，而PVC是用户存储需求的声明。PVC和PV之间的关系是通过匹配PVC的需求与PV的属性来实现的。</p><p>用户通过创建PVC来请求特定大小和访问模式的存储，而集群管理员则负责创建PV，这些PV可以绑定到PVC上以满足用户的存储需求。此外，还可以使用StorageClass来实现动态的存储供应，即当PVC被创建时，会自动根据StorageClass的定义来创建PV。</p><h1 id="_10-描述kubernetes的亲和性和反亲和性规则-并解释它们如何影响pod的调度" tabindex="-1">10. 描述Kubernetes的亲和性和反亲和性规则，并解释它们如何影响Pod的调度 <a class="header-anchor" href="#_10-描述kubernetes的亲和性和反亲和性规则-并解释它们如何影响pod的调度" aria-label="Permalink to &quot;10. 描述Kubernetes的亲和性和反亲和性规则，并解释它们如何影响Pod的调度&quot;">​</a></h1><p><strong>A10.</strong> Kubernetes的亲和性和反亲和性规则用于影响Pod的调度。</p><ul><li>亲和性 (Affinity)：指定Pod倾向于被调度到哪些Node上。这可以通过节点亲和性（基于Node的标签）或Pod亲和性（基于其他Pod的标签）来实现。例如，你可能希望将某些Pod调度到具有特定硬件或特定版本操作系统的节点上。</li><li>反亲和性 (Anti-Affinity)：指定Pod不应该被调度到哪些Node上。这通常用于确保Pod之间的高可用性。例如，你可以设置反亲和性规则，使得同一服务的Pod不会被调度到同一个节点上，从而防止节点故障导致服务中断。</li></ul><h1 id="_11-kubernetes中的ingress是什么-它如何工作" tabindex="-1">11. Kubernetes中的Ingress是什么，它如何工作？ <a class="header-anchor" href="#_11-kubernetes中的ingress是什么-它如何工作" aria-label="Permalink to &quot;11. Kubernetes中的Ingress是什么，它如何工作？&quot;">​</a></h1><p><strong>A11.</strong> Ingress是Kubernetes的一个API对象，用于管理外部对集群服务的HTTP和HTTPS访问。它提供了一个外部URL路由到集群内部服务的方式，可以基于域名、路径等规则进行路由。</p><p>Ingress控制器负责实现Ingress对象定义的路由规则。当Ingress对象被创建时，Ingress控制器会读取该对象的配置，并根据配置设置路由规则。常见的Ingress控制器有Nginx Ingress Controller、Traefik等。这些控制器会将Ingress规则转换为Nginx、HAProxy或其他负载均衡器的配置，以实现HTTP和HTTPS路由。</p><h1 id="_12-描述kubernetes中pod的生命周期以及常见的生命周期钩子" tabindex="-1">12. 描述Kubernetes中Pod的生命周期以及常见的生命周期钩子 <a class="header-anchor" href="#_12-描述kubernetes中pod的生命周期以及常见的生命周期钩子" aria-label="Permalink to &quot;12. 描述Kubernetes中Pod的生命周期以及常见的生命周期钩子&quot;">​</a></h1><p><strong>A12.</strong> Pod的生命周期从创建开始，经历运行、重启、终止等状态，最终可能被删除。在这个过程中，Kubernetes提供了多个生命周期钩子，允许用户在Pod的不同阶段执行自定义操作。</p><p>常见的生命周期钩子包括：</p><ul><li><strong>PostStart</strong>：在容器创建后立即执行一次。常用于初始化容器环境或启动后台进程。</li><li><strong>PreStop</strong>：在容器终止之前执行。常用于优雅地关闭容器中的服务或清理资源。</li></ul><h1 id="_13-kubernetes的自动伸缩-autoscaling-是如何工作的" tabindex="-1">13. Kubernetes的自动伸缩（Autoscaling）是如何工作的？ <a class="header-anchor" href="#_13-kubernetes的自动伸缩-autoscaling-是如何工作的" aria-label="Permalink to &quot;13. Kubernetes的自动伸缩（Autoscaling）是如何工作的？&quot;">​</a></h1><p><strong>A13.</strong> Kubernetes支持两种自动伸缩机制：水平伸缩（Horizontal Pod Autoscaling, HPA）和垂直伸缩（Vertical Pod Autoscaling, VPA）。</p><ul><li><strong>水平伸缩（HPA）</strong>：根据Pod的资源使用情况（如CPU、内存）或自定义指标（如应用特定的性能指标）自动增加或减少Pod的副本数量。HPA控制器会定期查询API服务器以获取Pod的资源使用情况，并根据配置的策略进行伸缩操作。</li><li><strong>垂直伸缩（VPA）</strong>：根据Pod的资源使用情况自动调整Pod的资源请求（requests）和限制（limits）。VPA控制器会分析Pod的历史资源使用情况，并预测其未来的资源需求，然后更新Pod的YAML配置文件以实现垂直伸缩。</li></ul><h1 id="_14-什么是kubernetes的service-account-它有什么用途" tabindex="-1">14. 什么是Kubernetes的Service Account，它有什么用途 <a class="header-anchor" href="#_14-什么是kubernetes的service-account-它有什么用途" aria-label="Permalink to &quot;14. 什么是Kubernetes的Service Account，它有什么用途&quot;">​</a></h1><p><strong>A14.</strong> Service Account是Kubernetes中用于访问API服务器的身份凭证。每个Service Account都与一个或多个Secret相关联，这些Secret包含用于身份验证的令牌（token）和证书。</p><p>Service Account的主要用途是为运行在集群中的Pod提供API访问权限。与常规用户账户不同，Service Account与特定的命名空间相关联，并且只能在该命名空间内访问资源。这使得Service Account成为管理Pod对API服务器访问权限的便捷方式。</p><h1 id="_15-描述kubernetes的滚动更新-rolling-update-和重新创建-recreate-策略" tabindex="-1">15. 描述Kubernetes的滚动更新（Rolling Update）和重新创建（Recreate）策略 <a class="header-anchor" href="#_15-描述kubernetes的滚动更新-rolling-update-和重新创建-recreate-策略" aria-label="Permalink to &quot;15. 描述Kubernetes的滚动更新（Rolling Update）和重新创建（Recreate）策略&quot;">​</a></h1><ul><li><strong>滚动更新（Rolling Update）</strong>：滚动更新是Kubernetes中一种用于更新应用程序版本的策略，它可以在不中断服务的情况下逐步替换旧版本的Pod。在滚动更新过程中，新的Pod实例会逐步替换旧的Pod实例，同时确保服务始终可用。这种策略允许管理员控制更新的速度和进度，以便在必要时进行干预和调整。滚动更新可以通过Kubernetes的Deployment对象来实现，它会自动处理Pod的创建、更新和删除操作。</li><li><strong>重新创建（Recreate）</strong>：重新创建是一种更为直接和简单的部署策略，它首先会停止并删除所有旧的Pod实例，然后再创建新的Pod实例。在这个过程中，服务可能会经历短暂的中断。重新创建策略适用于那些可以容忍短暂中断的应用程序，或者当需要进行较大规模的结构性更改时。与滚动更新相比，重新创建策略更为简单和直接，但可能会导致服务的可用性下降。</li></ul><h1 id="_16-kubernetes中的daemonset是什么-它通常用于什么场景" tabindex="-1">16. Kubernetes中的DaemonSet是什么，它通常用于什么场景？ <a class="header-anchor" href="#_16-kubernetes中的daemonset是什么-它通常用于什么场景" aria-label="Permalink to &quot;16. Kubernetes中的DaemonSet是什么，它通常用于什么场景？&quot;">​</a></h1><p><strong>A16.</strong> DaemonSet确保在集群中的每个节点上运行一个Pod的副本。当节点加入集群时，DaemonSet会为其调度一个Pod。当节点从集群中移除时，DaemonSet也会清理该节点上的Pod。DaemonSet通常用于运行集群级别的守护进程，例如存储守护进程、日志收集器、网络插件等。</p><h1 id="_17-kubernetes中的statefulset和deployment有什么区别" tabindex="-1">17. Kubernetes中的StatefulSet和Deployment有什么区别 <a class="header-anchor" href="#_17-kubernetes中的statefulset和deployment有什么区别" aria-label="Permalink to &quot;17. Kubernetes中的StatefulSet和Deployment有什么区别&quot;">​</a></h1><p><strong>A17.</strong> StatefulSet用于管理有状态的应用程序，例如数据库、分布式存储系统等。StatefulSet提供了稳定的网络标识符、稳定的存储和有序的部署、扩展和删除。与Deployment不同，StatefulSet中的Pod不是完全可替换的，每个Pod都有一个唯一的标识。而Deployment主要用于管理无状态的应用程序，它提供了滚动更新、回滚和扩展等功能。</p><h1 id="_18-kubernetes中的configmap和secret如何用于应用程序配置" tabindex="-1">18. Kubernetes中的ConfigMap和Secret如何用于应用程序配置 <a class="header-anchor" href="#_18-kubernetes中的configmap和secret如何用于应用程序配置" aria-label="Permalink to &quot;18. Kubernetes中的ConfigMap和Secret如何用于应用程序配置&quot;">​</a></h1><p><strong>A18.</strong> ConfigMap和Secret都是Kubernetes中用于存储应用程序配置信息的资源对象。ConfigMap用于存储非敏感的配置信息，如配置文件、环境变量等。Secret则用于存储敏感的配置信息，如密码、密钥等。这些信息可以被挂载到Pod中的容器文件系统中，或者以环境变量的形式注入到容器中，供应用程序使用。</p><h1 id="_19-kubernetes中的sidecar容器是什么-它有什么用途" tabindex="-1">19. Kubernetes中的Sidecar容器是什么，它有什么用途 <a class="header-anchor" href="#_19-kubernetes中的sidecar容器是什么-它有什么用途" aria-label="Permalink to &quot;19. Kubernetes中的Sidecar容器是什么，它有什么用途&quot;">​</a></h1><p><strong>A19.</strong> Sidecar容器是与主应用程序容器一起运行的辅助容器，它们共享相同的Pod和网络命名空间。Sidecar容器可以用于提供额外的功能或服务给主应用程序容器，例如日志收集、监控代理、服务发现等。由于它们与主应用程序容器共享相同的网络和存储资源，因此它们可以轻松地访问主应用程序的日志、环境变量和配置信息等。</p><h1 id="_20-kubernetes中的准入控制器-admission-controllers-是什么-它们如何影响集群的行为" tabindex="-1">20. Kubernetes中的准入控制器（Admission Controllers）是什么，它们如何影响集群的行为 <a class="header-anchor" href="#_20-kubernetes中的准入控制器-admission-controllers-是什么-它们如何影响集群的行为" aria-label="Permalink to &quot;20. Kubernetes中的准入控制器（Admission Controllers）是什么，它们如何影响集群的行为&quot;">​</a></h1><p><strong>A20.</strong> 准入控制器是Kubernetes API服务器中的一段代码，用于拦截发送到API服务器的请求，在它们持久化到存储之前进行更改或拒绝。这些控制器允许集群管理员定义并强制执行自定义的策略，以确保请求满足集群的安全性和业务规则。例如，准入控制器可以用于限制对资源的访问、验证Pod的安全配置或实施配额。</p><h1 id="_21-kubernetes中的taint和toleration是什么-它们如何影响pod的调度" tabindex="-1">21. Kubernetes中的Taint和Toleration是什么，它们如何影响Pod的调度？ <a class="header-anchor" href="#_21-kubernetes中的taint和toleration是什么-它们如何影响pod的调度" aria-label="Permalink to &quot;21. Kubernetes中的Taint和Toleration是什么，它们如何影响Pod的调度？&quot;">​</a></h1><p><strong>A21.</strong> Taint是附加到节点的键值对，用于表示节点上的某些属性或条件，这些属性或条件可能会阻止Pod在该节点上运行。</p><p>Toleration是Pod的规格中的字段，用于表示Pod可以容忍哪些Taint。当调度器尝试将Pod调度到节点时，它会检查节点的Taint和Pod的Toleration，以确保Pod可以容忍节点的所有Taint。这允许管理员更精细地控制Pod的调度，例如，将某些类型的Pod限制到具有特定硬件或软件配置的节点上。</p><h1 id="_22-kubernetes中的cni-容器网络接口-是什么-它在集群中的作用是什么" tabindex="-1">22. Kubernetes中的CNI（容器网络接口）是什么，它在集群中的作用是什么 <a class="header-anchor" href="#_22-kubernetes中的cni-容器网络接口-是什么-它在集群中的作用是什么" aria-label="Permalink to &quot;22. Kubernetes中的CNI（容器网络接口）是什么，它在集群中的作用是什么&quot;">​</a></h1><p><strong>A22.</strong> CNI（容器网络接口）是一个规范，用于定义容器如何连接到网络。在Kubernetes集群中，CNI允许使用各种网络插件来实现Pod之间的网络通信。这些插件负责设置网络接口、分配IP地址、配置路由等。通过使用CNI，Kubernetes可以支持多种网络解决方案，包括Flannel、Calico等。</p><h1 id="_23-kubernetes的pod亲和性和反亲和性是什么-它们在调度中的作用是什么" tabindex="-1">23. Kubernetes的Pod亲和性和反亲和性是什么，它们在调度中的作用是什么 <a class="header-anchor" href="#_23-kubernetes的pod亲和性和反亲和性是什么-它们在调度中的作用是什么" aria-label="Permalink to &quot;23. Kubernetes的Pod亲和性和反亲和性是什么，它们在调度中的作用是什么&quot;">​</a></h1><p><strong>A23.</strong> Pod亲和性和反亲和性是Kubernetes调度器中的两个概念，用于控制Pod在集群中的位置。亲和性规则允许管理员指定Pod应该运行（或不应该运行）在具有某些属性的节点上。这些属性可以包括节点的标签、其他Pod的存在或不存在等。通过使用亲和性和反亲和性规则，管理员可以确保Pod被调度到满足其需求的节点上，从而提高集群的可用性和性能。</p><h1 id="_24-在kubernetes中-qos类别是如何定义的-请解释guaranteed、burstable和besteffort的区别" tabindex="-1">24. 在Kubernetes中，QoS类别是如何定义的？请解释Guaranteed、Burstable和BestEffort的区别 <a class="header-anchor" href="#_24-在kubernetes中-qos类别是如何定义的-请解释guaranteed、burstable和besteffort的区别" aria-label="Permalink to &quot;24. 在Kubernetes中，QoS类别是如何定义的？请解释Guaranteed、Burstable和BestEffort的区别&quot;">​</a></h1><p><strong>A24.</strong> 在Kubernetes中，QoS类别是根据Pod的资源请求（request）和限制（limit）来定义的。QoS类别有三种：</p><ul><li><strong>Guaranteed</strong>：Pod中的每个容器都设置了CPU和内存的资源限制，并且限制值等于请求值。这种Pod的QoS最高，调度器会优先调度它们，并且在资源紧张的情况下，它们会被最后终止。</li><li><strong>Burstable</strong>：Pod中的至少一个容器设置了资源请求，但没有设置相应的限制，或者限制值大于请求值。这种Pod的QoS中等，调度器会正常调度它们，并在资源紧张时，根据资源使用情况来决定是否终止它们。</li><li><strong>BestEffort</strong>：Pod没有设置任何资源请求或限制。这种Pod的QoS最低，调度器在资源紧张时会优先终止它们。</li></ul><h1 id="_25-kubernetes中的服务发现是如何工作的" tabindex="-1">25. Kubernetes中的服务发现是如何工作的 <a class="header-anchor" href="#_25-kubernetes中的服务发现是如何工作的" aria-label="Permalink to &quot;25. Kubernetes中的服务发现是如何工作的&quot;">​</a></h1><p><strong>A25.</strong> Kubernetes通过DNS和Service资源对象来实现服务发现。当Pod启动时，它会向集群的DNS服务器注册自己的IP地址和主机名。然后，其他Pod可以通过服务名来访问该Pod，DNS服务器会将服务名解析为对应的Pod IP地址。此外，Kubernetes还提供了Service对象来抽象Pod的集合，并为它们提供负载均衡和发现功能。管理员可以创建Service对象来定义服务的名称、端口和选择器等属性，并将它们与Pod关联起来。其他Pod可以通过Service的名称和端口来访问该服务。</p><h1 id="_26-kubernetes中的podsecuritypolicy是什么-它如何帮助增强集群的安全性" tabindex="-1">26. Kubernetes中的PodSecurityPolicy是什么？它如何帮助增强集群的安全性 <a class="header-anchor" href="#_26-kubernetes中的podsecuritypolicy是什么-它如何帮助增强集群的安全性" aria-label="Permalink to &quot;26. Kubernetes中的PodSecurityPolicy是什么？它如何帮助增强集群的安全性&quot;">​</a></h1><p><strong>A26.</strong> PodSecurityPolicy（PSP）是一种集群级别的资源，用于控制Pod创建的安全上下文。通过PSP，管理员可以定义一系列的安全策略，如限制容器的运行用户、限制容器的文件系统访问权限等。这些策略可以帮助增强集群的安全性，防止潜在的安全风险。</p><h1 id="_27-kubernetes中的custom-resource-definition-crd-和-operator-是什么-它们如何一起工作" tabindex="-1">27. Kubernetes中的Custom Resource Definition (CRD) 和 Operator 是什么？它们如何一起工作？ <a class="header-anchor" href="#_27-kubernetes中的custom-resource-definition-crd-和-operator-是什么-它们如何一起工作" aria-label="Permalink to &quot;27. Kubernetes中的Custom Resource Definition (CRD) 和 Operator 是什么？它们如何一起工作？&quot;">​</a></h1><p><strong>A27.</strong> CRD允许用户定义自己的Kubernetes资源类型，而Operator则是一种控制循环，用于管理这些自定义资源的生命周期。Operator通过监听自定义资源的事件，并根据需要执行相应的操作，如创建、更新或删除相关的Kubernetes资源。这使得用户能够更灵活地扩展Kubernetes的功能，并管理自己的应用程序。</p><h1 id="_28-kubernetes中的service-account是什么-它与user-account有何不同" tabindex="-1">28. Kubernetes中的Service Account是什么？它与User Account有何不同？ <a class="header-anchor" href="#_28-kubernetes中的service-account是什么-它与user-account有何不同" aria-label="Permalink to &quot;28. Kubernetes中的Service Account是什么？它与User Account有何不同？&quot;">​</a></h1><p><strong>A28.</strong> 在Kubernetes中，Service Account是用于为Pod中的进程提供身份和权限的一种机制。每个Pod在创建时都会自动关联一个Service Account，该Service Account具有一组默认的权限和角色绑定。与User Account不同，Service Account主要用于Pod内部的进程与Kubernetes API服务器进行交互，而User Account则用于外部用户或客户端与Kubernetes API服务器进行交互。此外，Service Account的生命周期与Pod相关联，当Pod被删除时，其关联的Service Account也会被自动删除。</p><h1 id="_29-kubernetes中的poddisruptionbudget是什么-它如何帮助确保应用程序的高可用性" tabindex="-1">29. Kubernetes中的PodDisruptionBudget是什么？它如何帮助确保应用程序的高可用性？ <a class="header-anchor" href="#_29-kubernetes中的poddisruptionbudget是什么-它如何帮助确保应用程序的高可用性" aria-label="Permalink to &quot;29. Kubernetes中的PodDisruptionBudget是什么？它如何帮助确保应用程序的高可用性？&quot;">​</a></h1><p><strong>A29.</strong> PodDisruptionBudget（PDB）是Kubernetes中的一种资源对象，用于限制在自愿或非自愿中断（如节点维护、节点故障等）期间可以同时终止的Pod的数量。通过定义PDB，管理员可以指定在给定时间窗口内可以终止的Pod的最小数量或百分比。这有助于确保在发生中断时，应用程序仍然具有足够的容量来处理请求，从而保持高可用性。</p><h1 id="_30-kubernetes中的ingress是什么-它如何与service一起工作" tabindex="-1">30. Kubernetes中的Ingress是什么？它如何与Service一起工作？ <a class="header-anchor" href="#_30-kubernetes中的ingress是什么-它如何与service一起工作" aria-label="Permalink to &quot;30. Kubernetes中的Ingress是什么？它如何与Service一起工作？&quot;">​</a></h1><p><strong>A30.</strong> Ingress是Kubernetes的一个API对象，用于管理集群外部对集群内部服务的HTTP和HTTPS路由。Ingress提供了一种集中定义路由规则的方式，使得来自集群外部的请求能够被正确地转发到集群内部的服务上。Ingress需要配合Ingress Controller一起使用，Ingress Controller是一个负责监听Ingress对象并据其配置转发规则的组件。Service是Kubernetes中的另一个API对象，用于为Pod提供稳定的网络访问地址。Ingress通常会将请求转发到某个Service上，再由Service将请求分发到具体的Pod上。</p>',75),a=[s];function i(u,l,d,c,b,P){return r(),t("div",null,a)}const p=e(n,[["render",i]]);export{h as __pageData,p as default};
