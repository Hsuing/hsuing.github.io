import{_ as a,o as t,c as s,R as o}from"./chunks/framework.zUbWieqp.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/资源对象/5-StatefulSet-金丝雀部署.md","filePath":"guide/container/k8s/资源对象/5-StatefulSet-金丝雀部署.md","lastUpdated":1723447113000}'),p={name:"guide/container/k8s/资源对象/5-StatefulSet-金丝雀部署.md"},e=o('<h2 id="_1-金丝雀部署" tabindex="-1">1. 金丝雀部署 <a class="header-anchor" href="#_1-金丝雀部署" aria-label="Permalink to &quot;1. 金丝雀部署&quot;">​</a></h2><p>将处于暂存状态的更新操作的 partition 定位于 Pod 资源的最大索引号，即可放出一只金丝雀，由其测试第一轮的更新操作，在确认无误后通过修改 partition 属性的值更新其他的 Pod 对象是一种更为稳妥的更新操作。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202408091039379.png" alt="img"> StatefulSet 控制器 myapp 资源的分区号设置为 Pod 资源的最大索引号 2，将会触发 myapp-2 的更新操作：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">kubectl</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">path</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">statefulset</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">myapp</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-p</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;{&quot;spec&quot;:{&quot;updateStrategy&quot;:{&quot;rollingUpdate&quot;:{&quot;partition&quot;:2}}}}&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">kubectl</span><span style="color:#24292E;"> </span><span style="color:#032F62;">path</span><span style="color:#24292E;"> </span><span style="color:#032F62;">statefulset</span><span style="color:#24292E;"> </span><span style="color:#032F62;">myapp</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-p</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;{&quot;spec&quot;:{&quot;updateStrategy&quot;:{&quot;rollingUpdate&quot;:{&quot;partition&quot;:2}}}}&#39;</span></span></code></pre></div><p>位于非更新区域内的其他 Pod 资源仍然不会更新到新的镜像版本，哪怕它们被删除后重建亦是如此。</p><h2 id="_2-分段更新" tabindex="-1">2. 分段更新 <a class="header-anchor" href="#_2-分段更新" aria-label="Permalink to &quot;2. 分段更新&quot;">​</a></h2><p>金丝雀部署，第一批更新经过测试验证通过之后，用户便可启动后续其他 Pod 资源的更新操作。</p><p>在待更新的 Pod 资源数量极少的情况下，直接将 partition 属性的值设置为 0，它将逆序完成后续所有 Pod 资源的更新。而当待更新的 Pod 资源较多时，用户也可以将 Pod 资源以线性或指数级增长的方式来分阶段完成更新操作，操作过程无非是分步更新 partition 属性值。</p><p>例如，将 myapp 控制器的分区号依次设置为 1、0 以完成剩余 Pod 资源的线性分步更新。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202408091039356.png" alt="img"></p>',10),n=[e];function l(c,r,i,d,u,_){return t(),s("div",null,n)}const g=a(p,[["render",l]]);export{y as __pageData,g as default};
