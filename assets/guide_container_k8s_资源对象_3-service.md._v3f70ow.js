import{_ as e,o as s,c as a,R as t}from"./chunks/framework.zUbWieqp.js";const b=JSON.parse('{"title":"1.Service","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/资源对象/3-service.md","filePath":"guide/container/k8s/资源对象/3-service.md","lastUpdated":1714030813000}'),o={name:"guide/container/k8s/资源对象/3-service.md"},r=t(`<h1 id="_1-service" tabindex="-1">1.Service <a class="header-anchor" href="#_1-service" aria-label="Permalink to &quot;1.Service&quot;">​</a></h1><p>​ Service，是Kubernetes用来实现Pod负载均衡的一个服务；要想实现Pod的负载均衡，首先需要通过labels为Pod打上特定的标签，而后创建Service时使用Selector选择对应的标签，最终通过节点的kube-proxy来完成负载均衡的规则创建</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202401231358864.png" alt="image-20240123135851549"></p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">#iptables\\ipvs规则</span></span>
<span class="line"><span style="color:#B392F0;">iptables</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-t</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">nat</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-d</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">serviceIP</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-j</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">DNAT</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">podIP1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">#iptables\\ipvs规则</span></span>
<span class="line"><span style="color:#6F42C1;">iptables</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-t</span><span style="color:#24292E;"> </span><span style="color:#032F62;">nat</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-d</span><span style="color:#24292E;"> </span><span style="color:#032F62;">serviceIP</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-j</span><span style="color:#24292E;"> </span><span style="color:#032F62;">DNAT</span><span style="color:#24292E;"> </span><span style="color:#032F62;">podIP1</span></span></code></pre></div><h2 id="_1-1service概述" tabindex="-1">1.1Service概述 <a class="header-anchor" href="#_1-1service概述" aria-label="Permalink to &quot;1.1Service概述&quot;">​</a></h2><p>​ Service定义了一个服务的访问入口地址，前端应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，Service与其后端的Pod副本集群之间是通过Label Selector来实现“无缝对接”。RC保证Service的Pod副本实例数目保持预期水平.</p><h2 id="_1-2kubernetes的服务发现机制" tabindex="-1">1.2kubernetes的服务发现机制 <a class="header-anchor" href="#_1-2kubernetes的服务发现机制" aria-label="Permalink to &quot;1.2kubernetes的服务发现机制&quot;">​</a></h2><p>主要通过kube-dns这个组件来进行DNS方式的服务发现</p><h2 id="_1-3外部系统访问service的问题" tabindex="-1">1.3外部系统访问Service的问题 <a class="header-anchor" href="#_1-3外部系统访问service的问题" aria-label="Permalink to &quot;1.3外部系统访问Service的问题&quot;">​</a></h2><table><thead><tr><th>IP类型</th><th>说明</th></tr></thead><tbody><tr><td>Node IP</td><td>Node节点的IP地址</td></tr><tr><td>Pod IP</td><td>Pod的IP地址</td></tr><tr><td>Cluster IP</td><td>Service的IP地址</td></tr></tbody></table><h3 id="node-ip" tabindex="-1">Node IP <a class="header-anchor" href="#node-ip" aria-label="Permalink to &quot;Node IP&quot;">​</a></h3><p>NodeIP是集群中每个节点的物理网卡IP地址，是真实存在的物理网络，kubernetes集群之外的节点访问kubernetes内的某个节点或TCP/IP服务的时候，需要通过NodeIP进行通信。</p><h3 id="pod-ip" tabindex="-1">Pod IP <a class="header-anchor" href="#pod-ip" aria-label="Permalink to &quot;Pod IP&quot;">​</a></h3><p>Pod IP是每个Pod的IP地址，是Docker Engine根据docker0网桥的IP段地址进行分配的，是一个虚拟二层网络，集群中一个Pod的容器访问另一个Pod中的容器，是通过Pod IP进行通信的，而真实的TCP/IP流量是通过Node IP所在的网卡流出的</p><h3 id="cluster-ip" tabindex="-1">Cluster IP <a class="header-anchor" href="#cluster-ip" aria-label="Permalink to &quot;Cluster IP&quot;">​</a></h3><p>1.Service的Cluster IP是一个虚拟IP，只作用于Service这个对象，由kubernetes管理和分配IP地址（来源于Cluster IP地址池）。</p><p>2.Cluster IP无法被ping通，因为没有一个实体网络对象来响应。</p><p>3.Cluster IP结合Service Port组成的具体通信端口才具备TCP/IP通信基础，属于kubernetes集群内，集群外访问该IP和端口需要额外处理。</p><p>4.k8s集群内Node IP 、Pod IP、Cluster IP之间的通信采取k8s自己的特殊的路由规则，与传统IP路由不同</p><h2 id="_1-4外部访问kubernetes集群" tabindex="-1">1.4外部访问Kubernetes集群 <a class="header-anchor" href="#_1-4外部访问kubernetes集群" aria-label="Permalink to &quot;1.4外部访问Kubernetes集群&quot;">​</a></h2><p>通过宿主机与容器端口映射的方式进行访问，例如：Service定位文件如下：</p><p>可以通过任意Node的IP 加端口访问该服务。也可以通过Nginx或HAProxy来设置负载均衡。</p>`,22),n=[r];function l(p,c,i,d,P,h){return s(),a("div",null,n)}const I=e(o,[["render",l]]);export{b as __pageData,I as default};
