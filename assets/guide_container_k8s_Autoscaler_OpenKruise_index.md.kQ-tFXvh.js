import{_ as e,o as r,c as o,R as a}from"./chunks/framework.zUbWieqp.js";const K=JSON.parse('{"title":"1. OpenKruise","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/Autoscaler/OpenKruise/index.md","filePath":"guide/container/k8s/Autoscaler/OpenKruise/index.md","lastUpdated":1723447113000}'),n={name:"guide/container/k8s/Autoscaler/OpenKruise/index.md"},s=a('<p>官网：<a href="https://openkruise.io/zh/" target="_blank" rel="noreferrer">https://openkruise.io/zh/</a></p><h1 id="_1-openkruise" tabindex="-1">1. OpenKruise <a class="header-anchor" href="#_1-openkruise" aria-label="Permalink to &quot;1. OpenKruise&quot;">​</a></h1><h2 id="_1-1-openkruise诞生背景" tabindex="-1">1.1 OpenKruise诞生背景 <a class="header-anchor" href="#_1-1-openkruise诞生背景" aria-label="Permalink to &quot;1.1 OpenKruise诞生背景&quot;">​</a></h2><p>Kubernetes 自身提供的应用部署管理功能，无法满足大规模应用场景的需求，例如应用发布时的原地升级策略，流式扩容，缩容顺序控制等等。所以OpenKruise的出现弥补了 Kubernetes 在应用部署、升级、防护、运维等领域的不足。</p><p>K8s弹性策略有哪些？</p><p>在 Kubernetes 集群中，自动化资源管理和伸缩是保持应用高效运行的关键。Kubernetes 提供了几种不同的机制来帮助实现这一目标：水平自动伸缩（HPA, Horizontal Pod Autoscaler）、垂直自动伸缩（VPA,Vertical Pod Autoscaler）和集群自动伸缩（CA, ClusterAutoscaler）。这些伸缩器在功能和使用场景上有所不同:</p><ul><li>HPA：根据CPU 使用率或其他自定义指标自动增加或减少 Pod 的副本数，如在业务高峰自动增加Pod副本数，在业务低峰自动减少Pod副本数，通常用于无状态应用;</li><li>VPA：自动调整 Pod 的 CPU 和内存请求和限制，它的目标是为每个 Pod 分配最合适的资源量，既避免资源浪费，通常用于有状态应用或单实例应用;</li><li>CA：根据集群的当前负载和资源需求自动增加或减少节点的数量，适用于需要根据应用负载动态调整集群大小的场景，CA特别适用于云环境</li></ul><blockquote><p>上述所提到的HPA和VPA属于调度层弹性，CA属于资源层弹性，跨层级弹性策略可以结合使用，但不建议HPA和VPA共同使用，避免造成冲突。</p></blockquote><h2 id="_1-1-openkruise介绍" tabindex="-1">1.1 OpenKruise介绍 <a class="header-anchor" href="#_1-1-openkruise介绍" aria-label="Permalink to &quot;1.1 OpenKruise介绍&quot;">​</a></h2><p>OpenKruise是阿里云开源的云原生应用自动化引擎.</p><p>OpenKruise是个Kubernetes的扩展套件，主要聚焦于云原生应用的自动化，比如：部署，发布，运维以及可用性防护。</p><p>OpenKruise提供的绝大部能力都是基于CRD扩展来定义的，它们不存在于任何外部依赖，可以运行在任意纯净的</p><p>Kubernetes集群中，Kubernetes自身提供的一些应用部署管理功能，对于大规模应用与集群的场景这些功能是远远</p><p>不够的，而OpenKruise弥补了Kubernetes在应用部署，升级，防护，运维等领域的不足。</p><h2 id="_1-2-openkruise提供了什么" tabindex="-1">1.2 OpenKruise提供了什么 <a class="header-anchor" href="#_1-2-openkruise提供了什么" aria-label="Permalink to &quot;1.2 OpenKruise提供了什么&quot;">​</a></h2><p>1：增强版本的workloads：OpenKruise 包含了一系列增强版本的 Workloads（工作负载），比如 CloneSet、Advanced StatefulSet、Advanced DaemonSet、BroadcastJob 等。它们不仅支持类似于 Kubernetes 原生 Workloads 的基础功能，还提供了如原地升级、可配置的扩缩容/发布策略、并发操作等。原地升级是一种升级应用容器镜像甚至环境变量的全新方式。它只会用新的镜像重建 Pod 中的特定容器，整个 Pod 以及其中的其他容器都不会被影响。因此它带来了更快的发布速度，以及避免了对其他 Scheduler、CNI、CSI 等组件的负面影响。</p><p>2：应用旁路管理：OpenKruise 提供了多种通过旁路管理应用 sidecar 容器、多区域部署的方式，“旁路” 意味着你可以不需要修改应用的 Workloads 来实现它们。比如，SidecarSet 能帮助你在所有匹配的 Pod 创建的时候都注入特定的 sidecar 容器，甚至可以原地升级已经注入的 sidecar 容器镜像、并且对 Pod 中其他容器不造成影响。而 WorkloadSpread 可以约束无状态 Workload 扩容出来 Pod 的区域分布，赋予单一 workload 的多区域和弹性部署的能力。</p><p>3：高可用性防护：OpenKruise 在为应用的高可用性防护方面也做出了很多努力。目前它可以保护你的 Kubernetes 资源不受级联删除机制的干扰，包括 CRD、Namespace、以及几乎全部的 Workloads 类型资源。相比于 Kubernetes 原生的 PDB 只提供针对 Pod Eviction 的防护PodUnavailableBudget 能够防护 Pod Deletion、Eviction、Update 等许多种 voluntary disruption 场景。</p><p>4：高级的应用运维能力：OpenKruise也提供了很多高级的运维能力来帮助你更好的管理应用，比如可以通过ImagePullJob来在任意范围的节点上预先拉取某些镜像（镜像预热），或者指定某个Pod中的一个或多个容器被原地重启</p><h2 id="_1-3-openkruise架构" tabindex="-1">1.3 OpenKruise架构 <a class="header-anchor" href="#_1-3-openkruise架构" aria-label="Permalink to &quot;1.3 OpenKruise架构&quot;">​</a></h2><p><a href="https://openkruise.io/zh/docs/core-concepts/architecture" target="_blank" rel="noreferrer">官方</a></p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202408071639693.png" alt="alt"></p><p>OpenKruise 的功能都是通过 Kubernetes API 来提供的。</p><ul><li>Kruise-manager ：运行着 controller 和 webhook的中心组件，它通过 Deployment 部署在 kruise-system 命名空间中，同样它们之间采用 leader-election 的方式选主，同一时间只有一个提供服务，达到高可用的目的。除了 controller 之外，kruise-controller-manager-xxx 中还包含了针对 Kruise CRD 以及 Pod 资源的 admission webhook。Kruise-manager 会创建webhook configurations 来配置哪些资源需要感知处理、以及提供一个 Service 来给 kube-apiserver 调用。</li><li>kruise-daemon：这是从 Kruise v0.8.0 版本开始提供的一个新的 daemon 组件。它通过 DaemonSet 部署到每个 Node 节点上，提供镜像预热、容器重启等功能。</li></ul>',24),i=[s];function t(u,p,l,d,c,h){return r(),o("div",null,i)}const P=e(n,[["render",t]]);export{K as __pageData,P as default};
