import{_ as e,o as a,c as s,R as t}from"./chunks/framework.zUbWieqp.js";const b=JSON.parse('{"title":"HCL Native Syntax Specification","description":"","frontmatter":{},"headers":[],"relativePath":"guide/go/Terraform/4-syntax.md","filePath":"guide/go/Terraform/4-syntax.md","lastUpdated":1752158731000}'),n={name:"guide/go/Terraform/4-syntax.md"},o=t(`<h1 id="hcl-native-syntax-specification" tabindex="-1">HCL Native Syntax Specification <a class="header-anchor" href="#hcl-native-syntax-specification" aria-label="Permalink to &quot;HCL Native Syntax Specification&quot;">​</a></h1><p>This is the specification of the syntax and semantics of the native syntax for HCL. HCL is a system for defining configuration languages for applications. The HCL information model is designed to support multiple concrete syntaxes for configuration, but this native syntax is considered the primary format and is optimized for human authoring and maintenance, as opposed to machine generation of configuration.</p><p>The language consists of three integrated sub-languages:</p><ul><li>The <em>structural</em> language defines the overall hierarchical configuration structure, and is a serialization of HCL bodies, blocks and attributes.</li><li>The <em>expression</em> language is used to express attribute values, either as literals or as derivations of other values.</li><li>The <em>template</em> language is used to compose values together into strings, as one of several types of expression in the expression language.</li></ul><p>In normal use these three sub-languages are used together within configuration files to describe an overall configuration, with the structural language being used at the top level. The expression and template languages can also be used in isolation, to implement features such as REPLs, debuggers, and integration into more limited HCL syntaxes such as the JSON profile.</p><h2 id="syntax-notation" tabindex="-1">Syntax Notation <a class="header-anchor" href="#syntax-notation" aria-label="Permalink to &quot;Syntax Notation&quot;">​</a></h2><p>Within this specification a semi-formal notation is used to illustrate the details of syntax. This notation is intended for human consumption rather than machine consumption, with the following conventions:</p><ul><li>A naked name starting with an uppercase letter is a global production, common to all of the syntax specifications in this document.</li><li>A naked name starting with a lowercase letter is a local production, meaningful only within the specification where it is defined.</li><li>Double and single quotes (<code>&quot;</code> and <code>&#39;</code>) are used to mark literal character sequences, which may be either punctuation markers or keywords.</li><li>The default operator for combining items, which has no punctuation, is concatenation.</li><li>The symbol <code>|</code> indicates that any one of its left and right operands may be present.</li><li>The <code>*</code> symbol indicates zero or more repetitions of the item to its left.</li><li>The <code>?</code> symbol indicates zero or one of the item to its left.</li><li>Parentheses (<code>(</code> and <code>)</code>) are used to group items together to apply the <code>|</code>, <code>*</code> and <code>?</code> operators to them collectively.</li></ul><p>The grammar notation does not fully describe the language. The prose may augment or conflict with the illustrated grammar. In case of conflict, prose has priority.</p><h2 id="source-code-representation" tabindex="-1">Source Code Representation <a class="header-anchor" href="#source-code-representation" aria-label="Permalink to &quot;Source Code Representation&quot;">​</a></h2><p>Source code is unicode text expressed in the UTF-8 encoding. The language itself does not perform unicode normalization, so syntax features such as identifiers are sequences of unicode code points and so e.g. a precombined accented character is distinct from a letter associated with a combining accent. (String literals have some special handling with regard to Unicode normalization which will be covered later in the relevant section.)</p><p>UTF-8 encoded Unicode byte order marks are not permitted. Invalid or non-normalized UTF-8 encoding is always a parse error.</p><h2 id="lexical-elements" tabindex="-1">Lexical Elements <a class="header-anchor" href="#lexical-elements" aria-label="Permalink to &quot;Lexical Elements&quot;">​</a></h2><h3 id="comments-and-whitespace" tabindex="-1">Comments and Whitespace <a class="header-anchor" href="#comments-and-whitespace" aria-label="Permalink to &quot;Comments and Whitespace&quot;">​</a></h3><p>Comments and Whitespace are recognized as lexical elements but are ignored except as described below.</p><p>Whitespace is defined as a sequence of zero or more space characters (U+0020). Newline sequences (either U+000A or U+000D followed by U+000A) are <em>not</em> considered whitespace but are ignored as such in certain contexts. Horizontal tab characters (U+0009) are also treated as whitespace, but are counted only as one &quot;column&quot; for the purpose of reporting source positions.</p><p>Comments serve as program documentation and come in two forms:</p><ul><li><em>Line comments</em> start with either the <code>//</code> or <code>#</code> sequences and end with the next newline sequence. A line comment is considered equivalent to a newline sequence.</li><li><em>Inline comments</em> start with the <code>/*</code> sequence and end with the <code>*/</code> sequence, and may have any characters within except the ending sequence. An inline comment is considered equivalent to a whitespace sequence.</li></ul><p>Comments and whitespace cannot begin within other comments, or within template literals except inside an interpolation sequence or template directive.</p><h3 id="identifiers" tabindex="-1">Identifiers <a class="header-anchor" href="#identifiers" aria-label="Permalink to &quot;Identifiers&quot;">​</a></h3><p>Identifiers name entities such as blocks, attributes and expression variables. Identifiers are interpreted as per <a href="http://unicode.org/reports/tr31/" target="_blank" rel="noreferrer">UAX #31</a> Section 2. Specifically, their syntax is defined in terms of the <code>ID_Start</code> and <code>ID_Continue</code> character properties as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Identifier = ID_Start (ID_Continue | &#39;-&#39;)*;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Identifier = ID_Start (ID_Continue | &#39;-&#39;)*;</span></span></code></pre></div><p>The Unicode specification provides the normative requirements for identifier parsing. Non-normatively, the spirit of this specification is that <code>ID_Start</code> consists of Unicode letter and certain unambiguous punctuation tokens, while <code>ID_Continue</code> augments that set with Unicode digits, combining marks, etc.</p><p>The dash character <code>-</code> is additionally allowed in identifiers, even though that is not part of the unicode <code>ID_Continue</code> definition. This is to allow attribute names and block type names to contain dashes, although underscores as word separators are considered the idiomatic usage.</p><h3 id="keywords" tabindex="-1">Keywords <a class="header-anchor" href="#keywords" aria-label="Permalink to &quot;Keywords&quot;">​</a></h3><p>There are no globally-reserved words, but in some contexts certain identifiers are reserved to function as keywords. These are discussed further in the relevant documentation sections that follow. In such situations, the identifier&#39;s role as a keyword supersedes any other valid interpretation that may be possible. Outside of these specific situations, the keywords have no special meaning and are interpreted as regular identifiers.</p><h3 id="operators-and-delimiters" tabindex="-1">Operators and Delimiters <a class="header-anchor" href="#operators-and-delimiters" aria-label="Permalink to &quot;Operators and Delimiters&quot;">​</a></h3><p>The following character sequences represent operators, delimiters, and other special tokens:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">+    &amp;&amp;   ==   &lt;    :    {    [    (    \${</span></span>
<span class="line"><span style="color:#e1e4e8;">-    ||   !=   &gt;    ?    }    ]    )    %{</span></span>
<span class="line"><span style="color:#e1e4e8;">*    !         &lt;=        =         .</span></span>
<span class="line"><span style="color:#e1e4e8;">/              &gt;=        =&gt;        ,</span></span>
<span class="line"><span style="color:#e1e4e8;">%                                  ...</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">+    &amp;&amp;   ==   &lt;    :    {    [    (    \${</span></span>
<span class="line"><span style="color:#24292e;">-    ||   !=   &gt;    ?    }    ]    )    %{</span></span>
<span class="line"><span style="color:#24292e;">*    !         &lt;=        =         .</span></span>
<span class="line"><span style="color:#24292e;">/              &gt;=        =&gt;        ,</span></span>
<span class="line"><span style="color:#24292e;">%                                  ...</span></span></code></pre></div><h3 id="numeric-literals" tabindex="-1">Numeric Literals <a class="header-anchor" href="#numeric-literals" aria-label="Permalink to &quot;Numeric Literals&quot;">​</a></h3><p>A numeric literal is a decimal representation of a real number. It has an integer part, a fractional part, and an exponent part.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">NumericLit = decimal+ (&quot;.&quot; decimal+)? (expmark decimal+)?;</span></span>
<span class="line"><span style="color:#e1e4e8;">decimal    = &#39;0&#39; .. &#39;9&#39;;</span></span>
<span class="line"><span style="color:#e1e4e8;">expmark    = (&#39;e&#39; | &#39;E&#39;) (&quot;+&quot; | &quot;-&quot;)?;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">NumericLit = decimal+ (&quot;.&quot; decimal+)? (expmark decimal+)?;</span></span>
<span class="line"><span style="color:#24292e;">decimal    = &#39;0&#39; .. &#39;9&#39;;</span></span>
<span class="line"><span style="color:#24292e;">expmark    = (&#39;e&#39; | &#39;E&#39;) (&quot;+&quot; | &quot;-&quot;)?;</span></span></code></pre></div><h2 id="structural-elements" tabindex="-1">Structural Elements <a class="header-anchor" href="#structural-elements" aria-label="Permalink to &quot;Structural Elements&quot;">​</a></h2><p>The structural language consists of syntax representing the following constructs:</p><ul><li><em>Attributes</em>, which assign a value to a specified name.</li><li><em>Blocks</em>, which create a child body annotated by a type and optional labels.</li><li><em>Body Content</em>, which consists of a collection of attributes and blocks.</li></ul><p>These constructs correspond to the similarly-named concepts in the language-agnostic HCL information model.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ConfigFile   = Body;</span></span>
<span class="line"><span style="color:#e1e4e8;">Body         = (Attribute | Block | OneLineBlock)*;</span></span>
<span class="line"><span style="color:#e1e4e8;">Attribute    = Identifier &quot;=&quot; Expression Newline;</span></span>
<span class="line"><span style="color:#e1e4e8;">Block        = Identifier (StringLit|Identifier)* &quot;{&quot; Newline Body &quot;}&quot; Newline;</span></span>
<span class="line"><span style="color:#e1e4e8;">OneLineBlock = Identifier (StringLit|Identifier)* &quot;{&quot; (Identifier &quot;=&quot; Expression)? &quot;}&quot; Newline;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ConfigFile   = Body;</span></span>
<span class="line"><span style="color:#24292e;">Body         = (Attribute | Block | OneLineBlock)*;</span></span>
<span class="line"><span style="color:#24292e;">Attribute    = Identifier &quot;=&quot; Expression Newline;</span></span>
<span class="line"><span style="color:#24292e;">Block        = Identifier (StringLit|Identifier)* &quot;{&quot; Newline Body &quot;}&quot; Newline;</span></span>
<span class="line"><span style="color:#24292e;">OneLineBlock = Identifier (StringLit|Identifier)* &quot;{&quot; (Identifier &quot;=&quot; Expression)? &quot;}&quot; Newline;</span></span></code></pre></div><h3 id="configuration-files" tabindex="-1">Configuration Files <a class="header-anchor" href="#configuration-files" aria-label="Permalink to &quot;Configuration Files&quot;">​</a></h3><p>A <em>configuration file</em> is a sequence of characters whose top-level is interpreted as a Body.</p><h3 id="bodies" tabindex="-1">Bodies <a class="header-anchor" href="#bodies" aria-label="Permalink to &quot;Bodies&quot;">​</a></h3><p>A <em>body</em> is a collection of associated attributes and blocks. The meaning of this association is defined by the calling application.</p><h3 id="attribute-definitions" tabindex="-1">Attribute Definitions <a class="header-anchor" href="#attribute-definitions" aria-label="Permalink to &quot;Attribute Definitions&quot;">​</a></h3><p>An <em>attribute definition</em> assigns a value to a particular attribute name within a body. Each distinct attribute name may be defined no more than once within a single body.</p><p>The attribute value is given as an expression, which is retained literally for later evaluation by the calling application.</p><h3 id="blocks" tabindex="-1">Blocks <a class="header-anchor" href="#blocks" aria-label="Permalink to &quot;Blocks&quot;">​</a></h3><p>A <em>block</em> creates a child body that is annotated with a block <em>type</em> and zero or more block <em>labels</em>. Blocks create a structural hierarchy which can be interpreted by the calling application.</p><p>Block labels can either be quoted literal strings or naked identifiers.</p><h2 id="expressions" tabindex="-1">Expressions <a class="header-anchor" href="#expressions" aria-label="Permalink to &quot;Expressions&quot;">​</a></h2><p>The expression sub-language is used within attribute definitions to specify values.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Expression = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    ExprTerm |</span></span>
<span class="line"><span style="color:#e1e4e8;">    Operation |</span></span>
<span class="line"><span style="color:#e1e4e8;">    Conditional</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Expression = (</span></span>
<span class="line"><span style="color:#24292e;">    ExprTerm |</span></span>
<span class="line"><span style="color:#24292e;">    Operation |</span></span>
<span class="line"><span style="color:#24292e;">    Conditional</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><h3 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to &quot;Types&quot;">​</a></h3><p>The value types used within the expression language are those defined by the syntax-agnostic HCL information model. An expression may return any valid type, but only a subset of the available types have first-class syntax. A calling application may make other types available via <em>variables</em> and <em>functions</em>.</p><h3 id="expression-terms" tabindex="-1">Expression Terms <a class="header-anchor" href="#expression-terms" aria-label="Permalink to &quot;Expression Terms&quot;">​</a></h3><p>Expression <em>terms</em> are the operands for unary and binary expressions, as well as acting as expressions in their own right.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ExprTerm = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    LiteralValue |</span></span>
<span class="line"><span style="color:#e1e4e8;">    CollectionValue |</span></span>
<span class="line"><span style="color:#e1e4e8;">    TemplateExpr |</span></span>
<span class="line"><span style="color:#e1e4e8;">    VariableExpr |</span></span>
<span class="line"><span style="color:#e1e4e8;">    FunctionCall |</span></span>
<span class="line"><span style="color:#e1e4e8;">    ForExpr |</span></span>
<span class="line"><span style="color:#e1e4e8;">    ExprTerm Index |</span></span>
<span class="line"><span style="color:#e1e4e8;">    ExprTerm GetAttr |</span></span>
<span class="line"><span style="color:#e1e4e8;">    ExprTerm Splat |</span></span>
<span class="line"><span style="color:#e1e4e8;">    &quot;(&quot; Expression &quot;)&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ExprTerm = (</span></span>
<span class="line"><span style="color:#24292e;">    LiteralValue |</span></span>
<span class="line"><span style="color:#24292e;">    CollectionValue |</span></span>
<span class="line"><span style="color:#24292e;">    TemplateExpr |</span></span>
<span class="line"><span style="color:#24292e;">    VariableExpr |</span></span>
<span class="line"><span style="color:#24292e;">    FunctionCall |</span></span>
<span class="line"><span style="color:#24292e;">    ForExpr |</span></span>
<span class="line"><span style="color:#24292e;">    ExprTerm Index |</span></span>
<span class="line"><span style="color:#24292e;">    ExprTerm GetAttr |</span></span>
<span class="line"><span style="color:#24292e;">    ExprTerm Splat |</span></span>
<span class="line"><span style="color:#24292e;">    &quot;(&quot; Expression &quot;)&quot;</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><p>The productions for these different term types are given in their corresponding sections.</p><p>Between the <code>(</code> and <code>)</code> characters denoting a sub-expression, newline characters are ignored as whitespace.</p><h3 id="literal-values" tabindex="-1">Literal Values <a class="header-anchor" href="#literal-values" aria-label="Permalink to &quot;Literal Values&quot;">​</a></h3><p>A <em>literal value</em> immediately represents a particular value of a primitive type.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">LiteralValue = (</span></span>
<span class="line"><span style="color:#e1e4e8;">  NumericLit |</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;true&quot; |</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;false&quot; |</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;null&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">LiteralValue = (</span></span>
<span class="line"><span style="color:#24292e;">  NumericLit |</span></span>
<span class="line"><span style="color:#24292e;">  &quot;true&quot; |</span></span>
<span class="line"><span style="color:#24292e;">  &quot;false&quot; |</span></span>
<span class="line"><span style="color:#24292e;">  &quot;null&quot;</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><ul><li>Numeric literals represent values of type <em>number</em>.</li><li>The <code>true</code> and <code>false</code> keywords represent values of type <em>bool</em>.</li><li>The <code>null</code> keyword represents a null value of the dynamic pseudo-type.</li></ul><p>String literals are not directly available in the expression sub-language, but are available via the template sub-language, which can in turn be incorporated via <em>template expressions</em>.</p><h3 id="collection-values" tabindex="-1">Collection Values <a class="header-anchor" href="#collection-values" aria-label="Permalink to &quot;Collection Values&quot;">​</a></h3><p>A <em>collection value</em> combines zero or more other expressions to produce a collection value.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">CollectionValue = tuple | object;</span></span>
<span class="line"><span style="color:#e1e4e8;">tuple = &quot;[&quot; (</span></span>
<span class="line"><span style="color:#e1e4e8;">    (Expression ((&quot;,&quot; | Newline) Expression)* &quot;,&quot;?)?</span></span>
<span class="line"><span style="color:#e1e4e8;">) &quot;]&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">object = &quot;{&quot; (</span></span>
<span class="line"><span style="color:#e1e4e8;">    (objectelem (( &quot;,&quot; | Newline) objectelem)* &quot;,&quot;?)?</span></span>
<span class="line"><span style="color:#e1e4e8;">) &quot;}&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">objectelem = (Identifier | Expression) (&quot;=&quot; | &quot;:&quot;) Expression;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">CollectionValue = tuple | object;</span></span>
<span class="line"><span style="color:#24292e;">tuple = &quot;[&quot; (</span></span>
<span class="line"><span style="color:#24292e;">    (Expression ((&quot;,&quot; | Newline) Expression)* &quot;,&quot;?)?</span></span>
<span class="line"><span style="color:#24292e;">) &quot;]&quot;;</span></span>
<span class="line"><span style="color:#24292e;">object = &quot;{&quot; (</span></span>
<span class="line"><span style="color:#24292e;">    (objectelem (( &quot;,&quot; | Newline) objectelem)* &quot;,&quot;?)?</span></span>
<span class="line"><span style="color:#24292e;">) &quot;}&quot;;</span></span>
<span class="line"><span style="color:#24292e;">objectelem = (Identifier | Expression) (&quot;=&quot; | &quot;:&quot;) Expression;</span></span></code></pre></div><p>Only tuple and object values can be directly constructed via native syntax. Tuple and object values can in turn be converted to list, set and map values with other operations, which behaves as defined by the syntax-agnostic HCL information model.</p><p>When specifying an object element, an identifier is interpreted as a literal attribute name as opposed to a variable reference. To populate an item key from a variable, use parentheses to disambiguate:</p><ul><li><code>{foo = &quot;baz&quot;}</code> is interpreted as an attribute literally named <code>foo</code>.</li><li><code>{(foo) = &quot;baz&quot;}</code> is interpreted as an attribute whose name is taken from the variable named <code>foo</code>.</li></ul><p>Between the open and closing delimiters of these sequences, newline sequences are ignored as whitespace.</p><p>There is a syntax ambiguity between <em>for expressions</em> and collection values whose first element starts with an identifier named <code>for</code>. The <em>for expression</em> interpretation has priority, so to write a key literally named <code>for</code> or an expression derived from a variable named <code>for</code> you must use parentheses or quotes to disambiguate:</p><ul><li><code>[for, foo, baz]</code> is a syntax error.</li><li><code>[(for), foo, baz]</code> is a tuple whose first element is the value of variable <code>for</code>.</li><li><code>{for = 1, baz = 2}</code> is a syntax error.</li><li><code>{&quot;for&quot; = 1, baz = 2}</code> is an object with an attribute literally named <code>for</code>.</li><li><code>{baz = 2, for = 1}</code> is equivalent to the previous example, and resolves the ambiguity by reordering.</li><li><code>{(for) = 1, baz = 2}</code> is an object with a key with the same value as the variable <code>for</code>.</li></ul><h3 id="template-expressions" tabindex="-1">Template Expressions <a class="header-anchor" href="#template-expressions" aria-label="Permalink to &quot;Template Expressions&quot;">​</a></h3><p>A <em>template expression</em> embeds a program written in the template sub-language as an expression. Template expressions come in two forms:</p><ul><li>A <em>quoted</em> template expression is delimited by quote characters (<code>&quot;</code>) and defines a template as a single-line expression with escape characters.</li><li>A <em>heredoc</em> template expression is introduced by a <code>&lt;&lt;</code> sequence and defines a template via a multi-line sequence terminated by a user-chosen delimiter.</li></ul><p>In both cases the template interpolation and directive syntax is available for use within the delimiters, and any text outside of these special sequences is interpreted as a literal string.</p><p>In <em>quoted</em> template expressions any literal string sequences within the template behave in a special way: literal newline sequences are not permitted and instead <em>escape sequences</em> can be included, starting with the backslash <code>\\</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">    \\n         Unicode newline control character</span></span>
<span class="line"><span style="color:#e1e4e8;">    \\r         Unicode carriage return control character</span></span>
<span class="line"><span style="color:#e1e4e8;">    \\t         Unicode tab control character</span></span>
<span class="line"><span style="color:#e1e4e8;">    \\&quot;         Literal quote mark, used to prevent interpretation as end of string</span></span>
<span class="line"><span style="color:#e1e4e8;">    \\\\         Literal backslash, used to prevent interpretation as escape sequence</span></span>
<span class="line"><span style="color:#e1e4e8;">    \\uNNNN     Unicode character from Basic Multilingual Plane (NNNN is four hexadecimal digits)</span></span>
<span class="line"><span style="color:#e1e4e8;">    \\UNNNNNNNN Unicode character from supplementary planes (NNNNNNNN is eight hexadecimal digits)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">    \\n         Unicode newline control character</span></span>
<span class="line"><span style="color:#24292e;">    \\r         Unicode carriage return control character</span></span>
<span class="line"><span style="color:#24292e;">    \\t         Unicode tab control character</span></span>
<span class="line"><span style="color:#24292e;">    \\&quot;         Literal quote mark, used to prevent interpretation as end of string</span></span>
<span class="line"><span style="color:#24292e;">    \\\\         Literal backslash, used to prevent interpretation as escape sequence</span></span>
<span class="line"><span style="color:#24292e;">    \\uNNNN     Unicode character from Basic Multilingual Plane (NNNN is four hexadecimal digits)</span></span>
<span class="line"><span style="color:#24292e;">    \\UNNNNNNNN Unicode character from supplementary planes (NNNNNNNN is eight hexadecimal digits)</span></span></code></pre></div><p>The <em>heredoc</em> template expression type is introduced by either <code>&lt;&lt;</code> or <code>&lt;&lt;-</code>, followed by an identifier. The template expression ends when the given identifier subsequently appears again on a line of its own.</p><p>If a heredoc template is introduced with the <code>&lt;&lt;-</code> symbol, any literal string at the start of each line is analyzed to find the minimum number of leading spaces, and then that number of prefix spaces is removed from all line-leading literal strings. The final closing marker may also have an arbitrary number of spaces preceding it on its line.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">TemplateExpr = quotedTemplate | heredocTemplate;</span></span>
<span class="line"><span style="color:#e1e4e8;">quotedTemplate = (as defined in prose above);</span></span>
<span class="line"><span style="color:#e1e4e8;">heredocTemplate = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    (&quot;&lt;&lt;&quot; | &quot;&lt;&lt;-&quot;) Identifier Newline</span></span>
<span class="line"><span style="color:#e1e4e8;">    (content as defined in prose above)</span></span>
<span class="line"><span style="color:#e1e4e8;">    Identifier Newline</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">TemplateExpr = quotedTemplate | heredocTemplate;</span></span>
<span class="line"><span style="color:#24292e;">quotedTemplate = (as defined in prose above);</span></span>
<span class="line"><span style="color:#24292e;">heredocTemplate = (</span></span>
<span class="line"><span style="color:#24292e;">    (&quot;&lt;&lt;&quot; | &quot;&lt;&lt;-&quot;) Identifier Newline</span></span>
<span class="line"><span style="color:#24292e;">    (content as defined in prose above)</span></span>
<span class="line"><span style="color:#24292e;">    Identifier Newline</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><p>A quoted template expression containing only a single literal string serves as a syntax for defining literal string <em>expressions</em>. In certain contexts the template syntax is restricted in this manner:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">StringLit = &#39;&quot;&#39; (quoted literals as defined in prose above) &#39;&quot;&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">StringLit = &#39;&quot;&#39; (quoted literals as defined in prose above) &#39;&quot;&#39;;</span></span></code></pre></div><p>The <code>StringLit</code> production permits the escape sequences discussed for quoted template expressions as above, but does <em>not</em> permit template interpolation or directive sequences.</p><h3 id="variables-and-variable-expressions" tabindex="-1">Variables and Variable Expressions <a class="header-anchor" href="#variables-and-variable-expressions" aria-label="Permalink to &quot;Variables and Variable Expressions&quot;">​</a></h3><p>A <em>variable</em> is a value that has been assigned a symbolic name. Variables are made available for use in expressions by the calling application, by populating the <em>global scope</em> used for expression evaluation.</p><p>Variables can also be created by expressions themselves, which always creates a <em>child scope</em> that incorporates the variables from its parent scope but (re-)defines zero or more names with new values.</p><p>The value of a variable is accessed using a <em>variable expression</em>, which is a standalone <code>Identifier</code> whose name corresponds to a defined variable:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">VariableExpr = Identifier;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">VariableExpr = Identifier;</span></span></code></pre></div><p>Variables in a particular scope are immutable, but child scopes may <em>hide</em> a variable from an ancestor scope by defining a new variable of the same name. When looking up variables, the most locally-defined variable of the given name is used, and ancestor-scoped variables of the same name cannot be accessed.</p><p>No direct syntax is provided for declaring or assigning variables, but other expression constructs implicitly create child scopes and define variables as part of their evaluation.</p><h3 id="functions-and-function-calls" tabindex="-1">Functions and Function Calls <a class="header-anchor" href="#functions-and-function-calls" aria-label="Permalink to &quot;Functions and Function Calls&quot;">​</a></h3><p>A <em>function</em> is an operation that has been assigned a symbolic name. Functions are made available for use in expressions by the calling application, by populating the <em>function table</em> used for expression evaluation.</p><p>The namespace of functions is distinct from the namespace of variables. A function and a variable may share the same name with no implication that they are in any way related.</p><p>A function can be executed via a <em>function call</em> expression:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">FunctionCall = Identifier &quot;(&quot; arguments &quot;)&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">Arguments = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    () ||</span></span>
<span class="line"><span style="color:#e1e4e8;">    (Expression (&quot;,&quot; Expression)* (&quot;,&quot; | &quot;...&quot;)?)</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">FunctionCall = Identifier &quot;(&quot; arguments &quot;)&quot;;</span></span>
<span class="line"><span style="color:#24292e;">Arguments = (</span></span>
<span class="line"><span style="color:#24292e;">    () ||</span></span>
<span class="line"><span style="color:#24292e;">    (Expression (&quot;,&quot; Expression)* (&quot;,&quot; | &quot;...&quot;)?)</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><p>The definition of functions and the semantics of calling them are defined by the language-agnostic HCL information model. The given arguments are mapped onto the function&#39;s <em>parameters</em> and the result of a function call expression is the return value of the named function when given those arguments.</p><p>If the final argument expression is followed by the ellipsis symbol (<code>...</code>), the final argument expression must evaluate to either a list or tuple value. The elements of the value are each mapped to a single parameter of the named function, beginning at the first parameter remaining after all other argument expressions have been mapped.</p><p>Within the parentheses that delimit the function arguments, newline sequences are ignored as whitespace.</p><h3 id="for-expressions" tabindex="-1">For Expressions <a class="header-anchor" href="#for-expressions" aria-label="Permalink to &quot;For Expressions&quot;">​</a></h3><p>A <em>for expression</em> is a construct for constructing a collection by projecting the items from another collection.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ForExpr = forTupleExpr | forObjectExpr;</span></span>
<span class="line"><span style="color:#e1e4e8;">forTupleExpr = &quot;[&quot; forIntro Expression forCond? &quot;]&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">forObjectExpr = &quot;{&quot; forIntro Expression &quot;=&gt;&quot; Expression &quot;...&quot;? forCond? &quot;}&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">forIntro = &quot;for&quot; Identifier (&quot;,&quot; Identifier)? &quot;in&quot; Expression &quot;:&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">forCond = &quot;if&quot; Expression;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ForExpr = forTupleExpr | forObjectExpr;</span></span>
<span class="line"><span style="color:#24292e;">forTupleExpr = &quot;[&quot; forIntro Expression forCond? &quot;]&quot;;</span></span>
<span class="line"><span style="color:#24292e;">forObjectExpr = &quot;{&quot; forIntro Expression &quot;=&gt;&quot; Expression &quot;...&quot;? forCond? &quot;}&quot;;</span></span>
<span class="line"><span style="color:#24292e;">forIntro = &quot;for&quot; Identifier (&quot;,&quot; Identifier)? &quot;in&quot; Expression &quot;:&quot;;</span></span>
<span class="line"><span style="color:#24292e;">forCond = &quot;if&quot; Expression;</span></span></code></pre></div><p>The punctuation used to delimit a for expression decide whether it will produce a tuple value (<code>[</code> and <code>]</code>) or an object value (<code>{</code> and <code>}</code>).</p><p>The &quot;introduction&quot; is equivalent in both cases: the keyword <code>for</code> followed by either one or two identifiers separated by a comma which define the temporary variable names used for iteration, followed by the keyword <code>in</code> and then an expression that must evaluate to a value that can be iterated. The introduction is then terminated by the colon (<code>:</code>) symbol.</p><p>If only one identifier is provided, it is the name of a variable that will be temporarily assigned the value of each element during iteration. If both are provided, the first is the key and the second is the value.</p><p>Tuple, object, list, map, and set types are iterable. The type of collection used defines how the key and value variables are populated:</p><ul><li>For tuple and list types, the <em>key</em> is the zero-based index into the sequence for each element, and the <em>value</em> is the element value. The elements are visited in index order.</li><li>For object and map types, the <em>key</em> is the string attribute name or element key, and the <em>value</em> is the attribute or element value. The elements are visited in the order defined by a lexicographic sort of the attribute names or keys.</li><li>For set types, the <em>key</em> and <em>value</em> are both the element value. The elements are visited in an undefined but consistent order.</li></ul><p>The expression after the colon and (in the case of object <code>for</code>) the expression after the <code>=&gt;</code> are both evaluated once for each element of the source collection, in a local scope that defines the key and value variable names specified.</p><p>The results of evaluating these expressions for each input element are used to populate an element in the new collection. In the case of tuple <code>for</code>, the single expression becomes an element, appending values to the tuple in visit order. In the case of object <code>for</code>, the pair of expressions is used as an attribute name and value respectively, creating an element in the resulting object.</p><p>In the case of object <code>for</code>, it is an error if two input elements produce the same result from the attribute name expression, since duplicate attributes are not possible. If the ellipsis symbol (<code>...</code>) appears immediately after the value expression, this activates the grouping mode in which each value in the resulting object is a <em>tuple</em> of all of the values that were produced against each distinct key.</p><ul><li><code>[for v in [&quot;a&quot;, &quot;b&quot;]: v]</code> returns <code>[&quot;a&quot;, &quot;b&quot;]</code>.</li><li><code>[for i, v in [&quot;a&quot;, &quot;b&quot;]: i]</code> returns <code>[0, 1]</code>.</li><li><code>{for i, v in [&quot;a&quot;, &quot;b&quot;]: v =&gt; i}</code> returns <code>{a = 0, b = 1}</code>.</li><li><code>{for i, v in [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]: v =&gt; i}</code> produces an error, because attribute <code>a</code> is defined twice.</li><li><code>{for i, v in [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]: v =&gt; i...}</code> returns <code>{a = [0, 1], b = [2]}</code>.</li></ul><p>If the <code>if</code> keyword is used after the element expression(s), it applies an additional predicate that can be used to conditionally filter elements from the source collection from consideration. The expression following <code>if</code> is evaluated once for each source element, in the same scope used for the element expression(s). It must evaluate to a boolean value; if <code>true</code>, the element will be evaluated as normal, while if <code>false</code> the element will be skipped.</p><ul><li><code>[for i, v in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]: v if i &lt; 2]</code> returns <code>[&quot;a&quot;, &quot;b&quot;]</code>.</li></ul><p>If the collection value, element expression(s) or condition expression return unknown values that are otherwise type-valid, the result is a value of the dynamic pseudo-type.</p><h3 id="index-operator" tabindex="-1">Index Operator <a class="header-anchor" href="#index-operator" aria-label="Permalink to &quot;Index Operator&quot;">​</a></h3><p>The <em>index</em> operator returns the value of a single element of a collection value. It is a postfix operator and can be applied to any value that has a tuple, object, map, or list type.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Index = &quot;[&quot; Expression &quot;]&quot;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Index = &quot;[&quot; Expression &quot;]&quot;;</span></span></code></pre></div><p>The expression delimited by the brackets is the <em>key</em> by which an element will be looked up.</p><p>If the index operator is applied to a value of tuple or list type, the key expression must be an non-negative integer number representing the zero-based element index to access. If applied to a value of object or map type, the key expression must be a string representing the attribute name or element key. If the given key value is not of the appropriate type, a conversion is attempted using the conversion rules from the HCL syntax-agnostic information model.</p><p>An error is produced if the given key expression does not correspond to an element in the collection, either because it is of an unconvertable type, because it is outside the range of elements for a tuple or list, or because the given attribute or key does not exist.</p><p>If either the collection or the key are an unknown value of an otherwise-suitable type, the return value is an unknown value whose type matches what type would be returned given known values, or a value of the dynamic pseudo-type if type information alone cannot determine a suitable return type.</p><p>Within the brackets that delimit the index key, newline sequences are ignored as whitespace.</p><p>The HCL native syntax also includes a <em>legacy</em> index operator that exists only for compatibility with the precursor language HIL:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">LegacyIndex = &#39;.&#39; digit+</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">LegacyIndex = &#39;.&#39; digit+</span></span></code></pre></div><p>This legacy index operator must be supported by parser for compatibility but should not be used in new configurations. This allows an attribute-access-like syntax for indexing, must still be interpreted as an index operation rather than attribute access.</p><p>The legacy syntax does not support chaining of index operations, like <code>foo.0.0.bar</code>, because the interpretation of <code>0.0</code> as a number literal token takes priority and thus renders the resulting sequence invalid.</p><h3 id="attribute-access-operator" tabindex="-1">Attribute Access Operator <a class="header-anchor" href="#attribute-access-operator" aria-label="Permalink to &quot;Attribute Access Operator&quot;">​</a></h3><p>The <em>attribute access</em> operator returns the value of a single attribute in an object value. It is a postfix operator and can be applied to any value that has an object type.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">GetAttr = &quot;.&quot; Identifier;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">GetAttr = &quot;.&quot; Identifier;</span></span></code></pre></div><p>The given identifier is interpreted as the name of the attribute to access. An error is produced if the object to which the operator is applied does not have an attribute with the given name.</p><p>If the object is an unknown value of a type that has the attribute named, the result is an unknown value of the attribute&#39;s type.</p><h3 id="splat-operators" tabindex="-1">Splat Operators <a class="header-anchor" href="#splat-operators" aria-label="Permalink to &quot;Splat Operators&quot;">​</a></h3><p>The <em>splat operators</em> allow convenient access to attributes or elements of elements in a tuple, list, or set value.</p><p>There are two kinds of &quot;splat&quot; operator:</p><ul><li>The <em>attribute-only</em> splat operator supports only attribute lookups into the elements from a list, but supports an arbitrary number of them.</li><li>The <em>full</em> splat operator additionally supports indexing into the elements from a list, and allows any combination of attribute access and index operations.</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Splat = attrSplat | fullSplat;</span></span>
<span class="line"><span style="color:#e1e4e8;">attrSplat = &quot;.&quot; &quot;*&quot; GetAttr*;</span></span>
<span class="line"><span style="color:#e1e4e8;">fullSplat = &quot;[&quot; &quot;*&quot; &quot;]&quot; (GetAttr | Index)*;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Splat = attrSplat | fullSplat;</span></span>
<span class="line"><span style="color:#24292e;">attrSplat = &quot;.&quot; &quot;*&quot; GetAttr*;</span></span>
<span class="line"><span style="color:#24292e;">fullSplat = &quot;[&quot; &quot;*&quot; &quot;]&quot; (GetAttr | Index)*;</span></span></code></pre></div><p>The splat operators can be thought of as shorthands for common operations that could otherwise be performed using <em>for expressions</em>:</p><ul><li><code>tuple.*.foo.bar[0]</code> is approximately equivalent to <code>[for v in tuple: v.foo.bar][0]</code>.</li><li><code>tuple[*].foo.bar[0]</code> is approximately equivalent to <code>[for v in tuple: v.foo.bar[0]]</code></li></ul><p>Note the difference in how the trailing index operator is interpreted in each case. This different interpretation is the key difference between the <em>attribute-only</em> and <em>full</em> splat operators.</p><p>Splat operators have one additional behavior compared to the equivalent <em>for expressions</em> shown above: if a splat operator is applied to a value that is <em>not</em> of tuple, list, or set type, the value is coerced automatically into a single-value list of the value type:</p><ul><li><code>any_object.*.id</code> is equivalent to <code>[any_object.id]</code>, assuming that <code>any_object</code> is a single object.</li><li><code>any_number.*</code> is equivalent to <code>[any_number]</code>, assuming that <code>any_number</code> is a single number.</li></ul><p>If applied to a null value that is not tuple, list, or set, the result is always an empty tuple, which allows conveniently converting a possibly-null scalar value into a tuple of zero or one elements. It is illegal to apply a splat operator to a null value of tuple, list, or set type.</p><h3 id="operations" tabindex="-1">Operations <a class="header-anchor" href="#operations" aria-label="Permalink to &quot;Operations&quot;">​</a></h3><p>Operations apply a particular operator to either one or two expression terms.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Operation = unaryOp | binaryOp;</span></span>
<span class="line"><span style="color:#e1e4e8;">unaryOp = (&quot;-&quot; | &quot;!&quot;) ExprTerm;</span></span>
<span class="line"><span style="color:#e1e4e8;">binaryOp = ExprTerm binaryOperator ExprTerm;</span></span>
<span class="line"><span style="color:#e1e4e8;">binaryOperator = compareOperator | arithmeticOperator | logicOperator;</span></span>
<span class="line"><span style="color:#e1e4e8;">compareOperator = &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">arithmeticOperator = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;;</span></span>
<span class="line"><span style="color:#e1e4e8;">logicOperator = &quot;&amp;&amp;&quot; | &quot;||&quot;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Operation = unaryOp | binaryOp;</span></span>
<span class="line"><span style="color:#24292e;">unaryOp = (&quot;-&quot; | &quot;!&quot;) ExprTerm;</span></span>
<span class="line"><span style="color:#24292e;">binaryOp = ExprTerm binaryOperator ExprTerm;</span></span>
<span class="line"><span style="color:#24292e;">binaryOperator = compareOperator | arithmeticOperator | logicOperator;</span></span>
<span class="line"><span style="color:#24292e;">compareOperator = &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;;</span></span>
<span class="line"><span style="color:#24292e;">arithmeticOperator = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;;</span></span>
<span class="line"><span style="color:#24292e;">logicOperator = &quot;&amp;&amp;&quot; | &quot;||&quot;;</span></span></code></pre></div><p>The unary operators have the highest precedence.</p><p>The binary operators are grouped into the following precedence levels:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Level    Operators</span></span>
<span class="line"><span style="color:#e1e4e8;">  6      * / %</span></span>
<span class="line"><span style="color:#e1e4e8;">  5      + -</span></span>
<span class="line"><span style="color:#e1e4e8;">  4      &gt; &gt;= &lt; &lt;=</span></span>
<span class="line"><span style="color:#e1e4e8;">  3      == !=</span></span>
<span class="line"><span style="color:#e1e4e8;">  2      &amp;&amp;</span></span>
<span class="line"><span style="color:#e1e4e8;">  1      ||</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Level    Operators</span></span>
<span class="line"><span style="color:#24292e;">  6      * / %</span></span>
<span class="line"><span style="color:#24292e;">  5      + -</span></span>
<span class="line"><span style="color:#24292e;">  4      &gt; &gt;= &lt; &lt;=</span></span>
<span class="line"><span style="color:#24292e;">  3      == !=</span></span>
<span class="line"><span style="color:#24292e;">  2      &amp;&amp;</span></span>
<span class="line"><span style="color:#24292e;">  1      ||</span></span></code></pre></div><p>Higher values of &quot;level&quot; bind tighter. Operators within the same precedence level have left-to-right associativity. For example, <code>x / y * z</code> is equivalent to <code>(x / y) * z</code>.</p><h3 id="comparison-operators" tabindex="-1">Comparison Operators <a class="header-anchor" href="#comparison-operators" aria-label="Permalink to &quot;Comparison Operators&quot;">​</a></h3><p>Comparison operators always produce boolean values, as a result of testing the relationship between two values.</p><p>The two equality operators apply to values of any type:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">a == b  equal</span></span>
<span class="line"><span style="color:#e1e4e8;">a != b  not equal</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">a == b  equal</span></span>
<span class="line"><span style="color:#24292e;">a != b  not equal</span></span></code></pre></div><p>Two values are equal if they are of identical types and their values are equal as defined in the HCL syntax-agnostic information model. The equality operators are commutative and opposite, such that <code>(a == b) == !(a != b)</code> and <code>(a == b) == (b == a)</code> for all values <code>a</code> and <code>b</code>.</p><p>The four numeric comparison operators apply only to numbers:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">a &lt; b   less than</span></span>
<span class="line"><span style="color:#e1e4e8;">a &lt;= b  less than or equal to</span></span>
<span class="line"><span style="color:#e1e4e8;">a &gt; b   greater than</span></span>
<span class="line"><span style="color:#e1e4e8;">a &gt;= b  greater than or equal to</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">a &lt; b   less than</span></span>
<span class="line"><span style="color:#24292e;">a &lt;= b  less than or equal to</span></span>
<span class="line"><span style="color:#24292e;">a &gt; b   greater than</span></span>
<span class="line"><span style="color:#24292e;">a &gt;= b  greater than or equal to</span></span></code></pre></div><p>If either operand of a comparison operator is a correctly-typed unknown value or a value of the dynamic pseudo-type, the result is an unknown boolean.</p><h3 id="arithmetic-operators" tabindex="-1">Arithmetic Operators <a class="header-anchor" href="#arithmetic-operators" aria-label="Permalink to &quot;Arithmetic Operators&quot;">​</a></h3><p>Arithmetic operators apply only to number values and always produce number values as results.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">a + b   sum        (addition)</span></span>
<span class="line"><span style="color:#e1e4e8;">a - b   difference (subtraction)</span></span>
<span class="line"><span style="color:#e1e4e8;">a * b   product    (multiplication)</span></span>
<span class="line"><span style="color:#e1e4e8;">a / b   quotient   (division)</span></span>
<span class="line"><span style="color:#e1e4e8;">a % b   remainder  (modulo)</span></span>
<span class="line"><span style="color:#e1e4e8;">-a      negation</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#24292e;">a + b   sum        (addition)</span></span>
<span class="line"><span style="color:#24292e;">a - b   difference (subtraction)</span></span>
<span class="line"><span style="color:#24292e;">a * b   product    (multiplication)</span></span>
<span class="line"><span style="color:#24292e;">a / b   quotient   (division)</span></span>
<span class="line"><span style="color:#24292e;">a % b   remainder  (modulo)</span></span>
<span class="line"><span style="color:#24292e;">-a      negation</span></span></code></pre></div><p>Arithmetic operations are considered to be performed in an arbitrary-precision number space.</p><p>If either operand of an arithmetic operator is an unknown number or a value of the dynamic pseudo-type, the result is an unknown number.</p><h3 id="logic-operators" tabindex="-1">Logic Operators <a class="header-anchor" href="#logic-operators" aria-label="Permalink to &quot;Logic Operators&quot;">​</a></h3><p>Logic operators apply only to boolean values and always produce boolean values as results.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">a &amp;&amp; b   logical AND</span></span>
<span class="line"><span style="color:#e1e4e8;">a || b   logical OR</span></span>
<span class="line"><span style="color:#e1e4e8;">!a       logical NOT</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">a &amp;&amp; b   logical AND</span></span>
<span class="line"><span style="color:#24292e;">a || b   logical OR</span></span>
<span class="line"><span style="color:#24292e;">!a       logical NOT</span></span></code></pre></div><p>If either operand of a logic operator is an unknown bool value or a value of the dynamic pseudo-type, the result is an unknown bool value.</p><h3 id="conditional-operator" tabindex="-1">Conditional Operator <a class="header-anchor" href="#conditional-operator" aria-label="Permalink to &quot;Conditional Operator&quot;">​</a></h3><p>The conditional operator allows selecting from one of two expressions based on the outcome of a boolean expression.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Conditional = Expression &quot;?&quot; Expression &quot;:&quot; Expression;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Conditional = Expression &quot;?&quot; Expression &quot;:&quot; Expression;</span></span></code></pre></div><p>The first expression is the <em>predicate</em>, which is evaluated and must produce a boolean result. If the predicate value is <code>true</code>, the result of the second expression is the result of the conditional. If the predicate value is <code>false</code>, the result of the third expression is the result of the conditional.</p><p>The second and third expressions must be of the same type or must be able to unify into a common type using the type unification rules defined in the HCL syntax-agnostic information model. This unified type is the result type of the conditional, with both expressions converted as necessary to the unified type.</p><p>If the predicate is an unknown boolean value or a value of the dynamic pseudo-type then the result is an unknown value of the unified type of the other two expressions.</p><p>If either the second or third expressions produce errors when evaluated, these errors are passed through only if the erroneous expression is selected. This allows for expressions such as <code>length(some_list) &gt; 0 ? some_list[0] : default</code> (given some suitable <code>length</code> function) without producing an error when the predicate is <code>false</code>.</p><h2 id="templates" tabindex="-1">Templates <a class="header-anchor" href="#templates" aria-label="Permalink to &quot;Templates&quot;">​</a></h2><p>The template sub-language is used within template expressions to concisely combine strings and other values to produce other strings. It can also be used in isolation as a standalone template language.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Template = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    TemplateLiteral |</span></span>
<span class="line"><span style="color:#e1e4e8;">    TemplateInterpolation |</span></span>
<span class="line"><span style="color:#e1e4e8;">    TemplateDirective</span></span>
<span class="line"><span style="color:#e1e4e8;">)*</span></span>
<span class="line"><span style="color:#e1e4e8;">TemplateDirective = TemplateIf | TemplateFor;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Template = (</span></span>
<span class="line"><span style="color:#24292e;">    TemplateLiteral |</span></span>
<span class="line"><span style="color:#24292e;">    TemplateInterpolation |</span></span>
<span class="line"><span style="color:#24292e;">    TemplateDirective</span></span>
<span class="line"><span style="color:#24292e;">)*</span></span>
<span class="line"><span style="color:#24292e;">TemplateDirective = TemplateIf | TemplateFor;</span></span></code></pre></div><p>A template behaves like an expression that always returns a string value. The different elements of the template are evaluated and combined into a single string to return. If any of the elements produce an unknown string or a value of the dynamic pseudo-type, the result is an unknown string.</p><p>An important use-case for standalone templates is to enable the use of expressions in alternative HCL syntaxes where a native expression grammar is not available. For example, the HCL JSON profile treats the values of JSON strings as standalone templates when attributes are evaluated in expression mode.</p><h3 id="template-literals" tabindex="-1">Template Literals <a class="header-anchor" href="#template-literals" aria-label="Permalink to &quot;Template Literals&quot;">​</a></h3><p>A template literal is a literal sequence of characters to include in the resulting string. When the template sub-language is used standalone, a template literal can contain any unicode character, with the exception of the sequences that introduce interpolations and directives, and for the sequences that escape those introductions.</p><p>The interpolation and directive introductions are escaped by doubling their leading characters. The <code>\${</code> sequence is escaped as <code>$\${</code> and the <code>%{</code> sequence is escaped as <code>%%{</code>.</p><p>When the template sub-language is embedded in the expression language via <em>template expressions</em>, additional constraints and transforms are applied to template literals as described in the definition of template expressions.</p><p>The value of a template literal can be modified by <em>strip markers</em> in any interpolations or directives that are adjacent to it. A strip marker is a tilde (<code>~</code>) placed immediately after the opening <code>{</code> or before the closing <code>}</code> of a template sequence:</p><ul><li><code>hello \${~ &quot;world&quot; }</code> produces <code>&quot;helloworld&quot;</code>.</li><li><code>%{ if true ~} hello %{~ endif }</code> produces <code>&quot;hello&quot;</code>.</li></ul><p>When a strip marker is present, any spaces adjacent to it in the corresponding string literal (if any) are removed before producing the final value. Space characters are interpreted as per Unicode&#39;s definition.</p><p>Stripping is done at syntax level rather than value level. Values returned by interpolations or directives are not subject to stripping:</p><ul><li><code>\${&quot;hello&quot; ~}\${&quot; world&quot;}</code> produces <code>&quot;hello world&quot;</code>, and not <code>&quot;helloworld&quot;</code>, because the space is not in a template literal directly adjacent to the strip marker.</li></ul><h3 id="template-interpolations" tabindex="-1">Template Interpolations <a class="header-anchor" href="#template-interpolations" aria-label="Permalink to &quot;Template Interpolations&quot;">​</a></h3><p>An <em>interpolation sequence</em> evaluates an expression (written in the expression sub-language), converts the result to a string value, and replaces itself with the resulting string.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">TemplateInterpolation = (&quot;\${&quot; | &quot;\${~&quot;) Expression (&quot;}&quot; | &quot;~}&quot;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">TemplateInterpolation = (&quot;\${&quot; | &quot;\${~&quot;) Expression (&quot;}&quot; | &quot;~}&quot;;</span></span></code></pre></div><p>If the expression result cannot be converted to a string, an error is produced.</p><h3 id="template-if-directive" tabindex="-1">Template If Directive <a class="header-anchor" href="#template-if-directive" aria-label="Permalink to &quot;Template If Directive&quot;">​</a></h3><p>The template <code>if</code> directive is the template equivalent of the <em>conditional expression</em>, allowing selection of one of two sub-templates based on the value of a predicate expression.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">TemplateIf = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;if&quot; Expression (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    Template</span></span>
<span class="line"><span style="color:#e1e4e8;">    (</span></span>
<span class="line"><span style="color:#e1e4e8;">        (&quot;%{&quot; | &quot;%{~&quot;) &quot;else&quot; (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">        Template</span></span>
<span class="line"><span style="color:#e1e4e8;">    )?</span></span>
<span class="line"><span style="color:#e1e4e8;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;endif&quot; (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">TemplateIf = (</span></span>
<span class="line"><span style="color:#24292e;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;if&quot; Expression (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#24292e;">    Template</span></span>
<span class="line"><span style="color:#24292e;">    (</span></span>
<span class="line"><span style="color:#24292e;">        (&quot;%{&quot; | &quot;%{~&quot;) &quot;else&quot; (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#24292e;">        Template</span></span>
<span class="line"><span style="color:#24292e;">    )?</span></span>
<span class="line"><span style="color:#24292e;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;endif&quot; (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><p>The evaluation of the <code>if</code> directive is equivalent to the conditional expression, with the following exceptions:</p><ul><li>The two sub-templates always produce strings, and thus the result value is also always a string.</li><li>The <code>else</code> clause may be omitted, in which case the conditional&#39;s third expression result is implied to be the empty string.</li></ul><h3 id="template-for-directive" tabindex="-1">Template For Directive <a class="header-anchor" href="#template-for-directive" aria-label="Permalink to &quot;Template For Directive&quot;">​</a></h3><p>The template <code>for</code> directive is the template equivalent of the <em>for expression</em>, producing zero or more copies of its sub-template based on the elements of a collection.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">TemplateFor = (</span></span>
<span class="line"><span style="color:#e1e4e8;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;for&quot; Identifier (&quot;,&quot; Identifier) &quot;in&quot; Expression (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    Template</span></span>
<span class="line"><span style="color:#e1e4e8;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;endfor&quot; (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">TemplateFor = (</span></span>
<span class="line"><span style="color:#24292e;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;for&quot; Identifier (&quot;,&quot; Identifier) &quot;in&quot; Expression (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#24292e;">    Template</span></span>
<span class="line"><span style="color:#24292e;">    (&quot;%{&quot; | &quot;%{~&quot;) &quot;endfor&quot; (&quot;}&quot; | &quot;~}&quot;)</span></span>
<span class="line"><span style="color:#24292e;">);</span></span></code></pre></div><p>The evaluation of the <code>for</code> directive is equivalent to the <em>for expression</em> when producing a tuple, with the following exceptions:</p><ul><li>The sub-template always produces a string.</li><li>There is no equivalent of the &quot;if&quot; clause on the for expression.</li><li>The elements of the resulting tuple are all converted to strings and concatenated to produce a flat string result.</li></ul><h3 id="template-interpolation-unwrapping" tabindex="-1">Template Interpolation Unwrapping <a class="header-anchor" href="#template-interpolation-unwrapping" aria-label="Permalink to &quot;Template Interpolation Unwrapping&quot;">​</a></h3><p>As a special case, a template that consists only of a single interpolation, with no surrounding literals, directives or other interpolations, is &quot;unwrapped&quot;. In this case, the result of the interpolation expression is returned verbatim, without conversion to string.</p><p>This special case exists primarily to enable the native template language to be used inside strings in alternative HCL syntaxes that lack a first-class template or expression syntax. Unwrapping allows arbitrary expressions to be used to populate attributes when strings in such languages are interpreted as templates.</p><ul><li><code>\${true}</code> produces the boolean value <code>true</code></li><li><code>\${&quot;\${true}&quot;}</code> produces the boolean value <code>true</code>, because both the inner and outer interpolations are subject to unwrapping.</li><li><code>hello \${true}</code> produces the string <code>&quot;hello true&quot;</code></li><li><code>\${&quot;&quot;}\${true}</code> produces the string <code>&quot;true&quot;</code> because there are two interpolation sequences, even though one produces an empty result.</li><li><code>%{ for v in [true] }\${v}%{ endfor }</code> produces the string <code>true</code> because the presence of the <code>for</code> directive circumvents the unwrapping even though the final result is a single value.</li></ul><p>In some contexts this unwrapping behavior may be circumvented by the calling application, by converting the final template result to string. This is necessary, for example, if a standalone template is being used to produce the direct contents of a file, since the result in that case must always be a string.</p><h2 id="static-analysis" tabindex="-1">Static Analysis <a class="header-anchor" href="#static-analysis" aria-label="Permalink to &quot;Static Analysis&quot;">​</a></h2><p>The HCL static analysis operations are implemented for some expression types in the native syntax, as described in the following sections.</p><p>A goal for static analysis of the native syntax is for the interpretation to be as consistent as possible with the dynamic evaluation interpretation of the given expression, though some deviations are intentionally made in order to maximize the potential for analysis.</p><h3 id="static-list" tabindex="-1">Static List <a class="header-anchor" href="#static-list" aria-label="Permalink to &quot;Static List&quot;">​</a></h3><p>The tuple construction syntax can be interpreted as a static list. All of the expression elements given are returned as the static list elements, with no further interpretation.</p><h3 id="static-map" tabindex="-1">Static Map <a class="header-anchor" href="#static-map" aria-label="Permalink to &quot;Static Map&quot;">​</a></h3><p>The object construction syntax can be interpreted as a static map. All of the key/value pairs given are returned as the static pairs, with no further interpretation.</p><p>The usual requirement that an attribute name be interpretable as a string does not apply to this static analysis, allowing callers to provide map-like constructs with different key types by building on the map syntax.</p><h3 id="static-call" tabindex="-1">Static Call <a class="header-anchor" href="#static-call" aria-label="Permalink to &quot;Static Call&quot;">​</a></h3><p>The function call syntax can be interpreted as a static call. The called function name is returned verbatim and the given argument expressions are returned as the static arguments, with no further interpretation.</p><h3 id="static-traversal" tabindex="-1">Static Traversal <a class="header-anchor" href="#static-traversal" aria-label="Permalink to &quot;Static Traversal&quot;">​</a></h3><p>A variable expression and any attached attribute access operations and constant index operations can be interpreted as a static traversal.</p><p>The keywords <code>true</code>, <code>false</code> and <code>null</code> can also be interpreted as static traversals, behaving as if they were references to variables of those names, to allow callers to redefine the meaning of those keywords in certain contexts.</p><p>参考：</p><p><a href="https://github.com/hashicorp/hcl/blob/main/hclsyntax/spec.md" target="_blank" rel="noreferrer">https://github.com/hashicorp/hcl/blob/main/hclsyntax/spec.md</a></p><p><a href="https://developer.hashicorp.com/terraform/language/syntax/configuration" target="_blank" rel="noreferrer">https://developer.hashicorp.com/terraform/language/syntax/configuration</a></p>`,221),i=[o];function l(r,p,c,d,u,h){return a(),s("div",null,i)}const y=e(n,[["render",l]]);export{b as __pageData,y as default};
