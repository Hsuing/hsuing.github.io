import{_ as e,o as n,c as t,R as o}from"./chunks/framework.zUbWieqp.js";const k=JSON.parse('{"title":"1. Containerd 架构","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/containerd/index.md","filePath":"guide/container/containerd/index.md","lastUpdated":1731157838000}'),r={name:"guide/container/containerd/index.md"},a=o(`<h1 id="_1-containerd-架构" tabindex="-1">1. Containerd 架构 <a class="header-anchor" href="#_1-containerd-架构" aria-label="Permalink to &quot;1. Containerd 架构&quot;">​</a></h1><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202310251750073.png" alt=""></p><p>可以看到 Containerd 仍然采用标准的 C/S 架构，服务端通过 <code>GRPC</code> 协议提供稳定的 API，客户端通过调用服务端的 API 进行高级的操作。</p><p>为了解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个<strong>子系统</strong>（subsystem）。连接不同子系统的组件被称为模块。</p><p>总体上 Containerd 被划分为两个子系统：</p><ul><li><strong>Bundle</strong> : 在 Containerd 中，<code>Bundle</code> 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 <strong>Bundle 子系统</strong>允许用户从镜像中提取和打包 Bundles。</li><li><strong>Runtime</strong> : Runtime 子系统用来执行 Bundles，比如创建容器。</li></ul><p>其中，每一个子系统的行为都由一个或多个<strong>模块</strong>协作完成（架构图中的 <code>Core</code> 部分）。每一种类型的模块都以<strong>插件</strong>的形式集成到 Containerd 中，而且插件之间是相互依赖的。例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 <code>Service Plugin</code>、<code>Metadata Plugin</code>、<code>GC Plugin</code>、<code>Runtime Plugin</code> 等，其中 <code>Service Plugin</code> 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 <code>Metadata Plugin</code> 依赖 Containers Plugin、Content Plugin 等。 总之，万物皆插件，插件就是模块，模块就是插件</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202310251751665.png" alt=""></p><p>这里介绍几个常用的插件：</p><ul><li><strong>Content Plugin</strong> : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。</li><li><strong>Snapshot Plugin</strong> : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 <code>graphdriver</code>。</li><li><strong>Metrics</strong> : 暴露各个组件的监控指标。</li></ul><p>从总体来看，Containerd 被分为三个大块：<code>Storage</code>、<code>Metadata</code> 和 <code>Runtime</code>，可以将上面的架构图提炼一下</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202310251752717.png" alt=""></p><p>参考：</p><ul><li><a href="https://github.com/containerd/containerd/tree/main" target="_blank" rel="noreferrer">containerd</a></li></ul><h1 id="_2-docker、cntainerd、kubernetes之间的关系" tabindex="-1">2. Docker、Cntainerd、Kubernetes之间的关系 <a class="header-anchor" href="#_2-docker、cntainerd、kubernetes之间的关系" aria-label="Permalink to &quot;2. Docker、Cntainerd、Kubernetes之间的关系&quot;">​</a></h1><h2 id="_2-1docker、oci和containerd" tabindex="-1">2.1Docker、OCI和Containerd <a class="header-anchor" href="#_2-1docker、oci和containerd" aria-label="Permalink to &quot;2.1Docker、OCI和Containerd&quot;">​</a></h2><p>大概就是在docker如日中天的时候，社区要搞容器化标准，成立了OCI(Open Container Initiaiv)，OCI主要包含两个规范，一个是容器运行时规范(runtime-spec)，一个是容器镜像规范(image-spec)。 docker的公司也在OCI中，这里略过在推动标准化过程中各大厂各自心里的&quot;小算盘&quot;和&quot;利益考虑&quot;，docker在这个过程中由一个庞然大物逐渐拆分出了<code>containerd</code>、<code>runc</code>等项目， docker公司将runc捐赠给了OCI，后来将containerd捐赠给了CNCF。</p><ul><li>runc是什么? runc是一个轻量级的命令行工具，可以用它来运行容器。runc遵循OCI标准来创建和运行容器，它算是第一个OCI Runtime标准的参考实现。</li><li>containerd是什么？containerd的自我介绍中说它是一个开放、可靠的容器运行时，实际上它包含了单机运行一个容器运行时的功能。 containerd为了支持多种OCI Runtime实现，内部使用<code>containerd-shim</code>，shim英文翻译过来是&quot;垫片&quot;的意思，见名知义了，例如为了支持runc，就提供了<code>containerd-shim-runc</code>。</li></ul><p>经过上面的发展，docker启动一个容器的过程大致是下图所示的流程:</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411091941023.png" alt="docker-run-container.png"></p><p>从上图可以看出，每启动一个容器，实际上是containerd启动了一个<code>containerd-shim-runc</code>进程，即使containerd的挂掉也不会影响到已经启动的容器。</p><h1 id="_3-kubernetes、docker和containerd" tabindex="-1">3. Kubernetes、Docker和Containerd <a class="header-anchor" href="#_3-kubernetes、docker和containerd" aria-label="Permalink to &quot;3. Kubernetes、Docker和Containerd&quot;">​</a></h1><p>kubernetes的出现是为了解决容器编排的问题，在早期为了支持多个容器引擎，是在Kubernetes内部对多个容器引擎做兼容，例如kubelet启动一个<code>docker-manager</code>的进程直接调用docker的api进行容器的创建。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411091942200.png" alt="kubelet-run-containerd-0.png"></p><p>后来k8s为了隔离各个容器引擎之间的差异，在docker分出containerd后，k8s也搞出了自己的容器运行时接口(CRI)，CRI的出现是为了统一k8s与不同容器引擎之间交互的接口，与OCI的容器运行时规范不同，CRI更加适合k8s，不仅包含对容器的管理，还引入了k8s中Pod的概念及对Pod生命周期的管理。 k8s开始把containerd接入CRI标准。kubelet通过CRI接口调用<code>docker-shim</code>，进一步调用docker api。此时在每个k8s节点上kubelet大致按下图流程启动容器:</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411091943005.png" alt="kubelet-run-containerd-1.png"></p><p>为了更好的将containerd接入到CRI标准中，k8s又搞出了<code>cri-containerd</code>项目，<code>cri-containerd</code>是一个守护进程用来实现kubelet和containerd之间的交互，此时k8s节点上kubelet大致按下图流程启动容器:</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411091943091.png" alt="kubelet-run-containerd-2.png"></p><p>在上图中cri-containerd和containerd还是两个独立的进程，他们之间通过gRPC通信，后来在Containerd 1.1时，将cri-containerd改成了Containerd的CRI插件，CRI插件位于containerd内部，这让k8s启动Pod时的通信更加高效，此时k8s节点上kubelet大致按下图流程启动容器:</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411091943079.png" alt="kubelet-run-containerd-3.png"></p><p>为了更贴近OCI，k8s又搞了一个轻量级的容器运行时<code>cri-o</code>，所以在k8s&quot;抛弃&quot;dockershim后，可供我们选择的容器运行时有containerd和cri-o</p><p>早期: kubelet --&gt; docker-manager --&gt; docker</p><p>中期: kubelet -CRI-&gt; docker-shim --&gt; docker --&gt; containerd --&gt; runc</p><p>中期: kubelet -CRI-&gt; cri-containerd --&gt; containerd --&gt; runc</p><p>当前: kubelet -CRI-&gt; containerd(CRI plugin) --&gt; runc</p><p>当前: kubelet -CRI-&gt; cri-o --&gt; runc</p><p>文档：</p><ul><li><a href="https://github.com/opencontainers/runc" target="_blank" rel="noreferrer">runc</a></li><li><a href="https://github.com/containerd/containerd" target="_blank" rel="noreferrer">containerd</a></li><li><a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noreferrer">oci runtime spec</a></li><li><a href="https://github.com/opencontainers/image-spec" target="_blank" rel="noreferrer">oci image format spec</a></li><li><a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/" target="_blank" rel="noreferrer">Introducing Container Runtime Interface (CRI) in Kubernetes</a></li><li><a href="https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/" target="_blank" rel="noreferrer">Kubernetes Containerd Integration Goes GA</a></li></ul><h1 id="_4-cgroups" tabindex="-1">4. CGroups <a class="header-anchor" href="#_4-cgroups" aria-label="Permalink to &quot;4. CGroups&quot;">​</a></h1><h1 id="_5-namespace" tabindex="-1">5. namespace <a class="header-anchor" href="#_5-namespace" aria-label="Permalink to &quot;5. namespace&quot;">​</a></h1><ul><li><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noreferrer">namespaces(7) — Linux manual page</a></li></ul><h1 id="_6-容器仅仅是一种特殊的进程" tabindex="-1">6. 容器仅仅是一种特殊的进程 <a class="header-anchor" href="#_6-容器仅仅是一种特殊的进程" aria-label="Permalink to &quot;6. 容器仅仅是一种特殊的进程&quot;">​</a></h1><ul><li>容器实际上是一种特殊的进程。它使用namespace进行隔离，使用cgroup进行资源限制，并且它还以联合文件系统的形式挂载了单独的rootfs。</li><li>为了更方便的准备运行容器所需的资源和管理容器的生命周期，还需要容器引擎如containerd。</li><li>容器镜像实际上就是一种特殊的文件系统，它包含容器运行所需的程序、库、资源配置等所有内容，构建后内容保持不变。在启动容器时镜像会挂载为容器的rootfs。</li></ul><p>既然容器仅仅是一种特殊的进程，下面我们实际去探索一下它的存在。继续前面启动的redis容器为例，可以使用<code>nerdctl inspect &lt;container id&gt;</code>和<code>ctr c info &lt;container id&gt;</code>查看一下容器的信息。 下面的命令可以打印出容器在宿主机上的进程id:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">nerdctl inspect 8102f | grep Pid</span></span>
<span class="line"><span style="color:#e1e4e8;">            &quot;Pid&quot;: 27582,</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">nerdctl inspect 8102f | grep Pid</span></span>
<span class="line"><span style="color:#24292e;">            &quot;Pid&quot;: 27582,</span></span></code></pre></div>`,45),i=[a];function c(s,d,l,u,p,g){return n(),t("div",null,i)}const m=e(r,[["render",c]]);export{k as __pageData,m as default};
