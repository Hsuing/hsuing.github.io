import{_ as a,o as r,c as o,R as t}from"./chunks/framework.zUbWieqp.js";const u=JSON.parse('{"title":"1. Habor高可用架构","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/harbor/5-arch.md","filePath":"guide/container/harbor/5-arch.md","lastUpdated":1723529168000}'),e={name:"guide/container/harbor/5-arch.md"},h=t('<h1 id="_1-habor高可用架构" tabindex="-1">1. Habor高可用架构 <a class="header-anchor" href="#_1-habor高可用架构" aria-label="Permalink to &quot;1. Habor高可用架构&quot;">​</a></h1><h2 id="_1-1-habor主备" tabindex="-1">1.1 Habor主备 <a class="header-anchor" href="#_1-1-habor主备" aria-label="Permalink to &quot;1.1 Habor主备&quot;">​</a></h2><p><strong>主备Harbor互相镜像同步，搭配nginx作故障切换</strong></p><div class="danger custom-block"><p class="custom-block-title">❌ 注意</p><ul><li>主从Harbor不要开启https访问，https证书校验放在nginx层做</li><li>harbor镜像同步支持pull和push两种方式，我两种都配了，push是事件驱动，当有新镜像推到仓库中，会立刻向目标仓库同步，pull方式作为补偿，比如主harbor挂了五分钟，这五分钟内的镜像都推送到了从harbor中，当主harbor恢复后，这五分钟内产生的镜像会通过pull的方式同步到主harbor中</li></ul></div><h2 id="_1-2-habor双主" tabindex="-1">1.2 Habor双主 <a class="header-anchor" href="#_1-2-habor双主" aria-label="Permalink to &quot;1.2 Habor双主&quot;">​</a></h2><p><a href="https://iamyeka.github.io/2020/06/02/harbor/" target="_blank" rel="noreferrer">https://iamyeka.github.io/2020/06/02/harbor/</a></p><h2 id="_1-3-共享存储和共享数据库-推荐" tabindex="-1">1.3 共享存储和共享数据库-推荐 <a class="header-anchor" href="#_1-3-共享存储和共享数据库-推荐" aria-label="Permalink to &quot;1.3 共享存储和共享数据库-推荐&quot;">​</a></h2><p>官档,<a href="https://goharbor.io/docs/1.10/install-config/harbor-ha-helm/" target="_blank" rel="noreferrer">https://goharbor.io/docs/1.10/install-config/harbor-ha-helm/</a></p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202408081729833.png" alt="Harbor High Availability with Helm"></p>',9),i=[h];function l(n,s,c,b,_,d){return r(),o("div",null,i)}const g=a(e,[["render",l]]);export{u as __pageData,g as default};
