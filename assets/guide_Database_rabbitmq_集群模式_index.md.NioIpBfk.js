import{_ as e,o as t,c as a,R as r}from"./chunks/framework.zUbWieqp.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/rabbitmq/集群模式/index.md","filePath":"guide/Database/rabbitmq/集群模式/index.md","lastUpdated":1710405635000}'),o={name:"guide/Database/rabbitmq/集群模式/index.md"},n=r('<h2 id="_1-集群模式" tabindex="-1">1.集群模式 <a class="header-anchor" href="#_1-集群模式" aria-label="Permalink to &quot;1.集群模式&quot;">​</a></h2><p>RabbitMQ 是用 Erang 开发的，集群模式分为两种<code>普通模式</code> 和<code>镜像模式</code>，可以说<code>镜像模式</code>是<code>普通模式</code>的升级版，其中 RabbitMQ 默认使用的是 <code>普通模式</code></p><ul><li>普通模式：</li></ul><p>以两个节点（rabbit01、rabbit02）为例来进行说明，rabbit01 和 rabbit02 两个节点仅有相同的元数据，即队列的结构，但消息实体只存在于其中一个节点 rabbit01（或者 rabbit02）中。当消息进入 rabbit01 节点的 Queue 后，consumer 从 rabbit02 节点消费时，RabbitMQ 会临时在 rabbit01、rabbit02 间进行消息传输，把 A 中的消息实体取出并经过 B 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论 consumer 连 rabbit01 或 rabbit02，出口总在 rabbit01，会产生瓶颈。当 rabbit01 节点故障后，rabbit02 节点无法取到 rabbit01 节点中还未消费的消息实体。如果做了消息持久化，那么得等 rabbit01 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象</p><ul><li>镜像模式：</li></ul><p>在普通模式的基础上，把需要的队列做成镜像队列，存在于多个节点，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取，也就是说多少节点消息就会备份多少份。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉，所以在对业务可靠性要求较高的场合中适用。由于镜像队列之间消息自动同步，且内部有选举 Master 机制，即使 Master 节点宕机也不会影响整个集群的使用，达到去中心化的目的，从而有效的防止消息丢失及服务不可用等问题</p><h2 id="_2-集群节点的区别" tabindex="-1">2.集群节点的区别 <a class="header-anchor" href="#_2-集群节点的区别" aria-label="Permalink to &quot;2.集群节点的区别&quot;">​</a></h2><p>RabbitMQ 的集群节点分为磁盘节点、内存节点。RabbitMQ 支持消息的持久化，也就是数据写在磁盘上。在 RabbitMQ 集群中，必须至少有一个磁盘节点，否则队列元数据无法写入到集群中。当磁盘节点宕掉时，集群将无法写入新的队列元数据信息。如果 RabbitMQ 集群全部宕机，必须先启动磁盘节点，然后再启动内存节点。最合适的方案就是既有磁盘节点，又有内存节点，推荐 1 个 磁盘节点 + 2 个内存节点的集群搭建方式。</p><p><a href="https://www.jianshu.com/p/588e1c959f03" target="_blank" rel="noreferrer">https://www.jianshu.com/p/588e1c959f03</a></p><p><a href="https://www.cnblogs.com/leoyang63/articles/14033945.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/leoyang63/articles/14033945.html</a></p><p><a href="http://note.iawen.com/note/server/rabbitmq_base" target="_blank" rel="noreferrer">http://note.iawen.com/note/server/rabbitmq_base</a></p><p><a href="https://juejin.cn/post/6844904071183220749" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904071183220749</a></p><p><a href="https://segmentfault.com/a/1190000041104410" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000041104410</a></p><p><a href="https://cloud.tencent.com/developer/article/1631148" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/1631148</a></p><p><a href="https://www.cnblogs.com/lonely-wolf/p/14397704.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/lonely-wolf/p/14397704.html</a></p><p><a href="https://blog.csdn.net/IT_ZRS/article/details/120632932" target="_blank" rel="noreferrer">https://blog.csdn.net/IT_ZRS/article/details/120632932</a></p><p><a href="https://www.techgrow.cn/posts/486aeff3.html" target="_blank" rel="noreferrer">https://www.techgrow.cn/posts/486aeff3.html</a></p>',17),b=[n];function l(i,s,c,p,h,d){return t(),a("div",null,b)}const f=e(o,[["render",l]]);export{m as __pageData,f as default};
