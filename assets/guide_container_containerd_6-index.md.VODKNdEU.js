import{_ as e,o,c,R as d}from"./chunks/framework.zUbWieqp.js";const _=JSON.parse('{"title":"1.容器镜像构建工具和方案介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/containerd/6-index.md","filePath":"guide/container/containerd/6-index.md","lastUpdated":1731157838000}'),r={name:"guide/container/containerd/6-index.md"},a=d('<h1 id="_1-容器镜像构建工具和方案介绍" tabindex="-1">1.容器镜像构建工具和方案介绍 <a class="header-anchor" href="#_1-容器镜像构建工具和方案介绍" aria-label="Permalink to &quot;1.容器镜像构建工具和方案介绍&quot;">​</a></h1><p>如果你只是在单机本地构建镜像的话，使用<code>docker build</code>或<code>nerdctl+containerd+buildkit</code>确实没有问题，但实际</p><p>中由于不同场景和技术背景下的限制，如<code>docker build</code>依赖于<code>docker daemon</code>，这些限制使得在一些特殊的场景下</p><p>本机构建镜像的方式不再可用。</p><p>以cicd为列：</p><p>结合了容器技术，将Jenkins用于构建的Slave节点放到容器中，并基于K8S来动态调度管理这些Jenkins Slave容</p><p>器。这样一来Jenkins就具备了基于容器的分布式构建能力， 一个应用从源码经过各个阶段到最终的镜像是采用分布</p><p>式构建实现的，各个阶段也都是在容器中进行的。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202411092026077.png" alt="jenkins-slaves-in-k8s.png"></p><p>分布式构建，首先要面对的问题就是要在jenkins slave容器的内部构建镜像。由于docker是以docker cli和docker daemon的C/S形式工作，如果把docker cli放到jenkins slave容器里面执行docker build，那么docker build所需的docker daemon放哪儿呢? 于是就有了<code>Docker in Docker</code>和<code>Docker outside of Docker</code>两种方案</p><h2 id="_1-1-docker-in-docker" tabindex="-1">1.1 Docker in Docker <a class="header-anchor" href="#_1-1-docker-in-docker" aria-label="Permalink to &quot;1.1 Docker in Docker&quot;">​</a></h2><p><code>Docker in Docker</code>简称<code>DinD</code>。DinD模式是指在一个容器内部安装完整的docker服务，启动一个Docker</p><p>Daemon，然后就可以在容器内部使用docker cli进行镜像的构建。 此方案的优点是容器中的Docker Daemon与外</p><p>部完全隔离，隔离性较好，而缺点是容器内部比较臃肿复杂，同时要解决容器内docker服务的持久化存储、构建缓存</p><p>的问题，在安全上DinD还需要以特权(<code>--privileged</code>)形式启动容器，有安全风险。 因此这种方案在实际好少使用，</p><p>也<code>不推荐使用</code>。</p><h2 id="_1-2-docker-outside-of-docker" tabindex="-1">1.2 Docker outside of Docker <a class="header-anchor" href="#_1-2-docker-outside-of-docker" aria-label="Permalink to &quot;1.2 Docker outside of Docker&quot;">​</a></h2><p><code>Docker outside of Docker</code>简称<code>DooD</code>。DooD模式是指将容器外部宿主机上的docker daemon的socket挂载到容</p><p>器内，让容器内的docker cli误认为本地启动了docker daemon，这样进行docker build等命令操作时由容器外</p><p>部宿主机上的docker daemon处理请求。 此方案的优点是容器内部不需要安装docker daemon，构建在宿主机上进</p><p>行效率较高，缺点是没有与外部隔离，构建的镜像与宿主机上的镜像存在冲突的可能，同一宿主机上不支持并行构建。</p><p>在早些年前使用DooD这种方案的人比较多。</p><h2 id="_1-3-kaniko" tabindex="-1">1.3 Kaniko <a class="header-anchor" href="#_1-3-kaniko" aria-label="Permalink to &quot;1.3 Kaniko&quot;">​</a></h2><p>Kaniko是Google开源的一款容器镜像构建工具，可以用来在容器中或者Kubernetes集群中进行镜像的构建。 在Kaniko出现之前，使用Dockerfile和Docker cli来构建镜像时，需要将构建的上下文发送至docker daemon，Docker in Docker和Docker outside of Docker也不例外。 Kaniko构建容器镜像时并不依赖于Docker daemon，也不需要特权权限，这一特性使得kaniko成为DinD或者DooD之外的一种全新的解决方案。</p><p>Kaniko构建容器镜像时，需要三个输入: Dockerfile，构建上下文，以及构建成功后镜像在仓库中的存放地址。 kaniko executor需要在容器执行，前面三个输入可以挂载到kaniko executor的容器中。</p><p>Kaniko支持多种方式将构建上下文挂载到容器中： 可以使用本地文件夹，GCS bucket，S3 bucket等等方式，使用GCS 或者 S3时需要把上下文压缩为tar.gz，kaniko会自行在构建时解压上下文。</p><p>Kaniko executor在找到Dockerfile后会逐条解析Dockerfile内容，并且执行相关的命令。在用户目录中形成容器镜像的文件层，每条Dockerfile中的指令都执行完毕后，Kaniko会将新生成的镜像推送到指定的镜像仓库中去。 整个过程中，完全不依赖于docker daemon。</p>',27),n=[a];function i(k,t,p,s,l,D){return o(),c("div",null,n)}const h=e(r,[["render",i]]);export{_ as __pageData,h as default};
