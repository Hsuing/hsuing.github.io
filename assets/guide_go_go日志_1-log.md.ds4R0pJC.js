import{_ as e,o as r,c as o,R as i}from"./chunks/framework.zUbWieqp.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/go/go日志/1-log.md","filePath":"guide/go/go日志/1-log.md","lastUpdated":1760705628000}'),l={name:"guide/go/go日志/1-log.md"},a=i('<h3 id="panic最佳实践" tabindex="-1">panic最佳实践 <a class="header-anchor" href="#panic最佳实践" aria-label="Permalink to &quot;panic最佳实践&quot;">​</a></h3><ol><li>在程序启动时，出现明显的配置错误可以直接panic，防止错误的配置产生错误的数据</li><li>在程序启动时，如果关键组件启动失败就可以直接panic，比如mysql和redis连接错误</li><li>在web框架的入口处，都会加recover避免程序panic直接退出程序</li><li>不使用panic和recover做常用的错误处理 <ol><li>频繁 panic recover 性能不好</li><li>不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li></ol></li></ol><h3 id="error最佳实践" tabindex="-1">error最佳实践 <a class="header-anchor" href="#error最佳实践" aria-label="Permalink to &quot;error最佳实践&quot;">​</a></h3><ol><li><p>在应用程序中，我们一般使用</p><p>github.com/pkg/errors 这个库来处理应用错误</p><ol><li>在公共库中，一般不使用这个库，避免报错时产生多次堆栈</li><li>这个库当前已经归档，不少开源项目都不再使用这个库了，但是如果想要有完整的堆栈信息用于排查错误，这个库还是最合适的，等go2中关于错误的新语法出来之后，再决定是否要更换</li></ol></li><li><p>error应该是函数的最后一个返回值，当error不为nil时，函数的其他返回值我们都不应该再使用</p></li><li><p>错误处理的时候应该先判断错误<code>if err != nil</code>， 出现错误及时return，使代码是一条流畅的直线，避免过多的嵌套</p></li><li><p>在应用程序中<strong>首次</strong>出现错误时，使用 <code>errors.New</code> 或者 <code>errors.Errorf</code> 返回错误</p></li><li><p>如果是调用应用程序的其他函数出现错误，请直接返回，如果需要携带信息，请使用 <code>errors.WithMessage</code></p></li><li><p>如果是调用其他库（标准库、公共库、开源第三方库等）获取到错误时，请使用</p><p>errors.Wrap 添加堆栈信息</p><ol><li>为了避免多次堆栈，不要每个地方都是用 <code>errors.Wrap</code> 只需要在错误第一次出现时进行 <code>errors.Wrap</code> 即可</li></ol></li><li><p>根据“错误只处理一次”原则， <strong>禁止</strong>每个出错的地方都打日志，只需要在进程的最开始的地方使用 <code>%+v</code> 进行统一打印，例如 http/rpc 服务的中间件，或者是公司的kit库里面封装统一的middleware</p></li><li><p>错误判断使用 <code>errors.Is</code></p></li><li><p>错误判断并赋值使用 <code>errors.As</code></p></li><li><p>如何判定错误的信息是否足够，想一想当你的代码出现问题需要排查的时候你的错误信息是否可以帮助你快速的定位问题，例如我们在请求中一般会输出参数信息，用于辅助判断错误</p></li><li><p>对于业务错误，推荐在一个统一的地方创建一个错误字典，比如protobuf文件。错误字典里面应该包含错误的 code，并且在日志中作为独立字段打印，方便做业务告警的判断，错误必须有清晰的错误文档</p></li><li><p>错误的时候，需要处理已分配的资源，使用 <code>defer</code> 进行清理，例如文件句柄，或者是保存错误的操作记录。</p></li></ol>',4),c=[a];function p(t,d,s,n,_,g){return r(),o("div",null,c)}const f=e(l,[["render",p]]);export{u as __pageData,f as default};
