import{_ as s,o as a,c as o,R as e,k as n}from"./chunks/framework.zUbWieqp.js";const y=JSON.parse('{"title":"1. PromQL是什么?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/Monitor/Prometheus/4-promql_syntax.md","filePath":"guide/Linux/Monitor/Prometheus/4-promql_syntax.md","lastUpdated":1736331883000}'),t={name:"guide/Linux/Monitor/Prometheus/4-promql_syntax.md"},c=e(`<h1 id="_1-promql是什么" tabindex="-1">1. PromQL是什么? <a class="header-anchor" href="#_1-promql是什么" aria-label="Permalink to &quot;1. PromQL是什么?&quot;">​</a></h1><p>PromQL（Prometheus Query Language）是 Prometheus 自己开发的表达式语言，语言表现力很丰富，内置函数也很多。使用它可以对时序数据进行筛选和聚合。</p><h2 id="_1-1-组成" tabindex="-1">1.1 组成 <a class="header-anchor" href="#_1-1-组成" aria-label="Permalink to &quot;1.1 组成&quot;">​</a></h2><p>Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上，每个数据称为一个样本。时间序列（time-series）是按照时间戳和值的序列顺序存放的，我们称之为向量(vector). 每条时间序列（time-series）通过指标名称(metrics name)和一组标签集(labelset)命名。如下所示，可以将时间序列（time-series）理解为将多个时间序列（time-series）放在同一个坐标系内(以时间为横轴，以序列为纵轴)，将形成一个由数据点组成的矩阵;</p><p>可以把以下图想象成Promethus存储</p><ul><li>每一行代表一个时间序列（time-series）我们也称为一个向量(Vector)</li><li>每一列代表时间的流逝时间点</li></ul><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501081423452.png" alt="Prometheus-PromQL-1"></p><p>在时间序列（time-series）中的每一个点称为一个样本（sample），样本由以下三部分组成：</p><ul><li>指标名(metric name)：指标名（metric name）和描述当前样本特征的标签（labels）;</li><li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li><li>样本值(value)： 一个float64的浮点型数据表示当前样本的值。</li></ul><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501081430707.png" alt="Prometheus-PromQL-2"></p><h2 id="_1-1-指标类型" tabindex="-1">1.1 指标类型 <a class="header-anchor" href="#_1-1-指标类型" aria-label="Permalink to &quot;1.1 指标类型&quot;">​</a></h2><p>包含四种指标类型</p><ul><li>counter（计数器）</li><li>gauge （仪表类型）</li><li>histogram（直方图类型）</li><li>summary （摘要类型）</li></ul><h3 id="_1-counter-计数器" tabindex="-1">1.<strong>counter（计数器）</strong> <a class="header-anchor" href="#_1-counter-计数器" aria-label="Permalink to &quot;1.**counter（计数器）**&quot;">​</a></h3><p><strong>Counter</strong> (<strong>只增不减</strong>的计数器) 类型的指标其工作方式和计数器一样，只增不减。常见的监控指标，如 <strong>http_requests_total</strong>、 <strong>node_cpu_seconds_total</strong> 都是 <strong>Counter</strong> 类型的监控指标。</p><p>比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"># HELP node_cpu_seconds_total Seconds the cpus spent in each mode.</span></span>
<span class="line"><span style="color:#e1e4e8;"># TYPE node_cpu_seconds_total counter</span></span>
<span class="line"><span style="color:#e1e4e8;">node_cpu_seconds_total{cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;} 362812.7890625</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"># HELP node_cpu_seconds_total Seconds the cpus spent in each mode.</span></span>
<span class="line"><span style="color:#24292e;"># TYPE node_cpu_seconds_total counter</span></span>
<span class="line"><span style="color:#24292e;">node_cpu_seconds_total{cpu=&quot;cpu0&quot;,mode=&quot;idle&quot;} 362812.7890625</span></span></code></pre></div><ul><li><code>#HELP</code>：解释当前指标的含义，上面表示在每种模式下 node 节点的 cpu 花费的时间，以 s 为单位。</li><li><code>#TYPE</code>：说明当前指标的数据类型，上面是 counter 类型。</li></ul><h3 id="_2-gauge-仪表类型" tabindex="-1">2.<strong>gauge （仪表类型）</strong> <a class="header-anchor" href="#_2-gauge-仪表类型" aria-label="Permalink to &quot;2.**gauge （仪表类型）**&quot;">​</a></h3><p>与 <code>Counter</code> 不同， <code>Gauge</code>（可增可减的仪表盘）类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据<strong>可增可减</strong>。常见指标如：<code>node_memory_MemFree_bytes</code>（主机当前空闲的内存大小）、 <code>node_memory_MemAvailable_bytes</code>（可用内存大小）都是 <code>Gauge</code> 类型的监控指标。通过 <code>Gauge</code> 指标，用户可以直接查看系统的当前状态：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_memory_MemFree_bytes</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_memory_MemFree_bytes</span></span></code></pre></div><p>对于 <code>Gauge</code> 类型的监控指标，通过 <code>PromQL</code> 内置函数，使用 <code>predict_linear()</code> 对数据的变化趋势进行预测。例如，预测系统磁盘空间在 4 个小时之后的剩余情况：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">predict_linear(node_filesystem_free_bytes[1h], 4 * 3600)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">predict_linear(node_filesystem_free_bytes[1h], 4 * 3600)</span></span></code></pre></div><h3 id="_4-histogram-直方图类型-和-summary-摘要类型" tabindex="-1">4.<strong>Histogram（直方图类型） 和 Summary（摘要类型）</strong> <a class="header-anchor" href="#_4-histogram-直方图类型-和-summary-摘要类型" aria-label="Permalink to &quot;4.**Histogram（直方图类型） 和 Summary（摘要类型）**&quot;">​</a></h3><p><code>Histogram</code> 和 <code>Summary</code> 主用用于统计和分析样本的分布情况</p><p>指标 <code>prometheus_tsdb_wal_fsync_duration_seconds</code> 的指标类型为 Summary。它记录了 Prometheus Server 中 <code>wal_fsync</code> 的处理时间，通过访问 Prometheus Server 的 <code>/metrics</code> 地址，可以获取到以下监控样本数据：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.</span></span>
<span class="line"><span style="color:#e1e4e8;"># TYPE prometheus_tsdb_wal_fsync_duration_seconds summary</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&quot;0.5&quot;} 0.012352463</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&quot;0.9&quot;} 0.014458005</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&quot;0.99&quot;} 0.017316173</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_wal_fsync_duration_seconds_count 216</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.</span></span>
<span class="line"><span style="color:#24292e;"># TYPE prometheus_tsdb_wal_fsync_duration_seconds summary</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&quot;0.5&quot;} 0.012352463</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&quot;0.9&quot;} 0.014458005</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_wal_fsync_duration_seconds{quantile=&quot;0.99&quot;} 0.017316173</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_wal_fsync_duration_seconds_count 216</span></span></code></pre></div><p>类型为 Histogram 的监控指标 <code>prometheus_tsdb_compaction_chunk_range_seconds_bucket</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"># HELP prometheus_tsdb_compaction_chunk_range_seconds Final time range of chunks on their first compaction</span></span>
<span class="line"><span style="color:#e1e4e8;"># TYPE prometheus_tsdb_compaction_chunk_range_seconds histogram</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;100&quot;} 71</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;400&quot;} 71</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;1600&quot;} 71</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;6400&quot;} 71</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;25600&quot;} 405</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;102400&quot;} 25690</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;409600&quot;} 71863</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;1.6384e+06&quot;} 115928</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;6.5536e+06&quot;} 2.5687892e+07</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;2.62144e+07&quot;} 2.5687896e+07</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;+Inf&quot;} 2.5687896e+07</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_sum 4.7728699529576e+13</span></span>
<span class="line"><span style="color:#e1e4e8;">prometheus_tsdb_compaction_chunk_range_seconds_count 2.5687896e+07</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"># HELP prometheus_tsdb_compaction_chunk_range_seconds Final time range of chunks on their first compaction</span></span>
<span class="line"><span style="color:#24292e;"># TYPE prometheus_tsdb_compaction_chunk_range_seconds histogram</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;100&quot;} 71</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;400&quot;} 71</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;1600&quot;} 71</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;6400&quot;} 71</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;25600&quot;} 405</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;102400&quot;} 25690</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;409600&quot;} 71863</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;1.6384e+06&quot;} 115928</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;6.5536e+06&quot;} 2.5687892e+07</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;2.62144e+07&quot;} 2.5687896e+07</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_bucket{le=&quot;+Inf&quot;} 2.5687896e+07</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_sum 4.7728699529576e+13</span></span>
<span class="line"><span style="color:#24292e;">prometheus_tsdb_compaction_chunk_range_seconds_count 2.5687896e+07</span></span></code></pre></div><p>与 <code>Summary</code> 类型的指标相似之处在于 <code>Histogram</code> 类型的样本同样会反应当前指标的记录的总数(以 <code>_count</code> 作为后缀)以及其值的总量（以 <code>_sum</code> 作为后缀）。不同在于 <code>Histogram</code> 指标直接反应了在不同区间内样本的个数，区间通过标签 le 进行定义。</p><h1 id="_2-promql语法" tabindex="-1">2. PromQL语法 <a class="header-anchor" href="#_2-promql语法" aria-label="Permalink to &quot;2. PromQL语法&quot;">​</a></h1><h2 id="_2-1-数据类型" tabindex="-1">2.1 数据类型 <a class="header-anchor" href="#_2-1-数据类型" aria-label="Permalink to &quot;2.1 数据类型&quot;">​</a></h2><h3 id="_1-瞬时向量-instant-vector" tabindex="-1">1.瞬时向量-Instant vector <a class="header-anchor" href="#_1-瞬时向量-instant-vector" aria-label="Permalink to &quot;1.瞬时向量-Instant vector&quot;">​</a></h3><p>瞬时向量 (Instant vector): 一组时序，每个时序只有一个采样值</p><p>比如：node_memory_Active_bytes</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031345568.png" alt="image-20250103134525517"></p><h3 id="_2-区间向量-range-vector" tabindex="-1">2.区间向量-Range vector <a class="header-anchor" href="#_2-区间向量-range-vector" aria-label="Permalink to &quot;2.区间向量-Range vector&quot;">​</a></h3><p>区间向量 (Range vector): 一组时序，每个时序包含一段时间内的多个采样值</p><p>比如：node_memory_Active_bytes[1m]</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031349508.png" alt="image-20250103134906911"></p><h3 id="_3-标量数据-scalar" tabindex="-1">3.标量数据-Scalar <a class="header-anchor" href="#_3-标量数据-scalar" aria-label="Permalink to &quot;3.标量数据-Scalar&quot;">​</a></h3><p>标量数据 (Scalar): 一个浮点数</p><p>比如：10*10</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031351633.png" alt="image-20250103135100343"></p><div class="danger custom-block"><p class="custom-block-title">❌ 注意</p><p>需要注意的是，当使用表达式count(http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数scalar将单个瞬时向量转换为标量。</p></div><h3 id="_4-字符串-string" tabindex="-1">4.字符串-String <a class="header-anchor" href="#_4-字符串-string" aria-label="Permalink to &quot;4.字符串-String&quot;">​</a></h3><p>字符串 (String): 一个字符串，暂时未用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">字符串可以用单引号，双引号或反引号指定为文字，如果字符串内的特殊符号想要生效，我们可以使用反引号。</span></span>
<span class="line"><span style="color:#e1e4e8;">&quot;this is a string&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">&#39;these are unescaped: n t&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">\`these are not unescaped: n &#39; &quot; t\`</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">字符串可以用单引号，双引号或反引号指定为文字，如果字符串内的特殊符号想要生效，我们可以使用反引号。</span></span>
<span class="line"><span style="color:#24292e;">&quot;this is a string&quot;</span></span>
<span class="line"><span style="color:#24292e;">&#39;these are unescaped: n t&#39;</span></span>
<span class="line"><span style="color:#24292e;">\`these are not unescaped: n &#39; &quot; t\`</span></span></code></pre></div><h2 id="_2-2-时序选择器" tabindex="-1">2.2 时序选择器 <a class="header-anchor" href="#_2-2-时序选择器" aria-label="Permalink to &quot;2.2 时序选择器&quot;">​</a></h2><h3 id="_1-瞬时向量选择器" tabindex="-1">1.瞬时向量选择器 <a class="header-anchor" href="#_1-瞬时向量选择器" aria-label="Permalink to &quot;1.瞬时向量选择器&quot;">​</a></h3><p>瞬时向量选择器用来选择<strong>一组时序在某个采样点的采样值</strong></p><p>比如：拿node_cpu_seconds_total举例</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031359387.png" alt="image-20250103135925625"></p><p>可以通过在后面添加用大括号包围起来的一组标签键值对来对时序进行过滤。</p>`,54),p=n("p",{job:'node-exporter-10.103.236.199,mode="idle"'},"比如表达式，node_cpu_seconds_total",-1),l=e('<p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031401228.png" alt="image-20250103140116051"></p><p>匹配标签值时可以是<strong>等于</strong>，也可以<strong>使用正则表达式</strong>。总共有下面几种匹配操作符：</p><ul><li><code>=</code>：完全相等</li><li><code>!=</code>： 不相等</li><li><code>=~</code>： 正则表达式匹配</li><li><code>!~</code>： 正则表达式不匹配</li></ul><p>度量指标名可以使用内部标签 <code>__name__</code> 来匹配，表达式 <code>node_cpu_seconds_total</code> 也可以写成 <code>{__name__=&quot;node_cpu_seconds_total&quot;}</code>。表达式 <code>{__name__=~&quot;job:.*&quot;}</code> 匹配所有度量指标名称以 <code>job:</code> 打头的时序。</p><h3 id="_2-区间向量选择器" tabindex="-1">2.区间向量选择器 <a class="header-anchor" href="#_2-区间向量选择器" aria-label="Permalink to &quot;2.区间向量选择器&quot;">​</a></h3><p>区间向量选择器类似于瞬时向量选择器，不同的是它选择的是<strong>过去一段时间的采样值</strong>。可以通过在瞬时向量选择器后面添加包含在 <code>[]</code> 里的时长来得到区间向量选择器。比如下面的表达式选出了所有度量指标为 <code>node_cpu_seconds_total</code> 且 <code>job</code> 为 <code>prometheus</code> 的时序在过去 5 分钟的采样值。</p><p>比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_cpu_seconds_total{job=&quot;node-exporter-10.103.236.199&quot;}[1m]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_cpu_seconds_total{job=&quot;node-exporter-10.103.236.199&quot;}[1m]</span></span></code></pre></div><p><strong>说明：时长的单位可以是下面几种之一：</strong></p><ul><li>s：seconds</li><li>m：minutes</li><li>h：hours</li><li>d：days</li><li>w：weeks</li><li>y：years</li></ul><div class="danger custom-block"><p class="custom-block-title">❌ 注意</p><p>注意： 范围向量选择器返回的是一定时间范围内的数据样本，虽然不同时间序列的数据抓取时间点相同，但它们的时间戳并不会严格对齐；</p><p>多个Target上的数据抓取需要分散在抓取时间点前后一定的时间范围内，以均衡Prometheus Server的负载；</p><p>因而，Prometheus在趋势上准确，但并非绝对精准；</p></div><h3 id="_3-偏移修饰器" tabindex="-1">3.偏移修饰器 <a class="header-anchor" href="#_3-偏移修饰器" aria-label="Permalink to &quot;3.偏移修饰器&quot;">​</a></h3><p>前面介绍的选择器默认都是以当前时间为基准时间，偏移修饰器用来调整基准时间，使其往前偏移一段时间。偏移修饰器紧跟在选择器后面，使用 offset 来指定要偏移的量。比如下面的表达式选择度量名称为 <code>node_cpu_seconds_total</code> 的所有时序在 <code>5</code> 分钟前的采样值。</p><p>比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_cpu_seconds_total offset 1m</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_cpu_seconds_total offset 1m</span></span></code></pre></div><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031417980.png" alt="image-20250103141715612"></p><p>还比如，下面的表达式选择 <code>node_cpu_seconds_total</code> 度量指标在 <code>1</code> 周前的这个时间点过去 5 分钟的采样值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_cpu_seconds_total[5m] offset 1w</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_cpu_seconds_total[5m] offset 1w</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">❌ 注意</p><p>注意： offset 与 数据选择器是一个整体，不能分割 offset 偏移的是时间点</p></div>',19),r=[c,p,l];function i(_,d,u,h,m,g){return a(),o("div",null,r)}const q=s(t,[["render",i]]);export{y as __pageData,q as default};
