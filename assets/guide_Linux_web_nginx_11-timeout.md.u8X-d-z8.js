import{_ as e,o as t,c as s,R as n}from"./chunks/framework.zUbWieqp.js";const x=JSON.parse('{"title":"timeout","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/web/nginx/11-timeout.md","filePath":"guide/Linux/web/nginx/11-timeout.md","lastUpdated":1701684699000}'),a={name:"guide/Linux/web/nginx/11-timeout.md"},l=n(`<h1 id="timeout" tabindex="-1">timeout <a class="header-anchor" href="#timeout" aria-label="Permalink to &quot;timeout&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">http {</span></span>
<span class="line"><span style="color:#e1e4e8;">client_header_timeout 10s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> client_body_timeout 10s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> proxy_connect_timeout 10s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> proxy_send_timeout 55s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> proxy_read_timeout 60s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> keepalive_timeout  65s;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">http {</span></span>
<span class="line"><span style="color:#24292e;">client_header_timeout 10s;</span></span>
<span class="line"><span style="color:#24292e;"> client_body_timeout 10s;</span></span>
<span class="line"><span style="color:#24292e;"> proxy_connect_timeout 10s;</span></span>
<span class="line"><span style="color:#24292e;"> proxy_send_timeout 55s;</span></span>
<span class="line"><span style="color:#24292e;"> proxy_read_timeout 60s;</span></span>
<span class="line"><span style="color:#24292e;"> keepalive_timeout  65s;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">//nginx代理与后端服务器连接超时时间(代理连接超时)还未连接成功</span></span>
<span class="line"><span style="color:#e1e4e8;">Syntax:  proxy_connect_timeout time;</span></span>
<span class="line"><span style="color:#e1e4e8;">Default: proxy_connect_timeout 60s;</span></span>
<span class="line"><span style="color:#e1e4e8;">Context: http, server, location</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">//nginx代理等待后端服务器的响应时间（连接成功，等待读取资源）</span></span>
<span class="line"><span style="color:#e1e4e8;">Syntax:  proxy_read_timeout time;</span></span>
<span class="line"><span style="color:#e1e4e8;">Default: proxy_read_timeout 60s;</span></span>
<span class="line"><span style="color:#e1e4e8;">Context: http, server, location</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">//后端服务器数据回传给nginx代理超时时间（后段服务器给nginx传输资源的时间）</span></span>
<span class="line"><span style="color:#e1e4e8;">Syntax:  proxy_send_timeout time;</span></span>
<span class="line"><span style="color:#e1e4e8;">Default: proxy_send_timeout 60s;</span></span>
<span class="line"><span style="color:#e1e4e8;">Context: http, server, location</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">//nginx代理与后端服务器连接超时时间(代理连接超时)还未连接成功</span></span>
<span class="line"><span style="color:#24292e;">Syntax:  proxy_connect_timeout time;</span></span>
<span class="line"><span style="color:#24292e;">Default: proxy_connect_timeout 60s;</span></span>
<span class="line"><span style="color:#24292e;">Context: http, server, location</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">//nginx代理等待后端服务器的响应时间（连接成功，等待读取资源）</span></span>
<span class="line"><span style="color:#24292e;">Syntax:  proxy_read_timeout time;</span></span>
<span class="line"><span style="color:#24292e;">Default: proxy_read_timeout 60s;</span></span>
<span class="line"><span style="color:#24292e;">Context: http, server, location</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">//后端服务器数据回传给nginx代理超时时间（后段服务器给nginx传输资源的时间）</span></span>
<span class="line"><span style="color:#24292e;">Syntax:  proxy_send_timeout time;</span></span>
<span class="line"><span style="color:#24292e;">Default: proxy_send_timeout 60s;</span></span>
<span class="line"><span style="color:#24292e;">Context: http, server, location</span></span></code></pre></div><p>第一步请求头过来，</p><p>第二步连接upstream的server，</p><p>第三步将请求发送给upstream的server，</p><p>第四步接收upstream的server数据，</p><p>第五步是服务结束后是否采用长连接</p><ul><li>client_header_timeout 10s</li></ul><p>默认：60s</p><p>配在：http中、server中、location中</p><ul><li>client_body_timeout 10s</li></ul><p>默认：60s</p><p>配在：http中、server中</p><pre><code>  都跟请求相关，就一起理解了说了，这两个参数是对请求头和请求体（想了解请求头和请求体的概念自己百度）的超时时间，就是从三次握手到第一次读取请求头和请求体失败的时间。比如当前服务器负载大、网络卡，恰好在第一次读取请求头或请求提时没有得到且时间超过10s了，tengine就会超时报错，对于我当前应用而言，60s显而是太长了，优化到10s
</code></pre><ul><li>proxy_connect_timeout 10s;</li></ul><p>默认：60s</p><p>配在：http中、server中、location中</p><pre><code>   在收到请求头后，会将请求转发到upstream里面的server，这个呢就是与对应的server连接的超时时间，设置时最大值不能超过75s，我这里的server和tengine是放在同一个交换机上的内网，所以将连接时间优化到10s，超过10s连接不上，说明业务有问题了
</code></pre><ul><li>proxy_send_timeout 55s</li></ul><p>默认：60s</p><p>配在：http中、server中、location中</p><pre><code>  在与upstream的server建立连接后，就会把请求往server发送，这个时间是两次数据的发送时间差，不是整个发送过程的。比如说负载大、网络卡，在tengine向server发送请求时突然卡了一下，然后继续发送，而这两次的时间差（其实就是两次write的时间差）超过了我设置的55s，tengine就会超时报错，对于这个参数，我当前优化的是55s
</code></pre><ul><li>proxy_read_timeout 60s;</li></ul><p>默认：60s</p><p>配在：http中、server中、location中</p><pre><code> 在将请求发送给upstream的server后，后端server就会回传数据，这个时间是两次收取数据的时间差，不是整个的接收时间。比如说负载大、网络卡，在第1次收到请求的数据时断了，然后过了60s后才收到后面的数据，这两个时间差(其实就是两次read的时间差)超过了设置的60s，tengine（nginx）就会超时报错，我当前走的是默认设置60s
</code></pre><ul><li>keepalive_timeout 65s</li></ul><p>默认：75s</p><p>配在：http中、server中、location中</p><pre><code>  http是无状态的协议，当服务结束后，就面临着是否断开tcp连接的问题，当客户端或者服务器端需要时，可以在建链的时候采用长连接方式，即服务结束后在一段时间内不断开连接，当再有请求过来时省掉了建链的资源消耗，超时后tengine（nginx）会主动断开连接，当然配置里还有另外一个参数 keepalive_requests 600;，这个参数是说即使长连接没到过期时间，但服务的http总数量超过指定值后也是要断开连接，我目前设置的是600
</code></pre><ul><li>resolver_timeout 10s</li></ul><p>默认：30s</p><p>配在：http中、server中、location中</p><p>这个是dns解析超时时间，如果用作正向代理时就有用了，同时可以用resolver 127.0.0.1 valid=10m;指令来指定dns，后面是解析后缓存的有效时间。</p><p>server 127.0.0.1:9999 max_fails=20 fail_timeout=10s;</p><p>这个是指某一个upstream的server如果失败20次后，不可以操作的时间，默认就是10s，其实可以另外的写法配在http中，我习惯直接配在server的后端。</p><ul><li>keepalive_timeout 65 70</li></ul><p>这是前端keepalive_timeout的一个延伸配置，前面65是告诉客户端我给你保持多久，后面一个是多久我就给断开连接了</p><h2 id="_502-no-live" tabindex="-1">502，no live <a class="header-anchor" href="#_502-no-live" aria-label="Permalink to &quot;502，no live&quot;">​</a></h2><p>现象，*379803415 no live upstreams while connecting to upstream 的日志</p><p>no live upstreams</p><p>upstream prematurely closed connection while reading response header from upstream</p><p>tcpdump -nps0 -iany -w /tmp/20180617.pcap net [ip] and net [ip]</p><blockquote><p>解决方式</p></blockquote><p>1、如果系统并发量不大，没有必要开启长连接，有两种方式，</p><p>一、第一台nginx可以去除 proxy_http_version 1.1; proxy_set_header Connection &quot;0&quot;;这两个配置；</p><p>二、第二台nginx的keepalive_timeout可以配置为0（默认是75）。</p><p>2、上述问题我的解决方案是：暂时调大keepalive_timeout的值，先观察，但很有可能还是会有这个问题。</p><h2 id="错误日志类型" tabindex="-1">错误日志类型 <a class="header-anchor" href="#错误日志类型" aria-label="Permalink to &quot;错误日志类型&quot;">​</a></h2><ul><li>类型1: upstream timed out</li><li>类型2: connect() failed</li><li>类型3: no live upstreams</li><li>类型4: upstream prematurely closed connection</li><li>类型5: 104: Connection reset by peer</li><li>类型6: client intended to send too large body</li><li>类型7: upstream sent no valid HTTP/1.0 header</li></ul><h2 id="详细说明" tabindex="-1">详细说明 <a class="header-anchor" href="#详细说明" aria-label="Permalink to &quot;详细说明&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">错误日志</th><th style="text-align:left;">原因</th><th style="text-align:left;">解决办法</th></tr></thead><tbody><tr><td style="text-align:left;">类型</td><td style="text-align:left;">错误日志</td><td style="text-align:left;">原因</td><td style="text-align:left;">解决办法</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">upstream timed out (110: Connection timed out) while connecting to upstream</td><td style="text-align:left;">nginx与upstream建立tcp连接超时，nginx默认连接建立超时为200ms</td><td style="text-align:left;">排查upstream是否能正常建立tcp连接</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">upstream timed out (110: Connection timed out) while reading response header from upstream</td><td style="text-align:left;">nginx从upstream读取响应时超时，nginx默认的读超时为20s，读超时不是整体读的时间超时，而是指两次读操作之间的超时，整体读耗时有可能超过20s</td><td style="text-align:left;">排查upstream响应请求为什么过于缓慢</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">connect() failed (104: Connection reset by peer) while connecting to upstream</td><td style="text-align:left;">nginx与upstream建立tcp连接时被reset</td><td style="text-align:left;">排查upstream是否能正常建立tcp连接</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">connect() failed (111: Connection refused) while connecting to upstream</td><td style="text-align:left;">nginx与upstream建立tcp连接时被拒</td><td style="text-align:left;">排查upstream是否能正常建立tcp连接</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">no live upstreams while connecting to upstream</td><td style="text-align:left;">nginx向upstream转发请求时发现upstream状态全都为down</td><td style="text-align:left;">排查nginx的upstream的健康检查为什么失败</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;">upstream prematurely closed connection</td><td style="text-align:left;">nginx在与upstream建立完tcp连接之后，试图发送请求或者读取响应时，连接被upstream强制关闭</td><td style="text-align:left;">排查upstream程序是否异常，是否能正常处理http请求</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">recv() failed (104: Connection reset by peer) while reading response header from upstream</td><td style="text-align:left;">nginx从upstream读取响应时连接被对方reset</td><td style="text-align:left;">排查upstream应用已经tcp连接状态是否异常</td></tr><tr><td style="text-align:left;">6</td><td style="text-align:left;">client intended to send too large body</td><td style="text-align:left;">客户端试图发送过大的请求body，nginx默认最大允许的大小为1m，超过此大小，客户端会受到http 413错误码</td><td style="text-align:left;">调整请求客户端的请求body大小；调大相关域名的nginx配置：client_max_body_size；</td></tr><tr><td style="text-align:left;">7</td><td style="text-align:left;">upstream sent no valid HTTP/1.0 header</td><td style="text-align:left;">nginx不能正常解析从upstream返回来的请求行</td><td style="text-align:left;">排查upstream http响应异常</td></tr></tbody></table>`,53),p=[l];function i(o,r,c,d,u,y){return t(),s("div",null,p)}const g=e(a,[["render",i]]);export{x as __pageData,g as default};
