import{_ as e,o as t,c as r,R as n}from"./chunks/framework.zUbWieqp.js";const m=JSON.parse('{"title":"一、Kubeadm VS kubernetes 二进制","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/troubleshooting/12-Kubernetes建议.md","filePath":"guide/container/k8s/troubleshooting/12-Kubernetes建议.md","lastUpdated":1714315892000}'),l={name:"guide/container/k8s/troubleshooting/12-Kubernetes建议.md"},s=n('<h1 id="一、kubeadm-vs-kubernetes-二进制" tabindex="-1">一、Kubeadm VS kubernetes 二进制 <a class="header-anchor" href="#一、kubeadm-vs-kubernetes-二进制" aria-label="Permalink to &quot;一、Kubeadm VS kubernetes 二进制&quot;">​</a></h1><h4 id="_1-1kubeadm-方式部署-推荐" tabindex="-1"><strong>1.1kubeadm 方式部署（推荐）</strong> <a class="header-anchor" href="#_1-1kubeadm-方式部署-推荐" aria-label="Permalink to &quot;**1.1kubeadm 方式部署（推荐）**&quot;">​</a></h4><p><strong>推荐理由</strong>：</p><ol><li><strong>官方推荐</strong>：<code>kubeadm</code> 是 Kubernetes 官方提供的工具，用于快速搭建生产级别的 Kubernetes 集群，尤其适合于初次部署和对集群稳定性要求较高的场景。</li><li><strong>简化部署</strong>：<code>kubeadm</code> 自动处理了大量的初始化步骤，包括证书生成、网络配置、Pod 网络插件安装等，大大减少了手动操作和潜在错误。</li><li><strong>一致性</strong>：只要集群遵循最佳实践和官方规范，就易于维护和升级。</li><li><strong>可扩展性</strong>：适用于从小规模到大规模集群的部署，支持 HA（高可用）配置。</li><li><strong>社区支持</strong>：有丰富的文档和社区支持，便于排查问题和获取最新更新。</li><li>**易于集成：**对于集成自动化工具 Ansible 更加容易，也方便集成到公司运管平台。</li></ol><h4 id="_1-2kubernetes-二进制文件部署" tabindex="-1"><strong>1.2Kubernetes 二进制文件部署</strong> <a class="header-anchor" href="#_1-2kubernetes-二进制文件部署" aria-label="Permalink to &quot;**1.2Kubernetes 二进制文件部署**&quot;">​</a></h4><p><strong>适用场景</strong>：</p><ol><li><strong>完全手动控制</strong>：如果小伙伴们希望对每个组件的安装细节有完全的掌控权，比如在某些特殊环境中无法或不愿意使用自动化工具时。</li><li><strong>定制化需求</strong>：可能有一些特殊的网络配置、安全策略或其他自定义需求，需要逐一手动配置。</li><li><strong>学习和理解原理</strong>：对于想深入了解 Kubernetes 内部工作原理的人来说，手动部署有助于更好地理解各个组件之间的交互和依赖关系。</li></ol><p><strong>注意</strong>：</p><ul><li>二进制文件部署方式虽然更为灵活，但也意味着更高的复杂性和出错风险，特别是对于大型集群或多节点高可用配置。</li><li>维护和升级过程也相对繁琐，需要手动执行一系列命令来更新各个组件。</li></ul><p>除非有特定需求或学习目的，一般情况下，对于生产环境的部署，建议使用 <code>kubeadm</code>，因为它能提供更稳定、便捷且符合标准的操作流程。而对于想要深入学习 Kubernetes 架构时，可以选择二进制文件部署方式来了解集群内部构造</p><h1 id="二、集群网络组件的选择" tabindex="-1"><strong>二、集群网络组件的选择</strong> <a class="header-anchor" href="#二、集群网络组件的选择" aria-label="Permalink to &quot;**二、集群网络组件的选择**&quot;">​</a></h1><p>在 Kubernetes 集群中，选择合适的网络解决方案非常重要，因为它们负责提供跨节点容器间的服务发现、通信以及网络策略实施等功能</p><h4 id="flannel" tabindex="-1">Flannel： <a class="header-anchor" href="#flannel" aria-label="Permalink to &quot;Flannel：&quot;">​</a></h4><ul><li><p><strong>推荐理由</strong>：</p></li><li><ul><li>简单易用：Flannel设计简洁，易于安装和配置，特别适合于初学者和小型集群。</li><li>跨主机通信：它通过在集群内分配一个扁平化的IP地址空间来保证每个 Pod 都有一个唯一的IP地址，从而使得 Pod 之间可以直接通信。</li><li>支持多种后端：包括 VXLAN、Host-Gateway 2种模式，可根据底层网络基础设施灵活选择。</li></ul></li><li><p><strong>局限性</strong>：</p></li><li><ul><li>功能相对有限：相较于 Calico，Flannel 在网络策略方面的功能较弱，不提供精细化的网络策略控制。</li></ul></li></ul><h4 id="calico" tabindex="-1">Calico： <a class="header-anchor" href="#calico" aria-label="Permalink to &quot;Calico：&quot;">​</a></h4><ul><li><p><strong>推荐理由</strong>：</p></li><li><ul><li>精细化网络策略：Calico 提供了强大的网络策略管理和实施能力，可以精确控制 Pod 间的流量。</li><li>性能优越：由于其基于 BGP 协议，数据路径效率较高，特别适合大规模集群和对性能敏感的应用场景。</li><li>安全性：除了网络策略，Calico 还支持网络隔离、微分段等高级安全特性。</li><li>多云兼容：能够很好地适应公有云、私有云和混合云环境。</li></ul></li><li><p><strong>复杂度</strong>：</p></li><li><ul><li>Calico 的配置和维护相比 Flannel 来说稍微复杂一些，尤其是涉及到 BGP 路由配置时。</li></ul></li><li><h4 id="cni-网络方案优缺点及最终选择" tabindex="-1">CNI 网络方案优缺点及最终选择： <a class="header-anchor" href="#cni-网络方案优缺点及最终选择" aria-label="Permalink to &quot;CNI 网络方案优缺点及最终选择：&quot;">​</a></h4></li><li><p>至于怎么选择，我觉得需要先考虑几个问题，结合自己的业务场景去做应用：</p></li><li><p>1、需要细粒度网络访问控制？--&gt; flannel不支持，calico支持（ACL）；</p></li><li><p>2、追求网络性能？--&gt; flannel（host-gw），calico（BGP）；</p></li><li><p>3、当前架构下是否可以跑BGP协议？--&gt; 公有云有些不支持；</p></li><li><p>4、集群规模多大？--&gt; 100台node左右推荐（flannel，host-gw）维护方便；</p></li><li><p>5、是否有维护能力？--&gt; calico维护复杂，路由表！</p></li></ul><h1 id="三、持久化存储" tabindex="-1"><strong>三、持久化存储</strong> <a class="header-anchor" href="#三、持久化存储" aria-label="Permalink to &quot;**三、持久化存储**&quot;">​</a></h1><p>在 Kubernetes 集群中选择持久化存储方案时，需要考虑的因素还是蛮多的。不考虑外在因素，要看咱们整个团队或负责这块的同事是否专业于这块技术栈，记住，公司最宝贵的资源永远是数据（勿喷），下面我来通过几个不同的维度来分析下能够满足且可挑选的几个存储解决方案：</p><ol><li><p><strong>成本</strong>：</p></li><li><ul><li><strong>NFS</strong>: 一种成熟且广泛应用的网络文件系统，对于已有NAS设备的企业，利用NFS作为持久化存储是一种低成本的选择，只需安装NFS客户端和服务端即可。</li><li><strong>CEPH</strong>: 开源分布式存储系统，提供块存储（RBD）、文件系统（CephFS）和对象存储（RGW）。在集群规模较大、预算充足且希望利用硬件冗余提高数据安全性的场景下，CEPH是性价比较高的选择，因其可水平扩展并提供高可用性。</li><li><strong>MiniO</strong>（MinIO）：是一款开源的对象存储系统，对于需要大量非结构化数据存储，如图片、视频、日志等，MiniO可以作为S3兼容的对象存储服务，成本较低，且易于部署和管理。</li></ul></li><li><p><strong>性能与扩展性</strong>：</p></li><li><ul><li><strong>NFS</strong>: 性能受网络状况影响较大，不适合大规模并发读写或高 I/O 密集型应用。</li><li><strong>CEPH</strong>: 具备优秀的扩展性和性能优化，适合大数据分析、数据库存储等高性能应用场景。</li><li><strong>MiniO</strong>: 适合大规模对象存储场景，性能表现良好，尤其是在读写对象而非文件级别的操作上有优势。</li></ul></li><li><p><strong>数据可靠性与安全性</strong>：</p></li><li><ul><li><strong>NFS</strong>: 数据可靠性依赖于 NFS 服务器的稳定性和备份策略，安全性可通过权限管理增强。</li><li><strong>CEPH</strong>: 提供副本集、纠删码等机制保证数据高可用性和容灾能力，自带加密选项以增加安全性。</li><li><strong>MiniO</strong>: 支持多节点分布和纠删码，可提供企业级数据保护，同时也支持多种加密手段。</li></ul></li><li><p><strong>Kubernetes集成程度</strong>：</p></li><li><ul><li><strong>NFS</strong>: Kubernetes 可以通过 PV/PVC 和 StorageClass 支持 NFS，基于原生的动态供应功能，省时省力。</li><li><strong>CEPH</strong>: 提供 CSI（Container Storage Interface）驱动，支持动态存储类和持久卷的动态供应，无缝集成到Kubernetes生态系统中。</li><li><strong>MiniO</strong>: 也有相应的 CSI 插件，可以作为 Kubernetes 的持久化存储，同样支持动态卷供应。</li></ul></li><li><p><strong>运维难度与社区支持</strong>：</p></li><li><ul><li><strong>NFS</strong>: 配置相对简单，但其设计原理基于网络文件系统，可能存在一定的性能挑战。</li><li><strong>CEPH</strong>: 配置较为复杂，但因其广泛采用和活跃的社区，有大量的文档和案例可供参考。</li><li><strong>MiniO</strong>: 相比之下，部署和运维较为简便，社区活跃，且有详细的 Kubernetes 集成指南。</li></ul></li></ol><p><strong>总结：</strong></p><ul><li>若追求成本效益和快速部署，小型集群或非关键任务可选用 NFS；</li><li>对于大规模集群、需要高可用性和高性能存储，CEPH 是理想之选；</li><li>若侧重于非结构化数据的长期存储和分发，MiniO 是一个出色的对象存储解决方案。</li></ul><p>还是那句话，不是我不给大家结论，实在是考量的因素有点多。在实际应用中，还需要结合企业内部的IT基础设施现状、运维能力以及未来的扩容计划做出决策</p><h1 id="四、是否-helm-可作为线上应用管理工具" tabindex="-1"><strong>四、是否 Helm 可作为线上应用管理工具</strong> <a class="header-anchor" href="#四、是否-helm-可作为线上应用管理工具" aria-label="Permalink to &quot;**四、是否 Helm 可作为线上应用管理工具**&quot;">​</a></h1><p>这个我可以先给大家一个结论，我们作为一家某个行业内的互联网龙头企业，整个业务链都是基于 Helm 作为线上应用管理工具使用的。</p><p>另外 Helm 在云原生领域中得到了广泛的采纳和认可。我来通过如下几点来给大家聊下 Helm 在线上应用管理中的适用性：</p><ol><li><strong>简化部署与升级</strong>：Helm 提供了统一的、声明式的部署方式，允许通过简单的命令行工具即可安装、升级和删除复杂的 Kubernetes 应用。线上应用的生命周期管理变得更加高效和可靠。</li><li><strong>版本控制与回滚</strong>：Helm 采用了 Chart 的概念，包含了应用的所有YAML资源配置以及依赖关系，支持版本管理和应用历史记录。咱们可以轻易地对线上应用进行版本升级和回滚，这对于应对线上故障恢复和版本迭代尤为关键。</li><li><strong>标准化与复用</strong>：Helm Chart 作为一种标准化的包格式，允许应用开发者封装应用及其依赖项，形成可重复使用和共享的软件包。这有利于组织内部的标准化管理，也方便与其他开发者分享和交流。</li><li><strong>配置管理</strong>：Helm 允许通过 Values.yaml 文件进行参数化配置，使得同一 Chart 可以根据不同的环境变量和配置参数进行部署，满足线上环境多样化的配置需求。</li><li><strong>安全性与审计</strong>：Helm 通过数字签名和验证机制增强了应用的安全性，同时每一次的部署变更都可通过 Helm 的历史记录来进行审计跟踪。</li><li><strong>生态丰富</strong>：Helm 拥有庞大的社区支持和丰富的软件仓库，许多流行的 Kubernetes 应用都有对应的官方或社区维护的 Chart，极大地方便了线上应用的管理。</li></ol><p>我们当前的团队小伙伴们，每个人负责几个业务线，同时大家会根据当前所负责的业务属性不定期开发、优化、迭代某类应用的 Charts 包，这样对于 DEV 和 OPS 的衔接更加的密切，从而更加的了解线上应用的状态和配置。</p><p>另外，无论是从简化运维、保障应用一致性还是提高团队协作效率的角度来看，Helm 都是线上 Kubernetes 应用管理的理想选择。通过使用 Helm，运维人员能够更好地聚焦于应用本身的服务质量和业务发展，而不必花费过多精力在基础设施的复杂部署流程上</p><h1 id="五、cicd-工具的选择" tabindex="-1"><strong>五、CICD 工具的选择</strong> <a class="header-anchor" href="#五、cicd-工具的选择" aria-label="Permalink to &quot;**五、CICD 工具的选择**&quot;">​</a></h1><p>在 Kubernetes 技术栈中，CICD 这个话题，大家正确看待就好了，不要总是听别人说，每个技术栈的发展和应用都有各自的优势，Jenkins 发展至今，难道就通过 kubernetes 某些层面直接否定？不现实的。我们企业仍然是基于 Jenkins 贯穿整个 CICD 的上线流程，而且没有遇到多少因为自身瓶颈卡脖子的问题，虽然业界有些软件与 kubernetes 的匹配度较高，但是真的适用你们企业的？还是通过几个维度来做个分析吧：</p><p><strong>集成与兼容性</strong>：</p><ul><li><strong>Jenkins</strong>：是最老牌的持续集成工具之一，通过 Kubernetes 插件可以非常好地与 K8s 集成，能够在 Kubernetes 集群中创建 Jenkins Slave Pod 实现弹性伸缩和资源优化。同时，Jenkins 有着丰富的插件生态，可以与各种 Git 仓库、Harbor、以及 Kubernetes 自身的 API 进行深度集成。</li><li><strong>ArgoCD</strong>：专注于 Continuous Delivery（CD），作为 Kubernetes 的原生 CD 工具，它充分利用了 K8s 的声明式 API 对象（如 YAML 文件）来实现应用的部署和管理。ArgoCD 强调 GitOps 模式，将 Kubernetes 应用的整个生命周期管理与 Git 版本控制系统紧密绑定，支持自动同步和差异检测。</li><li><strong>GitLab CI/CD</strong>：GitLab 自带了一整套完整的 CI/CD 工具链，不仅限于构建、测试和部署，还包括从代码托管、静态代码分析、安全扫描到制品库管理等多个环节。GitLab CI/CD 支持与 Kubernetes 集成，可以轻松地将应用部署到 Kubernetes 集群，并提供了一系列预设的 Kubernetes 部署模板。</li></ul><p><strong>易用性与学习曲线</strong>：</p><ul><li><strong>Jenkins</strong>：高度可定制，但这也意味着学习和配置成本相对较高，对于复杂场景非常灵活，但对于初级用户可能需要更多时间去理解和掌握。</li><li><strong>ArgoCD</strong>：侧重于应用部署和管理，概念清晰，对于熟悉 Kubernetes 的 DevOps 团队而言，学习曲线相对较平缓，易于上手。</li><li><strong>GitLab CI/CD</strong>：因集成在 GitLab 平台中，所以对于已经使用 GitLab 的团队来说，其 CI/CD 流程的配置非常直观，YAML 配置文件 (<code>gitlab-ci.yml</code>) 易于编写和维护，同时提供了图形化界面辅助配置和监控。</li></ul><p><strong>自动化与扩展性</strong>：</p><ul><li><strong>Jenkins</strong>：通过编写 Groovy 脚本和使用各种插件，几乎可以实现任何形式的自动化流程，但有时需要手工维护这些脚本和配置。</li><li><strong>ArgoCD</strong>：专注于 Kubernetes 应用的自动化部署和运维，支持蓝绿部署、滚动更新、灰度发布等高级策略，通过 GitOps 模式实现了持续部署的自动化循环。</li><li><strong>GitLab CI/CD</strong>：内置了众多自动化阶段，支持流水线的可视化编排，且由于与 GitLab 无缝衔接，可以轻松实现从代码提交到上线的完整自动化流程。</li></ul><p><strong>社区支持与生态</strong>：</p><ul><li><strong>Jenkins</strong>：有庞大的社区支持，积累了大量的插件和教程，遇到问题容易找到解决方案。</li><li><strong>ArgoCD</strong>：随着 GitOps 理念的流行，ArgoCD 社区也在迅速壮大，尤其是在 Kubernetes 生态圈内，得到了广泛的认可和支持。</li><li><strong>GitLab CI/CD</strong>：作为一体化 DevOps 平台的一部分，GitLab CI/CD 依托 GitLab 社区的强大实力，拥有活跃的开发者和使用者群体。</li></ul><p>对于 Kubernetes 集群的 CI/CD 工具选择，如果是成熟的团队、需要高度定制化流程，并且已经有 Jenkins 使用经验，那么继续使用 Jenkins 并配合 Kubernetes 插件是个不错的选择；</p><p>如果希望拥抱 GitOps，简化应用部署和管理流程，ArgoCD 是一个很好的选择；</p><p>而对于希望在一个平台上完成全流程 DevOps 工作流，并且重视与代码版本管理紧密集成的团队，GitLab CI/CD 提供了一站式解决方案。</p><p>另外，在实际运用中，往往会选择组合使用这些工具，比如 Jenkins 或 GitLab CI/CD 负责 CI 部分，然后使用 ArgoCD 负责 CD 部分，以实现最佳效果</p><h1 id="六、集群应用网关" tabindex="-1"><strong>六、集群应用网关</strong> <a class="header-anchor" href="#六、集群应用网关" aria-label="Permalink to &quot;**六、集群应用网关**&quot;">​</a></h1><p>在 Kubernetes 技术栈中，选择集群应用网关（Ingress Controller）是一项重要的决定，不同的 Ingress Controller 工具各有优劣，我选择了下几个较为热门的网关，从几个重要维度对比一下 ingress-nginx、nginx-ingress、APISIX 和 Kong：</p><ol><li><p><strong>功能完备性</strong>：</p></li><li><ul><li><strong>Ingress-nginx</strong>：基于 Nginx 实现，由 Kubernetes 社区积极维护开源，提供基本的 Ingress 功能，包括 HTTP(S) 路由、TLS 终止、重写规则等，对于常规需求有足够的支持，但相比于其他工具可能在高级特性上略显不足。</li><li><strong>Nginx-ingress-controller</strong>：也是基于 Nginx，老牌负载均衡器，拥有更丰富的特性集，支持 Path 重写、Session 亲和性、全局速率限制等，更适合复杂的应用场景。</li><li><strong>APISIX</strong>：是云原生的API网关，除了基本的 Ingress 功能外，还提供了更多的高级特性，如金丝雀发布、蓝绿部署、服务熔断、JWT认证、ACL等，特别适合微服务架构和 API 管理。</li><li><strong>Kong</strong>：作为一款知名且成熟的 API 网关，除了 Ingress 的基本功能外，还有强大的插件系统支持，可以实现身份认证、限流、日志、监控等各种功能，非常适合企业级和大规模部署。</li></ul></li><li><p><strong>性能与扩展性</strong>：</p></li><li><ul><li><strong>Ingress-nginx</strong>：由于直接基于Nginx，性能优异，但扩展性依赖于额外开发或配置。</li><li><strong>Nginx-ingress-controller</strong>：同样基于 Nginx，性能优秀，并且支持水平扩展和HA部署。</li><li><strong>APISIX</strong>：性能表现优秀，通过异步非阻塞模型实现高并发处理，且具备较好的扩展性和可插拔性。</li><li><strong>Kong</strong>：以其性能见长，通过 Lua 插件系统实现高效扩展，支持大型集群部署和高可用架构。</li></ul></li><li><p><strong>易用性与社区支持</strong>：</p></li><li><ul><li><strong>Ingress-nginx</strong>：由 Kubernetes 社区发起并开源的一个项目，旨在为 Kubernetes 提供一个官方支持的 Ingress 控制器实现。</li><li><strong>Nginx-ingress-controller</strong>：由 NGINX 官方社区发起并开源，专门针对 Kubernetes 平台开发，为用户提供了一个专业、稳定的 Ingress 解决方案。</li><li><strong>APISIX</strong>：中国开源项目，有中文社区支持，文档完善，社区活跃度高，且逐渐在全球范围内获得广泛关注。</li><li><strong>Kong</strong>：国际知名的API网关项目，有丰富的文档和活跃的全球社区，商业支持也相当成熟。</li></ul></li><li><p><strong>云原生与集成</strong>：</p></li><li><ul><li><strong>Ingress-nginx</strong> 和 <strong>Nginx-ingress-controller</strong>：均较好地支持 Kubernetes 环境，但可能在服务网格和云原生服务治理方面不如 APISIX 和 Kong。</li><li><strong>APISIX</strong>：原生支持云环境，整合了服务网格概念，与 Kubernetes 生态融合度高，且可与 Linkerd、Istio 等服务网格协同工作。</li><li><strong>Kong</strong>：不仅可以作为 Kubernetes Ingress Controller，还支持多云和混合云环境，可以与云服务商提供的服务如 AWS Lambda 等深度集成。</li></ul></li></ol><p>Ingress-nginx 更注重与 Kubernetes 生态系统的紧密集成和功能扩展，而 NGINX Ingress Controller 则强调与 Nginx 产品的原生集成、稳定性以及官方支持的优势。在实际使用中，用户可以根据自身对 Kubernetes 集成深度的需求、对 Nginx 功能扩展的要求以及对官方支持和长期维护的关注程度，来选择适合自己的 Ingress 控制器方案。</p><p>对于特别依赖或微服务架构下需要更强大 API 管理功能的场景，APISIX 和 Kong 则提供了更多的增值功能。APISIX 更适合寻求国产自主可控、高度集成Kubernetes 生态、追求高性能和灵活扩展的团队。而 Kong 则在国际化支持、企业级 API 管理、与多种云服务集成等方面表现出色，适合全球化运营和技术要求更高的组织。</p><p>选择哪种工具，应根据具体业务需求、团队技能、技术支持以及未来发展规划来综合评估。</p><h1 id="七、监控平台解决方案" tabindex="-1"><strong>七、监控平台解决方案</strong> <a class="header-anchor" href="#七、监控平台解决方案" aria-label="Permalink to &quot;**七、监控平台解决方案**&quot;">​</a></h1><p>Zabbix 和 Prometheus 是两种广泛应用的监控解决方案，它们各自具有独特的特性和适用场景。接下来，我来将对二者进行对比，并重点阐述 Prometheus 在 Kubernetes 上的优势，以及 Prometheus 与 Prometheus Operator 的区别和介绍。</p><p><strong>Zabbix VS Prometheus：</strong></p><ul><li><strong>Zabbix</strong> 是一个传统的监控系统，提供丰富的监控功能，包括自动发现、阈值警告、图表展示等，支持多种类型的数据采集，如系统性能、网络流量、数据库状态等。Zabbix 的配置相对传统，依赖于中央服务器架构，虽然也能监控 Kubernetes，但并不原生支持 Kubernetes 的声明式和动态资源管理模式。</li><li><strong>Prometheus</strong> 是专为云原生环境设计的监控和警报系统，尤其在 Kubernetes 环境下表现卓越。Prometheus 采用 Pull/Push 模型抓取监控数据，支持多维度数据模型，具有强大的查询语言 PromQL，可进行灵活的数据聚合和分析。Prometheus 通过 ServiceMonitor CRD （自定义资源定义）可以自动发现并监控 Kubernetes 中的服务和 Pod，完美契合 Kubernetes 的声明式理念。</li></ul><p><strong>Prometheus 在 Kubernetes 上的优势：</strong></p><ol><li><strong>原生集成</strong>：Prometheus 与 Kubernetes 有深度集成，通过 Prometheus Operator 可以自动发现和监控 Kubernetes 中的资源，无需手动配置监控目标。</li><li><strong>声明式监控</strong>：Prometheus 通过 ServiceMonitor、PodMonitor 等 CRD 实现监控配置的声明式管理，符合 Kubernetes 的管理范式，简化了监控配置的复杂性。</li><li>**Prometheus 丰富生态：**Prometheus 生态圈包括 Grafana（数据可视化）、Alertmanager（警报管理）、 exporters（各类监控指标收集器）等工具，共同形成了强大的云原生监控解决方案。</li><li><strong>灵活查询与告警</strong>：PromQL 提供了灵活的监控指标查询和聚合功能，以及强大的告警规则定义能力，能够满足复杂场景下的监控需求。</li></ol><p><strong>Prometheus VS Prometheus Operator</strong></p><ul><li><p><strong>Prometheus</strong>：本身是一个独立的监控系统，用于收集和存储时间序列数据，并通过查询引擎进行数据分析和告警触发。</p></li><li><p><strong>Prometheus Operator</strong>：是为了在 Kubernetes 上更方便地管理和部署 Prometheus 监控系统而设计的。它通过 Custom Resource Definitions（CRDs）将 Prometheus 监控相关的配置转化为 Kubernetes 对象，使得 Prometheus 的部署和管理变得更符合 Kubernetes 的管理风格。</p></li><li><p><strong>优势</strong>：Prometheus Operator 提供了以下核心功能：</p></li><li><ul><li><strong>简化部署和管理</strong>：通过 Operator 创建和管理 Prometheus Server、Alertmanager、ServiceMonitor 和其他 CRDs，简化了部署过程，提高了配置的一致性和可维护性。</li><li><strong>声明式配置</strong>：通过 CRDs 实现监控目标的声明式配置，自动发现和监控 Kubernetes 集群中的服务。</li><li><strong>高可用与扩展性</strong>：可以方便地创建高可用的 Prometheus 集群，并支持水平扩展。</li></ul></li></ul><p>至此，随着当前技术栈的不停迭代和发展，在 Kubernetes 环境下，Prometheus 凭借其与 Kubernetes 的紧密集成、声明式配置以及强大的生态系统，成为越来越多企业的首选监控方案。而 Prometheus Operator 进一步提升了 Prometheus 在 Kubernetes 上的易用性和可靠性，使大规模集群监控更加得心应手</p><h1 id="八、可观察性的抉择" tabindex="-1"><strong>八、可观察性的抉择</strong> <a class="header-anchor" href="#八、可观察性的抉择" aria-label="Permalink to &quot;**八、可观察性的抉择**&quot;">​</a></h1><p>Kubernetes 技术栈中，选择可观测性（Observability）和 APM（Application Performance Monitoring，应用性能监控）工具是非常关键的，这有助于提升系统的可运维性和故障排查效率。</p><p>SkyWalking 和 OpenTelemetry 是目前市场上备受关注的两款工具，它们分别从不同角度提供可观测性支持，下面从多个维度对比和推荐：</p><p><strong>功能特性：</strong></p><ul><li><strong>SkyWalking</strong>：是一款应用性能监视系统，专注于服务网格、微服务和云原生环境的可观测性，提供了服务拓扑发现、分布式追踪、性能指标监控、告警和诊断等功能。SkyWalking 支持多种语言 SDK，并有与 Kubernetes 集成的良好支持，可以方便地监控部署在 Kubernetes 上的应用程序。</li><li><strong>OpenTelemetry</strong>：是一个开放标准的可观测性数据收集、传输和导出框架，旨在统一行业内各种监控和追踪工具的数据格式。OpenTelemetry 提供了统一的 SDK 用于在多种编程语言中产生遥测数据，包括 traces、metrics 和 logs，并支持将数据发送至多种后端分析和存储系统，如 Jaeger、Zipkin、Prometheus 和 SkyWalking 等。</li></ul><p><strong>开箱即用程度：</strong></p><ul><li><strong>SkyWalking</strong>：提供了一站式的解决方案，自带 UI 界面，易于部署和快速启用，尤其对于 Apache APISIX、Spring Boot、Java、Go 等语言和框架支持良好。</li><li><strong>OpenTelemetry</strong>：作为一套标准和 SDK，本身并未提供完整的 UI 和数据存储分析组件，但它提供了广泛的适配器，可以与很多已有的 APM 和可观测性工具对接，用户需要选择合适的后端存储和分析工具。</li></ul><p><strong>生态与兼容性：</strong></p><ul><li><strong>SkyWalking</strong>：有着丰富的生态，但主要是围绕其自身的体系构建，兼容性体现在支持多种语言和框架的探针上。</li><li><strong>OpenTelemetry</strong>：生态更为广阔，由于是 CNCF 项目，已被业界广泛接受和采纳，几乎所有的主流云服务商和 APM 工具都在支持 OpenTelemetry 标准，这使得数据可以更容易地迁移到不同工具或云服务中。</li></ul><p><strong>定制化需求：</strong></p><ul><li><strong>SkyWalking</strong>：对于寻求一站式解决方案、注重快速部署和高效分析的企业，SkyWalking 可能是更合适的选择，尤其适合已经在使用 Apache SkyWalking 生态的团队。</li><li><strong>OpenTelemetry</strong>：对于期望更灵活的集成策略、愿意投入更多精力构建个性化可观测性体系的企业，OpenTelemetry 提供了更多的定制化可能性。可以依据不同需求选择最适合的后端系统，且随着标准的普及和发展，未来兼容性和扩展性更强。</li></ul><p><strong>总结推荐：</strong></p><ul><li>如果你希望有一个快速部署、功能全面且对 Kubernetes 环境支持良好的一站式解决方案，SkyWalking 是值得推荐的。</li><li>如果你的企业需要一个更灵活、开放的标准框架，以便与现有或未来的各种可观测性工具无缝对接，并且看重生态的多样性，OpenTelemetry 是更好的选择。</li></ul><p>实际上，许多情况下，这两个工具并不是互斥的，而是可以结合使用。例如，可以使用 OpenTelemetry SDK 收集应用的可观测性数据，然后将这些数据输出给 SkyWalking 或其他支持 OpenTelemetry 的后端系统进行进一步分析和展示</p><h1 id="九、istio-到底要不要安排" tabindex="-1">九、Istio 到底要不要安排？ <a class="header-anchor" href="#九、istio-到底要不要安排" aria-label="Permalink to &quot;九、Istio 到底要不要安排？&quot;">​</a></h1><p>Istio 作为服务网格（Service Mesh）解决方案，在 Kubernetes 架构中，它通过在微服务间提供一致的安全、连接、可观测性和流量管理能力，显著提高了云原生应用的运维效率和整体性能。Istio 是否具有全面应用的可行性？有哪些风险点以及注意事项，今天咱们就展开聊聊：</p><p><strong>Istio 功能&amp;认可度：</strong></p><ul><li><strong>全面兼容性</strong>：Istio 通过 Sidecar 模式部署 Envoy 代理，能够与多种编程语言和框架编写的微服务兼容，只要这些服务部署在 Kubernetes 集群中，就能够在不修改服务代码的情况下，应用 Istio 的服务治理功能。</li><li><strong>功能完备</strong>：Istio 提供了丰富的功能集，包括流量管理（路由、熔断、重试、超时等）、安全策略（身份认证、授权、密钥交换等）、可观测性（跟踪、监控、日志等）以及渐进式采用的能力，使得它在很多场景下具有全面应用的可行性。</li><li><strong>模块化部署</strong>：Istio 由数据面板（Data Plane）和控制面板（Control Plane）两部分组成，可以根据需要单独部署 Istio 的服务治理功能（如 Envoy sidecar 代理）或流量管理功能（如 Pilot、Galley、 Citadel 等控制组件）。</li><li><strong>行业接受度</strong>：Istio 在业界获得了广泛的应用和好评，其背后的 Google、IBM、Lyft 等公司持续投入开发和维护，使得 Istio 成为了云原生时代服务治理的事实标准之一。</li></ul><p><strong>Istio 技术栈是否特别复杂？</strong></p><ul><li>Istio 由于其功能丰富，涉及到了服务间的通信管理、安全控制、可观测性等诸多方面，的确具有一定的技术复杂性。不过，Istio 的设计理念是尽可能减少对应用代码的侵入，通过 Sidecar 模式让 Envoy 代理接管服务间通信，从而实现上述功能。尽管如此，对于初次接触的服务治理工具的团队，确实需要一定时间去学习和理解 Istio 的核心概念和配置方法。但随着对服务网格理解的加深和实践经验的积累，大部分团队都能够逐步掌握并发挥其优势。</li></ul><p><strong>Istio 服务挂了，是否会影响整个集群的应用？</strong></p><ul><li>Istio 的核心组件（例如 Pilot、Galley、 Citadel 等）失效，确实可能对集群中部分服务的正常运作产生影响，尤其是流量管理和安全性相关的功能。然而，Envoy 代理在设计上具有一定的容错性，例如它可以缓存一部分配置，短时间内即使控制面板不可用，服务间的通信也不一定会立刻中断。即便如此，为了避免单点故障，Istio 提倡部署高可用的控制面，并且可以在适当时候通过冗余和故障转移来确保服务的连续性。</li></ul><p><strong>Istio 是否具有全面应用的可行性？</strong></p><ul><li>Istio 已经在众多生产环境中得到了验证和应用，证明了其在 Kubernetes 架构中全面应用的可行性。对于需要复杂服务间通信管理、安全策略、可观测性等功能的企业级应用，Istio 是一种理想的解决方案。然而，是否适用于每个具体的项目或场景，则需要根据项目规模、业务需求、团队技术栈以及运维能力等多方面因素综合评估。</li></ul><p><strong>风险点与注意事项：</strong></p><ul><li><strong>资源开销</strong>：每个 Pod 中额外的 Envoy 代理会占用一定的计算和内存资源，需要在容量规划时加以考虑。</li><li><strong>性能影响</strong>：虽然 Envoy 是高性能代理，但在极端场景下仍可能带来性能损失，需关注并针对性优化。</li><li><strong>运维复杂度</strong>：随着 Istio 的引入，运维人员需要掌握新工具和配置，这对团队的学习成本和运维能力提出了更高要求。</li><li><strong>稳定性与可用性</strong>：确保 Istio 控制面组件的高可用性，避免单点故障导致的服务中断。</li><li><strong>升级策略</strong>：Istio 的升级需要精心规划，防止中间版本兼容性问题或配置丢失导致的服务异常。</li></ul><p>不过，总的来说，Istio 作为服务网格解决方案确实增强了云原生应用的运维和管理能力，但在全面应用时需充分考虑其复杂性、资源消耗、运维要求以及可能的风险点，并采取适当的策略和措施予以应对。也不是说，全部的业务场景都适用，如果仅有很少量的应用而且服务层面也不需要很精度的流量控制，那真的就没必要了。另外核心维护人员对于 Istio 的技能熟悉度也是考量之一！从外部来看，随着技术的演进和社区支持的加强，Istio 在许多场合下已经成为推动微服务治理现代化的重要力量</p>',84),o=[s];function i(g,a,u,p,b,h){return t(),r("div",null,o)}const P=e(l,[["render",i]]);export{m as __pageData,P as default};
