import{_ as a,o as e,c as t,R as r}from"./chunks/framework.zUbWieqp.js";const o="/assets/w2.rfTzIbXL.jpg",m=JSON.parse('{"title":"RabbitMQ集群架构模式-多活模式（Federation）--异地数据复制的主流模式","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/rabbitmq/集群模式/3-多活模式.md","filePath":"guide/Database/rabbitmq/集群模式/3-多活模式.md","lastUpdated":1710405635000}'),i={name:"guide/Database/rabbitmq/集群模式/3-多活模式.md"},s=r('<h1 id="rabbitmq集群架构模式-多活模式-federation-异地数据复制的主流模式" tabindex="-1">RabbitMQ集群架构模式-多活模式（Federation）--异地数据复制的主流模式 <a class="header-anchor" href="#rabbitmq集群架构模式-多活模式-federation-异地数据复制的主流模式" aria-label="Permalink to &quot;RabbitMQ集群架构模式-多活模式（Federation）--异地数据复制的主流模式&quot;">​</a></h1><p>也是实现异地数据复制的主流模式，因为 shovel 模式配置比较复杂，所以一般来说，实现异地集群的都是采用这种双活 或者 多活模型来实现的。这种模式需要依赖 rabbitMQ 的 federation 插件，可以实现持续的，可靠的 AMQP 数据通信，多活模式在实际配置与应用非常的简单</p><h2 id="多活模式1" tabindex="-1">多活模式1 <a class="header-anchor" href="#多活模式1" aria-label="Permalink to &quot;多活模式1&quot;">​</a></h2><p>rabbitMQ 部署架构采用双中心模式(多中心)，那么在两套(或多套)数据中心各部署一套 rabbitMQ 集群，各中心的rabbitMQ 服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享</p><h2 id="多活模式2" tabindex="-1">多活模式2 <a class="header-anchor" href="#多活模式2" aria-label="Permalink to &quot;多活模式2&quot;">​</a></h2><p><img src="'+o+'" alt=""></p><h2 id="多活模式3" tabindex="-1">多活模式3 <a class="header-anchor" href="#多活模式3" aria-label="Permalink to &quot;多活模式3&quot;">​</a></h2><p><strong>federation 插件是一个不需要构建 cluster ，而在 brokers 之间传输消息的高性能插件</strong>，federation 插件可以在 brokers 或者 cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用不同版本的 rabbitMQ 和 erlang。</p><p>**federation 插件使用 AMQP 协议通信，可以接受不连续的传输。**federation 不是建立在集群上的，而是建立在单个节点上的，如图上黄色的 rabbit node 3 可以与绿色的 node1、node2、node3 中的任意一个利用 federation 插件进行数据同步</p>',9),n=[s];function d(b,_,l,c,h,p){return e(),t("div",null,n)}const u=a(i,[["render",d]]);export{m as __pageData,u as default};
