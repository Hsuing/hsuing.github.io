import{_ as s,o as a,c as o,R as e}from"./chunks/framework.zUbWieqp.js";const q=JSON.parse('{"title":"1. PromQL函数","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/Monitor/Prometheus/4-promql_function.md","filePath":"guide/Linux/Monitor/Prometheus/4-promql_function.md","lastUpdated":1737022476000}'),n={name:"guide/Linux/Monitor/Prometheus/4-promql_function.md"},t=e(`<h1 id="_1-promql函数" tabindex="-1">1. PromQL函数 <a class="header-anchor" href="#_1-promql函数" aria-label="Permalink to &quot;1. PromQL函数&quot;">​</a></h1><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：<code>year(v=vector(time()) instant-vector)</code>。其中参数 <code>v</code> 是一个瞬时向量，如果不提供该参数，将使用默认值 <code>vector(time())</code>。instant-vector 表示参数类型。</p><h2 id="_1-1-内置函数" tabindex="-1">1.1 内置函数 <a class="header-anchor" href="#_1-1-内置函数" aria-label="Permalink to &quot;1.1 内置函数&quot;">​</a></h2><p><a href="https://prometheus.io/docs/prometheus/2.55/querying/functions/" target="_blank" rel="noreferrer">Prometheus</a> 内置了一些函数来辅助计算，下面介绍一些典型的</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>abs()</td><td>绝对值</td></tr><tr><td>sqrt()</td><td>平方根</td></tr><tr><td>exp()</td><td>指数计算</td></tr><tr><td>ln()</td><td>自然对数</td></tr><tr><td>ceil()</td><td>向上取整</td></tr><tr><td>floor()</td><td>向下取整</td></tr><tr><td>round()</td><td>四舍五入取整</td></tr><tr><td>delta()</td><td>计算区间向量里每一个时序第一个和最后一个的差值</td></tr><tr><td>sort()</td><td>排序</td></tr><tr><td>time()</td><td>时间</td></tr></tbody></table><h3 id="_1-abs" tabindex="-1">1.abs <a class="header-anchor" href="#_1-abs" aria-label="Permalink to &quot;1.abs&quot;">​</a></h3><p><code>abs(v instant-vector)</code> 返回输入向量的所有样本的绝对值</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">abs(process_open_fds</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;alertmanager&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-20</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">abs(process_open_fds</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;alertmanager&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-20</span><span style="color:#24292E;">)</span></span></code></pre></div><h3 id="_2-sqrt" tabindex="-1">2.sqrt <a class="header-anchor" href="#_2-sqrt" aria-label="Permalink to &quot;2.sqrt&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">sqrt(process_open_fds</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;alertmanager&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">+37</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">sqrt(process_open_fds</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;alertmanager&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;"> </span><span style="color:#032F62;">+37</span><span style="color:#24292E;">)</span></span></code></pre></div><h3 id="_3-round" tabindex="-1">3.round <a class="header-anchor" href="#_3-round" aria-label="Permalink to &quot;3.round&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">round(vector(7.8))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">round(vector(7.8))</span></span></code></pre></div><h3 id="_4-time" tabindex="-1">4.time <a class="header-anchor" href="#_4-time" aria-label="Permalink to &quot;4.time&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">time</span><span style="color:#E1E4E8;">()-process_start_time_seconds</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">time</span><span style="color:#24292E;">()-process_start_time_seconds</span></span></code></pre></div><h3 id="_5-absent" tabindex="-1">5.absent <a class="header-anchor" href="#_5-absent" aria-label="Permalink to &quot;5.absent&quot;">​</a></h3><p><code>absent(v instant-vector)</code>，如果传递给它的向量参数具有样本数据，则返回空向量；如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列，且样本值为1。</p><p>监控度量指标时，如果获取到的样本数据是空的， 使用 absent 方法对告警是非常有用的。例如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># 这里提供的向量有样本数据</span></span>
<span class="line"><span style="color:#B392F0;">absent(http_requests_total</span><span style="color:#E1E4E8;">{method=</span><span style="color:#B392F0;">&quot;get&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">)  =</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> no </span></span>
<span class="line"><span style="color:#B392F0;">dataabsent(sum(http_requests_total</span><span style="color:#E1E4E8;">{method=</span><span style="color:#B392F0;">&quot;get&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">))  =</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> no data</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 由于不存在度量指标 nonexistent，所以 返回不带度量指标名称且带有标签的时间序列，且样本值为1</span></span>
<span class="line"><span style="color:#B392F0;">absent(nonexistent</span><span style="color:#E1E4E8;">{job=</span><span style="color:#B392F0;">&quot;myjob&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">)  =</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> {job</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;myjob&quot;}</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 正则匹配的 instance 不作为返回 labels 中的一部分</span></span>
<span class="line"><span style="color:#B392F0;">absent(nonexistent</span><span style="color:#E1E4E8;">{job=</span><span style="color:#B392F0;">&quot;myjob&quot;</span><span style="color:#B392F0;">,instance</span><span style="color:#E1E4E8;">=~</span><span style="color:#B392F0;">&quot;.*&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">)  =</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> {job</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;myjob&quot;}</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># sum 函数返回的时间序列不带有标签，且没有样本数据</span></span>
<span class="line"><span style="color:#B392F0;">absent(sum(nonexistent</span><span style="color:#E1E4E8;">{job=</span><span style="color:#B392F0;">&quot;myjob&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">))  =</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> {}  1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># 这里提供的向量有样本数据</span></span>
<span class="line"><span style="color:#6F42C1;">absent(http_requests_total</span><span style="color:#24292E;">{method=</span><span style="color:#6F42C1;">&quot;get&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">)  =</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> no </span></span>
<span class="line"><span style="color:#6F42C1;">dataabsent(sum(http_requests_total</span><span style="color:#24292E;">{method=</span><span style="color:#6F42C1;">&quot;get&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">))  =</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> no data</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 由于不存在度量指标 nonexistent，所以 返回不带度量指标名称且带有标签的时间序列，且样本值为1</span></span>
<span class="line"><span style="color:#6F42C1;">absent(nonexistent</span><span style="color:#24292E;">{job=</span><span style="color:#6F42C1;">&quot;myjob&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">)  =</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> {job</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;myjob&quot;}</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 正则匹配的 instance 不作为返回 labels 中的一部分</span></span>
<span class="line"><span style="color:#6F42C1;">absent(nonexistent</span><span style="color:#24292E;">{job=</span><span style="color:#6F42C1;">&quot;myjob&quot;</span><span style="color:#6F42C1;">,instance</span><span style="color:#24292E;">=~</span><span style="color:#6F42C1;">&quot;.*&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">)  =</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> {job</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;myjob&quot;}</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># sum 函数返回的时间序列不带有标签，且没有样本数据</span></span>
<span class="line"><span style="color:#6F42C1;">absent(sum(nonexistent</span><span style="color:#24292E;">{job=</span><span style="color:#6F42C1;">&quot;myjob&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">))  =</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> {}  1</span></span></code></pre></div><h3 id="_6-ceil" tabindex="-1">6.ceil() <a class="header-anchor" href="#_6-ceil" aria-label="Permalink to &quot;6.ceil()&quot;">​</a></h3><p><code>ceil(v instant-vector)</code> 将 v 中所有元素的样本值向上四舍五入到最接近的整数。例如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">ceil(node_load5</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;192.168.1.75:9100&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;"># 结果为 2.79ceil(node_load5{instance=&quot;192.168.1.75:9100&quot;}) # 结果为 3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">ceil(node_load5</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;192.168.1.75:9100&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">) </span><span style="color:#6A737D;"># 结果为 2.79ceil(node_load5{instance=&quot;192.168.1.75:9100&quot;}) # 结果为 3</span></span></code></pre></div><h3 id="_7-changes" tabindex="-1">7.changes() <a class="header-anchor" href="#_7-changes" aria-label="Permalink to &quot;7.changes()&quot;">​</a></h3><p><code>changes(v range-vector)</code> 输入一个区间向量， 返回这个区间向量内每个样本数据值变化的次数（瞬时向量）。例如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># 如果样本数据值没有发生变化，则返回结果为 1</span></span>
<span class="line"><span style="color:#B392F0;">changes(node_load5</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;192.168.1.75:9100&quot;</span><span style="color:#B392F0;">}[1m]</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;"># 结果为 1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># 如果样本数据值没有发生变化，则返回结果为 1</span></span>
<span class="line"><span style="color:#6F42C1;">changes(node_load5</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;192.168.1.75:9100&quot;</span><span style="color:#6F42C1;">}[1m]</span><span style="color:#24292E;">) </span><span style="color:#6A737D;"># 结果为 1</span></span></code></pre></div><h3 id="_8-clamp-max" tabindex="-1">8.clamp_max() <a class="header-anchor" href="#_8-clamp-max" aria-label="Permalink to &quot;8.clamp_max()&quot;">​</a></h3><p><code>clamp_max(v instant-vector, max scalar)</code> 函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">node_load5</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;192.168.1.75:9100&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># 结果为 </span></span>
<span class="line"><span style="color:#B392F0;">2.79clamp_max(node_load5</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;192.168.1.75:9100&quot;</span><span style="color:#B392F0;">},</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;"># 结果为 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">node_load5</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;192.168.1.75:9100&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;"> </span><span style="color:#6A737D;"># 结果为 </span></span>
<span class="line"><span style="color:#6F42C1;">2.79clamp_max(node_load5</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;192.168.1.75:9100&quot;</span><span style="color:#6F42C1;">},</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">) </span><span style="color:#6A737D;"># 结果为 2</span></span></code></pre></div><h3 id="_9-clamp-min" tabindex="-1">9.clamp_min() <a class="header-anchor" href="#_9-clamp-min" aria-label="Permalink to &quot;9.clamp_min()&quot;">​</a></h3><p><code>clamp_min(v instant-vector, min scalar)</code> 函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min，否则不变。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_load5{instance=&quot;192.168.1.75:9100&quot;} # 结果为 </span></span>
<span class="line"><span style="color:#e1e4e8;">2.79clamp_min(node_load5{instance=&quot;192.168.1.75:9100&quot;}, 3) # 结果为 3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_load5{instance=&quot;192.168.1.75:9100&quot;} # 结果为 </span></span>
<span class="line"><span style="color:#24292e;">2.79clamp_min(node_load5{instance=&quot;192.168.1.75:9100&quot;}, 3) # 结果为 3</span></span></code></pre></div><h3 id="_10-increase" tabindex="-1">10.increase() <a class="header-anchor" href="#_10-increase" aria-label="Permalink to &quot;10.increase()&quot;">​</a></h3><p><code>increase(v range-vector)</code> 函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">increase(http_requests_total{job=&quot;apiserver&quot;}[5m])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">increase(http_requests_total{job=&quot;apiserver&quot;}[5m])</span></span></code></pre></div><p><code>increase</code> 的返回值类型只能是计数器类型，主要作用是增加图表和数据的可读性。使用 <code>rate</code> 函数记录规则的使用率，以便持续跟踪数据样本值的变化。</p><h3 id="_11-irate" tabindex="-1">11.irate() <a class="header-anchor" href="#_11-irate" aria-label="Permalink to &quot;11.irate()&quot;">​</a></h3><p><code>irate(v range-vector)</code> 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">irate(http_requests_total{job=&quot;api-server&quot;}[5m])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">irate(http_requests_total{job=&quot;api-server&quot;}[5m])</span></span></code></pre></div><p>irate 只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 irate 函数时，速率的简短变化会重置 <code>FOR</code> 语句，形成的图形有很多波峰，难以阅读。</p><blockquote><p>当将 <code>irate()</code> 函数与<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators" target="_blank" rel="noreferrer">聚合运算符</a>（例如 <code>sum()</code>）或随时间聚合的函数（任何以 <code>_over_time</code> 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。</p></blockquote><h3 id="_12-rate" tabindex="-1">12.rate() <a class="header-anchor" href="#_12-rate" aria-label="Permalink to &quot;12.rate()&quot;">​</a></h3><p><code>rate(v range-vector)</code> 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果<strong>不带有度量指标</strong>，只有标签列表。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">rate(http_requests_total[5m])结果：</span></span>
<span class="line"><span style="color:#e1e4e8;">{code=&quot;200&quot;,handler=&quot;label_values&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;} 0</span></span>
<span class="line"><span style="color:#e1e4e8;">{code=&quot;200&quot;,handler=&quot;query_range&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}  0</span></span>
<span class="line"><span style="color:#e1e4e8;">{code=&quot;200&quot;,handler=&quot;prometheus&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}   0.2</span></span>
<span class="line"><span style="color:#e1e4e8;">...</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">rate(http_requests_total[5m])结果：</span></span>
<span class="line"><span style="color:#24292e;">{code=&quot;200&quot;,handler=&quot;label_values&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;} 0</span></span>
<span class="line"><span style="color:#24292e;">{code=&quot;200&quot;,handler=&quot;query_range&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}  0</span></span>
<span class="line"><span style="color:#24292e;">{code=&quot;200&quot;,handler=&quot;prometheus&quot;,instance=&quot;120.77.65.193:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;}   0.2</span></span>
<span class="line"><span style="color:#24292e;">...</span></span></code></pre></div><p>rate() 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。</p><blockquote><p>当将 <code>rate()</code> 函数与<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators" target="_blank" rel="noreferrer">聚合运算符</a>（例如 <code>sum()</code>）或随时间聚合的函数（任何以 <code>_over_time</code> 结尾的函数）一起使用时，必须先执行 rate 函数，然后再进行聚合操作，否则当采样目标重新启动时 rate() 无法检测到计数器是否被重置。</p></blockquote><h3 id="_13-label-join" tabindex="-1">13.label_join() <a class="header-anchor" href="#_13-label-join" aria-label="Permalink to &quot;13.label_join()&quot;">​</a></h3><p><code>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</code> 函数可以将时间序列 v 中多个标签 <code>src_label</code> 的值，通过 <code>separator</code> 作为连接符写入到一个新的标签 <code>dst_label</code> 中。可以有多个 src_label 标签。</p><p>例如，以下表达式返回的时间序列多了一个 <code>foo</code> 标签，标签值为 <code>etcd,etcd-k8s</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">up</span><span style="color:#E1E4E8;">{endpoint=</span><span style="color:#B392F0;">&quot;api&quot;</span><span style="color:#B392F0;">,instance</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;192.168.123.248:2379&quot;</span><span style="color:#B392F0;">,job</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;etcd&quot;</span><span style="color:#B392F0;">,namespace</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;monitoring&quot;</span><span style="color:#B392F0;">,service</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;etcd-k8s&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;">=&gt; </span><span style="color:#9ECBFF;">up{endpoint=&quot;api&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;}</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">label_join(up</span><span style="color:#E1E4E8;">{endpoint=</span><span style="color:#B392F0;">&quot;api&quot;</span><span style="color:#B392F0;">,instance</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;192.168.123.248:2379&quot;</span><span style="color:#B392F0;">,job</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;etcd&quot;</span><span style="color:#B392F0;">,namespace</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;monitoring&quot;</span><span style="color:#B392F0;">,service</span><span style="color:#E1E4E8;">=</span><span style="color:#B392F0;">&quot;etcd-k8s&quot;</span><span style="color:#B392F0;">},</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;foo&quot;,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;,&quot;,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;job&quot;,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;service&quot;</span><span style="color:#E1E4E8;">)=</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> up{endpoint</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;api&quot;,foo=&quot;etcd,etcd-k8s&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;}</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">up</span><span style="color:#24292E;">{endpoint=</span><span style="color:#6F42C1;">&quot;api&quot;</span><span style="color:#6F42C1;">,instance</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;192.168.123.248:2379&quot;</span><span style="color:#6F42C1;">,job</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;etcd&quot;</span><span style="color:#6F42C1;">,namespace</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;monitoring&quot;</span><span style="color:#6F42C1;">,service</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;etcd-k8s&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;">=&gt; </span><span style="color:#032F62;">up{endpoint=&quot;api&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;}</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">label_join(up</span><span style="color:#24292E;">{endpoint=</span><span style="color:#6F42C1;">&quot;api&quot;</span><span style="color:#6F42C1;">,instance</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;192.168.123.248:2379&quot;</span><span style="color:#6F42C1;">,job</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;etcd&quot;</span><span style="color:#6F42C1;">,namespace</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;monitoring&quot;</span><span style="color:#6F42C1;">,service</span><span style="color:#24292E;">=</span><span style="color:#6F42C1;">&quot;etcd-k8s&quot;</span><span style="color:#6F42C1;">},</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;foo&quot;,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;,&quot;,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;job&quot;,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;service&quot;</span><span style="color:#24292E;">)=</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> up{endpoint</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;api&quot;,foo=&quot;etcd,etcd-k8s&quot;,instance=&quot;192.168.123.248:2379&quot;,job=&quot;etcd&quot;,namespace=&quot;monitoring&quot;,service=&quot;etcd-k8s&quot;}</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">1</span></span></code></pre></div><h3 id="_14-label-replace" tabindex="-1">14.label_replace() <a class="header-anchor" href="#_14-label-replace" aria-label="Permalink to &quot;14.label_replace()&quot;">​</a></h3><p>为了能够让客户端的图标更具有可读性，可以通过 <code>label_replace</code> 函数为时间序列添加额外的标签。label_replace 的具体参数如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">label_replace(v</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">instant-vector,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">dst_label</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">string,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">replacement</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">string,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">src_label</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">string,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">regex</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">string</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">label_replace(v</span><span style="color:#24292E;"> </span><span style="color:#032F62;">instant-vector,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">dst_label</span><span style="color:#24292E;"> </span><span style="color:#032F62;">string,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">replacement</span><span style="color:#24292E;"> </span><span style="color:#032F62;">string,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">src_label</span><span style="color:#24292E;"> </span><span style="color:#032F62;">string,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">regex</span><span style="color:#24292E;"> </span><span style="color:#032F62;">string</span><span style="color:#24292E;">)</span></span></code></pre></div><p>该函数会依次对 v 中的每一条时间序列进行处理，通过 <code>regex</code> 匹配 src_label 的值，并将匹配部分 <code>relacement</code> 写入到 dst_label 标签中。如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,  &quot;(.*):.*&quot;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,  &quot;(.*):.*&quot;)</span></span></code></pre></div><p>函数处理后，时间序列将包含一个 <code>host</code> 标签，host 标签的值为 Exporter 实例的 IP 地址：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">up{host=&quot;localhost&quot;,instance=&quot;localhost:8080&quot;,job=&quot;cadvisor&quot;}   1</span></span>
<span class="line"><span style="color:#e1e4e8;">up{host=&quot;localhost&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;}   1</span></span>
<span class="line"><span style="color:#e1e4e8;">up{host=&quot;localhost&quot;,instance=&quot;localhost:9100&quot;,job=&quot;node&quot;}   1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">up{host=&quot;localhost&quot;,instance=&quot;localhost:8080&quot;,job=&quot;cadvisor&quot;}   1</span></span>
<span class="line"><span style="color:#24292e;">up{host=&quot;localhost&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;}   1</span></span>
<span class="line"><span style="color:#24292e;">up{host=&quot;localhost&quot;,instance=&quot;localhost:9100&quot;,job=&quot;node&quot;}   1</span></span></code></pre></div><h3 id="_15-sort" tabindex="-1">15.sort() <a class="header-anchor" href="#_15-sort" aria-label="Permalink to &quot;15.sort()&quot;">​</a></h3><p><code>sort(v instant-vector)</code> 函数对向量按元素的值进行升序排序，返回结果：key: value = 度量指标：样本值[升序排列]。</p><h3 id="_16-sort-desc" tabindex="-1">16.sort_desc() <a class="header-anchor" href="#_16-sort-desc" aria-label="Permalink to &quot;16.sort_desc()&quot;">​</a></h3><p><code>sort(v instant-vector)</code> 函数对向量按元素的值进行降序排序，返回结果：key: value = 度量指标：样本值[降序排列]。</p><h2 id="_1-2-基于时间聚合" tabindex="-1">1.2 基于时间聚合 <a class="header-anchor" href="#_1-2-基于时间聚合" aria-label="Permalink to &quot;1.2 基于时间聚合&quot;">​</a></h2><table><thead><tr><th>avg_over_time(range-vector)</th><th>区间向量内每个指标的平均值</th></tr></thead><tbody><tr><td>min_over_time(range-vector)</td><td>区间向量内每个指标的最小值</td></tr><tr><td>max_over_time(range-vector)</td><td>区间向量内每个指标的最大值</td></tr><tr><td>sum_over_time(range-vector)</td><td>区间向量内每个指标的求和</td></tr><tr><td>count_over_time(range-vector)</td><td>区间向量内每个指标的样本数据个数</td></tr><tr><td>quantile_over_time(scalar, range-vector)</td><td>区间向量内每个指标的样本数据值分位数</td></tr><tr><td>stddev_over_time(range-vector)</td><td>区间向量内每个指标的总体标准差</td></tr><tr><td>stdvar_over_time(range-vector)</td><td>区间向量内每个指标的总体标准方差</td></tr></tbody></table><h2 id="_1-3-基于标签聚合" tabindex="-1">1.3 基于标签聚合 <a class="header-anchor" href="#_1-3-基于标签聚合" aria-label="Permalink to &quot;1.3 基于标签聚合&quot;">​</a></h2><p>使用PromQL查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过up指标可以获取到当前所有运行的Exporter实例以及其状态：</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501081812174.png" alt="image-20250108181255157"></p><p>可视化工具渲染图标时可能根据，instance和job的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过label_replace标签为时间序列添加额外的标签。label_replace的具体语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">label_replace(__input_vector__, &quot;dst_label&quot;, &quot;__replacement__&quot;, &quot;src_label&quot;, &quot;__regex__&quot;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">label_replace(__input_vector__, &quot;dst_label&quot;, &quot;__replacement__&quot;, &quot;src_label&quot;, &quot;__regex__&quot;)</span></span></code></pre></div><p>该函数会依次对v中的每一条时间序列进行处理，通过regex匹配src_label的值，并将匹配部分relacement写入到dst_label标签中。如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">label_replace(up,&quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,&quot;(.*)&quot;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">label_replace(up,&quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,&quot;(.*)&quot;)</span></span></code></pre></div><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501081820117.png" alt="image-20250108182016116"></p><p>执行之后</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501081820681.png" alt="image-20250108182051001"></p><h2 id="_1-4-基于counter指标" tabindex="-1">1.4 基于counter指标 <a class="header-anchor" href="#_1-4-基于counter指标" aria-label="Permalink to &quot;1.4 基于counter指标&quot;">​</a></h2><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501081748436.png" alt="image-20250108174802113"></p><p>通过增长率表示样本的变化情况</p><p>increase(vrange-vector)函数是PromQL中提供的众多内置函数之一。其中参数v是一个区间向量，increase函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式Counter类型指标的增长率：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">increase(node_load1[2m]) / 120</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">increase(node_load1[2m]) / 120</span></span></code></pre></div><p>这里通过node_cpu[2m]获取时间序列最近两分钟的所有样本，increase计算出最近两分钟的增长量，最后除以时间120秒得到node_cpu样本在最近两分钟的平均增长率。并目这个值也近似于主机节点最近两分钟内的平均CPU使用率。</p><p>除了使用increase函数以外，PromQL中还直接内置了rate(Vrange-vector)函数，rate函数可以直接计算区间向量v在时间窗口内平均增长速率。因此，通过以下表达式可以得到与increase函数相同的结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">rate(node_load1[2m])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">rate(node_load1[2m])</span></span></code></pre></div><p>需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入&quot;长尾问题&quot;当中，其无法反应在时间窗口内样本数据的突发变化。例如，对于主机而言在2分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用100%的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</p><p>为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(vrange-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的&quot;长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">irate(node_load1[2m])</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">irate(node_load1[2m])</span></span></code></pre></div><p>长期还是建议使用rate函数</p><h2 id="_1-5-基于gauge指标" tabindex="-1">1.5 基于Gauge指标 <a class="header-anchor" href="#_1-5-基于gauge指标" aria-label="Permalink to &quot;1.5 基于Gauge指标&quot;">​</a></h2><p>比如有些某些业务增长，存储空间的增长速率提升了高几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。那么还有没有更好的方法？</p><p>PromQL中内置的predict_linear(vrange-vector,tscalar)函数可以帮助系统管理员更好的处理此类情况，predict_linear函数可以预测时间序列v在t秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于1小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满，可以使用如下表达式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">predict_linear(node_filesystem_avail_bytes{fstype!~&quot;tmpfs&quot;}[1h],24 * 3600)&lt;0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">predict_linear(node_filesystem_avail_bytes{fstype!~&quot;tmpfs&quot;}[1h],24 * 3600)&lt;0</span></span></code></pre></div><p>node_export表达式</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">node_filesystem_avail_bytes</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">*</span><span style="color:#9ECBFF;">100</span><span style="color:#E1E4E8;">)/ node_filesystem_size_bytes</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">10 and ON (</span><span style="color:#B392F0;">instance,device,mountpoint</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">predict_linear(node_filesystem_avail_bytes</span><span style="color:#E1E4E8;">{fstype!~</span><span style="color:#B392F0;">&quot;tmpfs&quot;</span><span style="color:#B392F0;">}[1h],24</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3600</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">0 and on (</span><span style="color:#B392F0;">instance,device,</span></span>
<span class="line"><span style="color:#B392F0;">mountpoint</span><span style="color:#E1E4E8;">) node_filesystem_readonly ==0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">(</span><span style="color:#6F42C1;">node_filesystem_avail_bytes</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">*</span><span style="color:#032F62;">100</span><span style="color:#24292E;">)/ node_filesystem_size_bytes</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">10 and ON (</span><span style="color:#6F42C1;">instance,device,mountpoint</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6F42C1;">predict_linear(node_filesystem_avail_bytes</span><span style="color:#24292E;">{fstype!~</span><span style="color:#6F42C1;">&quot;tmpfs&quot;</span><span style="color:#6F42C1;">}[1h],24</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3600</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">0 and on (</span><span style="color:#6F42C1;">instance,device,</span></span>
<span class="line"><span style="color:#6F42C1;">mountpoint</span><span style="color:#24292E;">) node_filesystem_readonly ==0</span></span></code></pre></div><h1 id="_2-案例" tabindex="-1">2.案例 <a class="header-anchor" href="#_2-案例" aria-label="Permalink to &quot;2.案例&quot;">​</a></h1><p>下面的示例中我们看到另外一种写法<code>[15m:1m]</code>，这表示取15分钟的一个范围数据，并按每分钟分为一段，最后分为15段。在15段中取一个最小值。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">- </span><span style="color:#85E89D;">alert</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">KubernetesPodNotHealthy</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">expr</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">min_over_time(sum by (namespace, pod) (kube_pod_status_phase{phase=~&quot;Pending|Unknown|Failed&quot;})[15m:1m]) &gt; 0</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">for</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">0m</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">labels</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">severity</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">critical</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#85E89D;">annotations</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">summary</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">Kubernetes Pod not healthy (instance {{ $labels.instance }})</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#85E89D;">description</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;Pod has been in a non-ready state for longer than 15 minutes.</span><span style="color:#79B8FF;">\\n</span><span style="color:#9ECBFF;">  VALUE = {{ $value }}</span><span style="color:#79B8FF;">\\n</span><span style="color:#9ECBFF;">  LABELS = {{ $labels }}&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">- </span><span style="color:#22863A;">alert</span><span style="color:#24292E;">: </span><span style="color:#032F62;">KubernetesPodNotHealthy</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">expr</span><span style="color:#24292E;">: </span><span style="color:#032F62;">min_over_time(sum by (namespace, pod) (kube_pod_status_phase{phase=~&quot;Pending|Unknown|Failed&quot;})[15m:1m]) &gt; 0</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">for</span><span style="color:#24292E;">: </span><span style="color:#032F62;">0m</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">labels</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">severity</span><span style="color:#24292E;">: </span><span style="color:#032F62;">critical</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#22863A;">annotations</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">summary</span><span style="color:#24292E;">: </span><span style="color:#032F62;">Kubernetes Pod not healthy (instance {{ $labels.instance }})</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#22863A;">description</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;Pod has been in a non-ready state for longer than 15 minutes.</span><span style="color:#005CC5;">\\n</span><span style="color:#032F62;">  VALUE = {{ $value }}</span><span style="color:#005CC5;">\\n</span><span style="color:#032F62;">  LABELS = {{ $labels }}&quot;</span></span></code></pre></div>`,94),l=[t];function p(c,r,i,d,u,y){return a(),o("div",null,l)}const E=s(n,[["render",p]]);export{q as __pageData,E as default};
