import{_ as e,o as a,c as t,R as s}from"./chunks/framework.zUbWieqp.js";const b=JSON.parse('{"title":"1.介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/etcd/index.md","filePath":"guide/Database/etcd/index.md","lastUpdated":1703141608000}'),n={name:"guide/Database/etcd/index.md"},c=s(`<p><a href="https://www.cnblogs.com/yanshicheng/p/13436485.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/yanshicheng/p/13436485.html</a></p><p>官方文档：<a href="https://etcd.io/docs/v3.4/op-guide/maintenance/" target="_blank" rel="noreferrer">https://etcd.io/docs/v3.4/op-guide/maintenance/</a></p><h1 id="_1-介绍" tabindex="-1">1.介绍 <a class="header-anchor" href="#_1-介绍" aria-label="Permalink to &quot;1.介绍&quot;">​</a></h1><p>ETCD是一个分布式的、可靠的KV存储，基于 Go 语言实现</p><p>特点：</p><ul><li>完全复制：集群中的每个节点都可以使用完整的存档</li><li>高可用性：Etcd 可用于避免硬件的单点故障或网络问题</li><li>一致性：每次读取都会返回跨多主机的最新写入</li><li>简单：包括一个定义良好、面向用户的 API（gRPC）</li><li>安全：实现了带有可选的客户端证书身份验证的自动化 TLS</li><li>快速：每秒 10000 次写入的基准速度</li><li>可靠：使用 Raft 算法实现了存储的合理分布</li></ul><h2 id="_2-交互" tabindex="-1">2.交互 <a class="header-anchor" href="#_2-交互" aria-label="Permalink to &quot;2.交互&quot;">​</a></h2><p>etcd 对外通过 HTTP API 对外提供服务，这种方式方便测试（通过 curl 或者其他工具就能和 etcd 交互），也很容易集成到各种语言中（每个语言封装 HTTP API 实现自己的 client 就行</p><p><strong>提示： etcd为服务主文件，etcdctl为命令客户端</strong>，只有这两个配置</p><h1 id="_2-工作原理" tabindex="-1">2.工作原理 <a class="header-anchor" href="#_2-工作原理" aria-label="Permalink to &quot;2.工作原理&quot;">​</a></h1><h1 id="_3-工作目录" tabindex="-1">3.工作目录 <a class="header-anchor" href="#_3-工作目录" aria-label="Permalink to &quot;3.工作目录&quot;">​</a></h1><p>etcd会在默认的工作目录下生成两个子目录：snap和wal。两个目录的作用说明如下：</p><p>snap：用于存放快照数据。etcd为了防止WAL文件过多就会创建快照，snap用于存储etcd的快照数据状态</p><p>wal：用于存放预写式日志，其最大的作用是记录整个数据变化的全部历程。在etcd中，所有数据的修改在提交之前，都要写入WAL中。使用WAL进行数据的存储使得etcd拥有故障快速恢复和数据回滚两个重要的功能</p><h1 id="_3-注意" tabindex="-1">3.注意 <a class="header-anchor" href="#_3-注意" aria-label="Permalink to &quot;3.注意&quot;">​</a></h1><p>初始化的时候就需要确定</p><p>\\1. --auto-compaction-retention</p><p>由于ETCD数据存储多版本数据，随着写入的主键增加历史版本需要定时清理，　默认的历史数据是不会清理的，数据达到2G就不能写入，必须要清理压缩历史数据才能继续写入；</p><p>所以根据业务需求，在上生产环境之前就提前确定，历史数据多长时间压缩一次；　我们的生产环境现在升级后是默认一小时压缩一次数据。这样可以极大的保证集群稳定，减少内存和磁盘占用</p><p>2.--max-request-bytes</p><p>etcd Raft消息最大字节数，ETCD默认该值为1.5M; 但是很多业务场景发现同步数据的时候1.5M完全没法满足要求，所以提前确定初始值很重要；　由于1.5M导致我们线上的业务无法写入元数据的问题，</p><p>我们紧急升级之后把该值修改为默认32M,但是官方推荐的是10M，大家可以根据业务情况自己调整</p><p>3.--quota-backend-bytes</p><p>ETCDdb数据大小，默认是２G,当数据达到２G的时候就不允许写入，必须对历史数据进行压缩才能继续写入；　参加1里面说的，我们启动的时候就应该提前确定大小，官方推荐是8G,这里我们也使用8G的配置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">＃启动命令</span></span>
<span class="line"><span style="color:#e1e4e8;">/usr/bin/etcd --auto-compaction-retention &#39;1&#39; --max-request-bytes &#39;33554432&#39; --quota-backend-bytes &#39;8589934592&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">＃启动命令</span></span>
<span class="line"><span style="color:#24292e;">/usr/bin/etcd --auto-compaction-retention &#39;1&#39; --max-request-bytes &#39;33554432&#39; --quota-backend-bytes &#39;8589934592&#39;</span></span></code></pre></div><p>注：删除操作前记得对etcd进行快照的备份，etcd的配额大小可以进行配置，需要到etcd.service文件中添加如下参数： ExecStart=/usr/bin/etcd --quota-backend-bytes ‘8589934592’(根据自己实际需求来改</p>`,26),o=[c];function p(i,l,r,d,h,u){return a(),t("div",null,o)}const m=e(n,[["render",p]]);export{b as __pageData,m as default};
