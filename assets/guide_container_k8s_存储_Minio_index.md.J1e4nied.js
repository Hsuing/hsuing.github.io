import{_ as e,o as i,c as a,R as t}from"./chunks/framework.zUbWieqp.js";const g=JSON.parse('{"title":"1. 介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/存储/Minio/index.md","filePath":"guide/container/k8s/存储/Minio/index.md","lastUpdated":1721309786000}'),r={name:"guide/container/k8s/存储/Minio/index.md"},n=t('<h1 id="_1-介绍" tabindex="-1">1. 介绍 <a class="header-anchor" href="#_1-介绍" aria-label="Permalink to &quot;1. 介绍&quot;">​</a></h1><p>MinIO 作为高性能对象存储，是与 Amazon S3 云存储服务兼容的 API，使用 MinIO 为机器学习、分析和应用程序数据工作负载构建高性能基础架构。</p><p>对于 Kubernetes 环境，使用 MinIO Operator 实现 MinIO 部署和租户的创建</p><p>MinIO Operator 是一个工具，该工具扩展了 k8s 的 api，可以通过 minio operator 在公有云或私有云 上来部署 MinIO Tenants。</p><p>MinIO 的不同之处在于，它从一开始就被设计为私有/混合云对象存储。因MinIO 是专门为服务于对象而构建的，所以单层架构可以实现所有必要的功能。它是一个同时具有高性能、可扩展性和轻量级的云原生对象服务器</p><p>架构图：</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407151736485.png" alt=""></p><h2 id="_1-1-特点" tabindex="-1">1.1 特点 <a class="header-anchor" href="#_1-1-特点" aria-label="Permalink to &quot;1.1 特点&quot;">​</a></h2><h3 id="纠删码" tabindex="-1">纠删码 <a class="header-anchor" href="#纠删码" aria-label="Permalink to &quot;纠删码&quot;">​</a></h3><p>MinIO 使用以汇编代码编写的每个对象内联擦除编码来保护数据，以提供尽可能高的性能。MinIO 使用 Reed-Solomon 代码将对象条带化为具有用户可配置冗余级别的数据和奇偶校验块。MinIO 的 Erasure Coding 在对象级别执行修复，可以独立修复多个对象。</p><p>在 N/2 的最大奇偶校验下，MinIO 的实现可以确保在部署中仅使用 ((N/2)+1) 个操作驱动器进行不间断的读写操作。例如，在 12 个驱动器的设置中，MinIO 将对象分片到 6 个数据和 6 个奇偶校验驱动器，并且可以可靠地写入新对象或重建现有对象，而部署中仅剩下 7 个驱动器。详细介绍可以参考 <a href="https://docs.min.io/minio/baremetal/concepts/erasure-coding.html" target="_blank" rel="noreferrer">https://docs.min.io/minio/baremetal/concepts/erasure-coding.html</a></p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407161715499.png" alt=""></p><h3 id="bitrot-保护" tabindex="-1">Bitrot 保护 <a class="header-anchor" href="#bitrot-保护" aria-label="Permalink to &quot;Bitrot 保护&quot;">​</a></h3><p>静默数据损坏或 bitrot 是磁盘驱动器面临的严重问题，导致数据在用户不知情的情况下损坏。原因是多方面的（驱动器老化、电流峰值、磁盘固件中的错误、幻像写入、读取/写入方向错误、驱动程序错误、意外覆盖），但结果是一样的 - 数据受损。</p><p>MinIO 对 HighwayHash 算法的优化实现确保它永远不会读取损坏的数据 - 它即时捕获和修复损坏的对象。通过在 READ 上计算散列并在从应用程序、网络到内存/驱动器的 WRITE 上对其进行验证来确保端到端的完整性。该实现专为速度而设计，可以在 Intel CPU 的单核上实现超过 10 GB/秒的散列速度。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407161717124.png" alt="image-20210831171039426"></p><h3 id="身份管理" tabindex="-1">身份管理 <a class="header-anchor" href="#身份管理" aria-label="Permalink to &quot;身份管理&quot;">​</a></h3><p>MinIO 支持与 OpenID 连接兼容提供商以及关键的外部 IDP 供应商集成。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407161717180.png" alt="image-20210831171212298"></p><h3 id="数据加密" tabindex="-1">数据加密 <a class="header-anchor" href="#数据加密" aria-label="Permalink to &quot;数据加密&quot;">​</a></h3><p>MinIO 支持多种复杂的服务器端加密方案来保护数据——无论数据在哪里。MinIO 的方法以可忽略的性能开销确保机密性、完整性和真实性。使用 AES-256-GCM、ChaCha20-Poly1305 和 AES-CBC 支持服务器端和客户端加密。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407161717526.png" alt="image-20210831171304852"></p><h3 id="连续复制" tabindex="-1">连续复制 <a class="header-anchor" href="#连续复制" aria-label="Permalink to &quot;连续复制&quot;">​</a></h3><p>MinIO 的持续复制专为大规模、跨数据中心部署而设计。通过利用 Lambda 计算通知和对象元数据，它可以高效快速地计算增量。Lambda 通知确保更改立即传播，而不是传统的批处理模式。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202407161718324.png" alt="image-20210831171444574"></p><h3 id="数据保护" tabindex="-1">数据保护 <a class="header-anchor" href="#数据保护" aria-label="Permalink to &quot;数据保护&quot;">​</a></h3><ul><li>分布式 Minio 采用纠删码来防范多个节点宕机和位衰减。</li><li>分布式 Minio 至少需要 4 个节点（4台服务器），使用分布式 Minio 就 自动引入了纠删码功能。</li><li>纠删码是一种恢复丢失和损坏数据的数学算法， Minio 采用 Reed-Solomon code 将对象拆分成 N/2 数据和 N/2 奇偶校验块。 这就意味着如果是 12 块盘，一个对象会被分成 6 个数据块、6 个奇偶校验块，你可以丢失任意 6 块盘（不管其是存放的数据块还是奇偶校验块），你仍可以从剩下的盘中的数据进行恢复。</li><li>纠删码的工作原理和 RAID 或者复制不同，像 RAID6 可以在损失两块盘的情况下不丢数据，而 Minio 纠删码可以在丢失一半的盘的情况下，仍可以保证数据安全。 而且 Minio 纠删码是作用在对象级别，可以一次恢复一个对象，而RAID 是作用在卷级别，数据恢复时间很长。 Minio 对每个对象单独编码，存储服务一经部署，通常情况下是不需要更换硬盘或者修复。Minio 纠删码的设计目标是为了性能和尽可能的使用硬件加速。</li><li>位衰减又被称为数据腐化 Data Rot、无声数据损坏 Silent Data Corruption ，是目前硬盘数据的一种严重数据丢失问题。硬盘上的数据可能会神不知鬼不觉就损坏了，也没有什么错误日志。正所谓明枪易躲，暗箭难防，这种背地里犯的错比硬盘直接故障还危险。 所以 Minio 纠删码采用了高速 HighwayHash 基于哈希的校验和来防范位衰减。</li></ul><h3 id="一致性" tabindex="-1">一致性 <a class="header-anchor" href="#一致性" aria-label="Permalink to &quot;一致性&quot;">​</a></h3><p>Minio 在分布式和单机模式下，所有读写操作都严格遵守 read-after-write 一致性模型</p><h3 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h3><ul><li>分布式 Minio 单租户存在最少 4 个盘最多 16 个盘的限制（受限于纠删码）。这种限制确保了 Minio 的简洁，同时仍拥有伸缩性。如果你需要搭建一个多租户环境，你可以轻松的使用编排工具（Kubernetes）来管理多个Minio实例。</li><li>注意，只要遵守分布式 Minio 的限制，你可以组合不同的节点和每个节点几块盘。比如，你可以使用 2 个节点，每个节点 4 块盘，也可以使用 4 个节点，每个节点两块盘，诸如此类。</li></ul><p>文档：</p><p><a href="https://helm.sh/" target="_blank" rel="noreferrer">https://helm.sh/</a></p><p><a href="https://helm.sh/docs/intro/install/" target="_blank" rel="noreferrer">https://helm.sh/docs/intro/install/</a></p><p><a href="https://k3s.io/" target="_blank" rel="noreferrer">https://k3s.io/</a></p><p><a href="https://krew.sigs.k8s.io/docs/user-guide/quickstart/" target="_blank" rel="noreferrer">https://krew.sigs.k8s.io/docs/user-guide/quickstart/</a></p><p><a href="https://kubernetes.io/docs/concepts/overview/" target="_blank" rel="noreferrer">https://kubernetes.io/docs/concepts/overview/</a></p><p><a href="https://kubernetes.io/docs/tasks/tools/" target="_blank" rel="noreferrer">https://kubernetes.io/docs/tasks/tools/</a></p><p><a href="https://min.io/docs/minio/kubernetes/upstream/index.html" target="_blank" rel="noreferrer">https://min.io/docs/minio/kubernetes/upstream/index.html</a></p><p><a href="https://min.io/docs/minio/linux/reference/minio-mc.html?ref=docs-redirect" target="_blank" rel="noreferrer">https://min.io/docs/minio/linux/reference/minio-mc.html?ref=docs-redirect</a></p><p><a href="https://github.com/minio/minio/tree/master/helm/minio" target="_blank" rel="noreferrer">https://github.com/minio/minio/tree/master/helm/minio</a></p><p><a href="https://www.bboy.app/2023/09/19/%E4%BD%BF%E7%94%A8prometheus%E5%92%8Cmimir%E5%81%9Ak8s%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7/" target="_blank" rel="noreferrer">https://www.bboy.app/2023/09/19/使用prometheus和mimir做k8s多集群监控/</a></p>',42),o=[n];function s(h,l,p,c,m,d){return i(),a("div",null,o)}const b=e(r,[["render",s]]);export{g as __pageData,b as default};
