import{_ as l,o as i,c as a,R as e}from"./chunks/framework.zUbWieqp.js";const t="/assets/jg.q0LV29hI.jpg",d=JSON.parse('{"title":"3.简介","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/rabbitmq/0-架构.md","filePath":"guide/Database/rabbitmq/0-架构.md","lastUpdated":1713406156000}'),r={name:"guide/Database/rabbitmq/0-架构.md"},b=e('<h2 id="_1-官方的简单架构图" tabindex="-1">1.官方的简单架构图 <a class="header-anchor" href="#_1-官方的简单架构图" aria-label="Permalink to &quot;1.官方的简单架构图&quot;">​</a></h2><p>Publisher - 生产者：发布消息到RabbitMQ中的Exchange</p><p>Consumer - 消费者：监听RabbitMQ中的Queue中的消息</p><p>Exchange - 交换机：和生产者建立连接并接收生产者的消息</p><p>Queue - 队列：Exchange会将消息分发到指定的Queue，Queue和消费者进行交互</p><p>Routes - 路由：交换机以什么样的策略将消息发布到Queue</p><h2 id="_2-rabbitmq的完整架构图" tabindex="-1">2.RabbitMQ的完整架构图 <a class="header-anchor" href="#_2-rabbitmq的完整架构图" aria-label="Permalink to &quot;2.RabbitMQ的完整架构图&quot;">​</a></h2><p><img src="'+t+'" alt=""></p><p><strong>核心概念:</strong></p><ul><li>Server :又称Broker接受客户端的连接，实现AMQP实体服务。安装rabbitmq-server</li><li>Connection :连接,应用程序与Broker的网络连接TCP/IP/三次握手和四次挥手</li><li>Channel :网络信道，几乎所有的操作都在Channel中进行，Channe|是进行消息读写的通道，客户端可以建立对各 Channel,每个Channel代表-个会话任务 。</li><li>Message :消息: 服务与应用程序之间传送的数据，Properties和body组成， Properties可是对消息进行修饰， 比 如消息的优先级，延迟等高级特性，Body则就 是消息体的内容。 Virtual Host虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若干个Exhange和 Queueu,同-个虚拟主机里面不能有相同名字的Exchange</li><li>Exchange :交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)</li><li>Bindings : Exchange和Queue之间的虚拟连接，binding中可以保护多 个routing key.</li><li>Routing key :是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。</li><li>Queue :队列:也成为Message Queue,消息队列，保存消息并将它们转发给消费者</li></ul><h1 id="_3-简介" tabindex="-1">3.简介 <a class="header-anchor" href="#_3-简介" aria-label="Permalink to &quot;3.简介&quot;">​</a></h1><p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p><h2 id="rabbitmq-特点" tabindex="-1">RabbitMQ 特点 <a class="header-anchor" href="#rabbitmq-特点" aria-label="Permalink to &quot;RabbitMQ 特点&quot;">​</a></h2><ul><li><p>可靠性</p></li><li><p>灵活的路由</p></li><li><p>扩展性</p></li><li><p>高可用性</p></li><li><p>多种协议</p></li><li><p>多语言客户端</p></li><li><p>管理界面</p></li><li><p>插件机制</p></li><li><p>支持高性能的序列化转换, 异步化发送消息</p></li><li><p>支持消息生产实例与消费实例的链接池化缓存化, 提升性能</p></li><li><p>支持可靠性投递消息, 保障消息100%不丢失</p></li><li><p>支持消费端的幂等操作, 避免消费端重复消费的问题</p></li><li><p>支持迅速消息发送模式, 在一些日志收集/统计分析等需求下可以保证高性能, 高吞吐量</p></li><li><p>支持延迟消息模式, 消息可以延迟发送, 指定延迟时间, 用于某些延迟检查, 服务限流场景</p></li><li><p>支持事务消息, 器100%保障可靠性投递, 在金融行业单笔大金额操作时会有此类需求</p></li><li><p>支持顺序消息, 保证消息送达消费端的先后顺序</p></li><li><p>支持消息补偿, 重试, 以及快速定位异常/失败消息</p></li><li><p>支持集群消息负载均衡, 保障消息落到具体SET集群的负载均衡</p></li><li><p>支持消息路由策略, 指定某些消息路由到指定的SET集群</p></li></ul><h2 id="amqp-介绍" tabindex="-1">AMQP 介绍 <a class="header-anchor" href="#amqp-介绍" aria-label="Permalink to &quot;AMQP 介绍&quot;">​</a></h2><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制</p><h2 id="什么是消息队列" tabindex="-1">什么是消息队列 <a class="header-anchor" href="#什么是消息队列" aria-label="Permalink to &quot;什么是消息队列&quot;">​</a></h2><p>MQ 全称为Message Queue, 消息队列。是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><p>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。队列的使用除去了接收和发送应用程序同时执行的要求。</p><p>在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><p>消息队列的使用场景是怎样的？</p><h2 id="rabbitmq-应用场景" tabindex="-1">RabbitMQ 应用场景 <a class="header-anchor" href="#rabbitmq-应用场景" aria-label="Permalink to &quot;RabbitMQ 应用场景&quot;">​</a></h2><p>对于一个大型的软件系统来说，它会有很多的组件或者说模块或者说子系统或者（subsystem or Component or submodule）。那么这些模块的如何通信？这和传统的IPC有很大的区别。传统的IPC很多都是在单一系统上的，模块耦合性很大，不适合扩展（Scalability）；如果使用socket那么不同的模块的确可以部署到不同的机器上，但是还是有很多问题需要解决。比如：</p><p>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？</p><p>2）如何降低发送者和接收者的耦合度？</p><p>3）如何让Priority高的接收者先接到数据？</p><p>4）如何做到load balance？有效均衡接收者的负载？</p><p>5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。</p><p>6）如何做到可扩展，甚至将这个通信模块发到cluster上？</p><p>7）如何保证接收者接收到了完整，正确的数据？</p><p>AMDQ协议解决了以上的问题，而RabbitMQ实现了AMQP</p><h2 id="rabbitmq-概念介绍" tabindex="-1">RabbitMQ 概念介绍 <a class="header-anchor" href="#rabbitmq-概念介绍" aria-label="Permalink to &quot;RabbitMQ 概念介绍&quot;">​</a></h2><ul><li><strong>Broker</strong>：简单来说就是消息队列服务器实体。</li><li><strong>Exchange</strong>：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li><strong>Queue</strong>：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li><strong>Binding</strong>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li><strong>Routing Key</strong>：路由关键字，exchange根据这个关键字进行消息投递。</li><li><strong>vhost</strong>：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li><strong>producer</strong>：消息生产者，就是投递消息的程序。</li><li><strong>consumer</strong>：消息消费者，就是接受消息的程序。</li><li><strong>channel</strong>：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><p>RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息</p><h2 id="rabbitmq-使用流程" tabindex="-1">RabbitMQ 使用流程 <a class="header-anchor" href="#rabbitmq-使用流程" aria-label="Permalink to &quot;RabbitMQ 使用流程&quot;">​</a></h2><p>AMQP模型中，消息在producer中产生，发送到MQ的exchange上，exchange根据配置的路由方式发到相应的Queue上，Queue又将消息发送给consumer，消息从queue到consumer有push和pull两种方式。消息队列的使用过程大概如下：</p><ol><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li></ol><p>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列</p><h1 id="_4-端口" tabindex="-1">4.端口 <a class="header-anchor" href="#_4-端口" aria-label="Permalink to &quot;4.端口&quot;">​</a></h1><h2 id="_4-1-amqp默认端口-5672" tabindex="-1">4.1：AMQP默认端口(5672) <a class="header-anchor" href="#_4-1-amqp默认端口-5672" aria-label="Permalink to &quot;4.1：AMQP默认端口(5672)&quot;">​</a></h2><p>AMQP（高级消息队列协议）是一种网络协议，用于在应用程序之间传递消息，通常用于消息队列系统。在RabbitMQ中，AMQP协议是消息传递的核心协议，它定义了消息的格式、传递方法和消息队列的行为。下面是您提到的问题的解答：</p><ol><li>AMQP 协议是什么以及它在RabbitMQ中的重要性：</li></ol><ul><li><ul><li>AMQP（Advanced Message Queuing Protocol）是一种网络协议，用于消息传递。它定义了消息的格式和传递规则，允许不同应用程序之间进行异步通信。在RabbitMQ中，AMQP是主要的通信协议，用于生产者将消息发送到队列，消费者从队列中接收消息，以及在消息代理（如RabbitMQ）中进行消息路由和处理。AMQP的重要性在于它提供了一种标准的方法，使不同的应用程序能够可靠地交换消息，从而构建强大的分布式系统。</li></ul></li></ul><ol><li>为什么5672端口是默认端口：</li></ol><ul><li><ul><li>5672端口是AMQP协议的默认端口，通常用于与RabbitMQ建立非加密连接。这个端口之所以成为默认端口，是因为它是AMQP协议的标准端口号，开发者可以方便地配置其应用程序来连接到此端口，而无需手动指定端口号。当您创建一个与RabbitMQ的连接时，如果没有指定端口号，客户端库通常会默认使用5672端口。</li></ul></li></ul><ol><li>如何通过5672端口与RabbitMQ建立非加密连接：</li></ol><ul><li><ul><li>为了通过5672端口与RabbitMQ建立非加密连接，您可以使用适当的AMQP客户端库。以下是通常的步骤：</li></ul></li><li><ul><li><ul><li>安装并配置适当的AMQP客户端库（例如，pika for Python、RabbitMQ Java Client等）。</li><li>在您的应用程序中，创建一个AMQP连接对象，通常需要指定RabbitMQ服务器的主机名或IP地址、端口（5672）、虚拟主机、用户名和密码。</li><li>创建一个通道（channel）来进行消息的发布和订阅。</li><li>使用通道来发送和接收消息。</li></ul></li></ul></li></ul><ol><li>请注意，5672端口是非加密的，默认情况下消息在网络上传输时不会被加密。如果您需要加密连接，可以考虑使用5671端口，它通常用于AMQPS（AMQP over SSL/TLS）协议，这将提供加密的通信。加密连接需要配置证书等安全设置。</li></ol><h2 id="_4-2-rabbitmq管理界面端口-15672" tabindex="-1">4.2：RabbitMQ管理界面端口（15672） <a class="header-anchor" href="#_4-2-rabbitmq管理界面端口-15672" aria-label="Permalink to &quot;4.2：RabbitMQ管理界面端口（15672）&quot;">​</a></h2><p>RabbitMQ管理界面是一个Web应用程序，用于管理和监控RabbitMQ消息代理。下面是有关RabbitMQ管理界面（通常运行在15672端口）的信息：</p><ol><li>管理界面的作用和重要性：</li></ol><ul><li><ul><li>RabbitMQ管理界面是一个用于管理和监控RabbitMQ服务器的用户界面。它对于RabbitMQ的管理和监控是非常重要的，因为它提供了易于使用的图形化界面，允许管理员执行以下任务：</li></ul></li><li><ul><li><ul><li>创建、删除和管理消息队列。</li><li>查看和管理交换机（exchanges）和绑定（bindings）。</li><li>查看当前连接到RabbitMQ的客户端应用程序。</li><li>监视消息传递情况，包括消息发布和消费的速率。</li><li>查看节点信息、集群状态和性能指标。</li><li>设置用户权限和虚拟主机（virtual host）的配置。</li></ul></li></ul></li></ul><ol><li>如何通过15672端口访问RabbitMQ管理控制台：</li></ol><ul><li><ul><li>默认情况下，RabbitMQ管理界面运行在15672端口。要通过浏览器访问管理控制台，您需要确保RabbitMQ服务器正在运行，并且已经启用了管理插件。以下是访问管理控制台的步骤：</li></ul></li><li><ul><li><ul><li>打开Web浏览器，并输入以下URL：<a href="http://your-rabbitmq-server:15672/" target="_blank" rel="noreferrer">http://your-rabbitmq-server:15672/</a></li><li>替换&quot;your-rabbitmq-server&quot;为实际运行RabbitMQ服务器的主机名或IP地址。</li><li>您将被重定向到登录页面，输入您的RabbitMQ用户名和密码，通常是&quot;guest&quot;（默认用户名和密码）。</li><li>登录后，您将能够访问RabbitMQ管理控制台。</li></ul></li></ul></li></ul><ol><li>管理界面提供的功能和监控选项：</li></ol><ul><li><ul><li>RabbitMQ管理控制台提供了多种功能和监控选项，包括但不限于：</li></ul></li><li><ul><li><ul><li>队列和交换机的创建和删除。</li><li>查看连接到服务器的客户端。</li><li>查看队列中的消息数量、消费者数量以及消息的详细信息。</li><li>查看节点的性能指标，例如内存使用情况和CPU利用率。</li><li>配置虚拟主机、用户、权限和策略。</li><li>查看集群状态和节点信息。</li><li>查看日志和错误报告，以进行故障排除。</li></ul></li></ul></li></ul><p>RabbitMQ管理界面是一个强大的工具，用于轻松管理和监控RabbitMQ服务器，以确保消息队列系统的正常运行。</p><h2 id="_4-3-erlang-port-mapper-daemon-epmd-端口-4369" tabindex="-1">4.3：Erlang Port Mapper Daemon（epmd）端口（4369） <a class="header-anchor" href="#_4-3-erlang-port-mapper-daemon-epmd-端口-4369" aria-label="Permalink to &quot;4.3：Erlang Port Mapper Daemon（epmd）端口（4369）&quot;">​</a></h2><p>Erlang Port Mapper Daemon（epmd）是Erlang编程语言中的一个重要组件，用于节点之间的通信。下面是有关epmd和其监听的端口4369的信息：</p><ol><li>epmd的作用，用于节点之间的通信：</li></ol><ul><li><ul><li>epmd（Erlang Port Mapper Daemon）是一个独立的守护进程，它在Erlang分布式系统中扮演着关键的角色。它的主要作用是为Erlang节点提供服务发现和端口分配功能。当Erlang节点启动时，它需要在分布式系统中找到其他节点以便进行通信，epmd负责维护这些节点的注册信息。每个节点在启动时会向epmd注册，以及在需要与其他节点通信时，它会查询epmd获取目标节点的端口信息，从而建立通信连接。</li></ul></li></ul><ol><li>这个端口为什么重要，但通常不由客户端应用程序使用：</li></ol><ul><li><ul><li>端口4369是epmd的默认监听端口。虽然它对Erlang节点之间的通信至关重要，但通常不由客户端应用程序直接使用。客户端应用程序通常通过Erlang虚拟机来与其他Erlang节点通信，而Erlang虚拟机会自动与epmd进行交互以获取目标节点的端口信息。因此，客户端应用程序通常不需要直接连接到4369端口。</li></ul></li></ul><p>总之，epmd是Erlang分布式系统中的重要组件，负责节点之间的服务发现和端口分配，从而支持分布式通信。尽管它监听着端口4369，但客户端应用程序通常不需要直接操作此端口，而是通过Erlang虚拟机来与其他节点通信，让Erlang运行时来处理与epmd的交互。</p><h2 id="_4-4-https端口-25672" tabindex="-1">4.4：HTTPS端口（25672） <a class="header-anchor" href="#_4-4-https端口-25672" aria-label="Permalink to &quot;4.4：HTTPS端口（25672）&quot;">​</a></h2><p>通常情况下，RabbitMQ的管理界面使用HTTP协议在15672端口上提供服务。端口25672通常用于AMQP over TLS（AMQPS），而不是RabbitMQ管理界面的HTTPS访问。如果您希望启用RabbitMQ管理界面的HTTPS访问，您需要进行一些额外的配置，而不是使用25672端口。</p><p>以下是关于RabbitMQ管理界面的HTTPS访问的信息：</p><ol><li>为什么RabbitMQ管理界面提供HTTPS访问：</li></ol><ul><li><ul><li>启用HTTPS访问对RabbitMQ管理界面是一个安全性增强措施。HTTPS提供了数据传输的加密和身份验证，使得管理界面更安全，特别是在生产环境中。这有助于保护敏感信息，如用户名和密码，以及管理操作的数据，免受窃听和中间人攻击的威胁。</li></ul></li></ul><ol><li>如何通过25672端口启用管理界面的HTTPS访问：</li></ol><ul><li><ul><li>默认情况下，RabbitMQ管理界面不会使用25672端口提供HTTPS访问。要启用HTTPS访问，您需要执行以下步骤：</li></ul></li></ul><ol><li><ol><li><ol><li>获得有效的SSL/TLS证书：您需要获取一个有效的SSL/TLS证书，通常从可信的证书颁发机构（CA）获得。这个证书将用于加密HTTPS连接。</li><li>配置RabbitMQ：在RabbitMQ服务器上，您需要编辑RabbitMQ配置文件，通常是<code>rabbitmq.config</code>，并配置HTTPS监听端口和相关SSL/TLS选项。这个配置文件可能位于不同的位置，具体取决于您的RabbitMQ安装。</li><li>启用HTTPS监听：在配置文件中，指定要使用的SSL/TLS证书和私钥的路径，以及其他必要的配置，如端口号等。</li><li>重启RabbitMQ服务器：一旦配置完成，重新启动RabbitMQ服务器，使更改生效。</li><li>使用HTTPS URL：一旦配置完成，您可以通过HTTPS URL（通常是<a href="https://your-rabbitmq-server" target="_blank" rel="noreferrer">https://your-rabbitmq-server</a>:custom-https-port/）访问RabbitMQ管理界面。</li></ol></li></ol></li></ol>',73),o=[b];function n(u,p,s,h,M,Q){return i(),a("div",null,o)}const P=l(r,[["render",n]]);export{d as __pageData,P as default};
