import{_ as a,D as e,o as n,c as l,I as p,w as o,R as i,a as c}from"./chunks/framework.zUbWieqp.js";const m=JSON.parse('{"title":"1.1 redis 的简单介绍","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/Redis/1-jieshao.md","filePath":"guide/Database/Redis/1-jieshao.md","lastUpdated":1720533756000}'),t={name:"guide/Database/Redis/1-jieshao.md"},r=i(`<h1 id="_1-1-redis-的简单介绍" tabindex="-1">1.1 redis 的简单介绍 <a class="header-anchor" href="#_1-1-redis-的简单介绍" aria-label="Permalink to &quot;1.1 redis 的简单介绍&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"> Redis是一个开源（BSD许可）的，ANSI C语言编写的，高级键值（key-value）缓存和支持永久存储NoSql数据库产品。</span></span>
<span class="line"><span style="color:#e1e4e8;">    内存中的数据结构存储系统，他可以用作数据库、缓存和消息中间件。</span></span>
<span class="line"><span style="color:#e1e4e8;">    它支持多种数据类型。字符串(string)、字典(hash)、列表(list)、集合(set)、有序集合(sorted set)</span></span>
<span class="line"><span style="color:#e1e4e8;">    运行于大多数POSIX系统，如Linux、*BSD、OS X等。</span></span>
<span class="line"><span style="color:#e1e4e8;">    基本配合后端数据库使用，存放的只是用户当前频繁调去的数据</span></span>
<span class="line"><span style="color:#e1e4e8;">    作者： Salvatore Sanfilippo</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"> Redis是一个开源（BSD许可）的，ANSI C语言编写的，高级键值（key-value）缓存和支持永久存储NoSql数据库产品。</span></span>
<span class="line"><span style="color:#24292e;">    内存中的数据结构存储系统，他可以用作数据库、缓存和消息中间件。</span></span>
<span class="line"><span style="color:#24292e;">    它支持多种数据类型。字符串(string)、字典(hash)、列表(list)、集合(set)、有序集合(sorted set)</span></span>
<span class="line"><span style="color:#24292e;">    运行于大多数POSIX系统，如Linux、*BSD、OS X等。</span></span>
<span class="line"><span style="color:#24292e;">    基本配合后端数据库使用，存放的只是用户当前频繁调去的数据</span></span>
<span class="line"><span style="color:#24292e;">    作者： Salvatore Sanfilippo</span></span></code></pre></div><h1 id="_1-2-redis的功能特点" tabindex="-1">1.2 redis的功能特点 <a class="header-anchor" href="#_1-2-redis的功能特点" aria-label="Permalink to &quot;1.2 redis的功能特点&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"> 1）高速读写（因为是在内存上的数据库）</span></span>
<span class="line"><span style="color:#e1e4e8;">    2）数据类型丰富</span></span>
<span class="line"><span style="color:#e1e4e8;">    3）支持持久化（把内存上的数据写到磁盘上）</span></span>
<span class="line"><span style="color:#e1e4e8;">    4）多种内存分配及回收策略</span></span>
<span class="line"><span style="color:#e1e4e8;">    5）支持多事物</span></span>
<span class="line"><span style="color:#e1e4e8;">    6）消息队列、消息订阅（先订阅后发送）</span></span>
<span class="line"><span style="color:#e1e4e8;">    7）支持高可用</span></span>
<span class="line"><span style="color:#e1e4e8;">    8）支持分布式分片集群</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"> 1）高速读写（因为是在内存上的数据库）</span></span>
<span class="line"><span style="color:#24292e;">    2）数据类型丰富</span></span>
<span class="line"><span style="color:#24292e;">    3）支持持久化（把内存上的数据写到磁盘上）</span></span>
<span class="line"><span style="color:#24292e;">    4）多种内存分配及回收策略</span></span>
<span class="line"><span style="color:#24292e;">    5）支持多事物</span></span>
<span class="line"><span style="color:#24292e;">    6）消息队列、消息订阅（先订阅后发送）</span></span>
<span class="line"><span style="color:#24292e;">    7）支持高可用</span></span>
<span class="line"><span style="color:#24292e;">    8）支持分布式分片集群</span></span></code></pre></div><h1 id="_1-3-memcache、redis和tair的对比" tabindex="-1">1.3 Memcache、redis和Tair的对比 <a class="header-anchor" href="#_1-3-memcache、redis和tair的对比" aria-label="Permalink to &quot;1.3 Memcache、redis和Tair的对比&quot;">​</a></h1><p>企业缓存数据库解决方案对比</p><h2 id="_1-3-1-memcached" tabindex="-1">1.3.1 Memcached <a class="header-anchor" href="#_1-3-1-memcached" aria-label="Permalink to &quot;1.3.1 Memcached&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">优点：高性能读写，单一的数据类型，支持客户端式分布式集群，一致性hash多核结构，多线程读写性能高</span></span>
<span class="line"><span style="color:#e1e4e8;">缺点：无持久化，节点故障可能出现缓存穿透，分布式需要客户端实现，跨机房数据同步困难，架构扩容复杂度高</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">优点：高性能读写，单一的数据类型，支持客户端式分布式集群，一致性hash多核结构，多线程读写性能高</span></span>
<span class="line"><span style="color:#24292e;">缺点：无持久化，节点故障可能出现缓存穿透，分布式需要客户端实现，跨机房数据同步困难，架构扩容复杂度高</span></span></code></pre></div><h1 id="_1-3-2-redis" tabindex="-1">1.3.2 Redis <a class="header-anchor" href="#_1-3-2-redis" aria-label="Permalink to &quot;1.3.2 Redis&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">优点：高性能读写，多数据类型支持，数据持久化，高可用架构，支持自定义虚拟内存，支持分布式分片集群，单线程读写性能极高</span></span>
<span class="line"><span style="color:#e1e4e8;">缺点：多线程读写较Mencached慢</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">优点：高性能读写，多数据类型支持，数据持久化，高可用架构，支持自定义虚拟内存，支持分布式分片集群，单线程读写性能极高</span></span>
<span class="line"><span style="color:#24292e;">缺点：多线程读写较Mencached慢</span></span></code></pre></div><h1 id="_1-3-3-tair-淘宝使用" tabindex="-1">1.3.3 Tair：淘宝使用 <a class="header-anchor" href="#_1-3-3-tair-淘宝使用" aria-label="Permalink to &quot;1.3.3 Tair：淘宝使用&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">优点：高性能读写，支持三种存储引擎（ddb/rdb/ldb），支持高可用，支持分布式分片集群，支撑了几乎所有淘宝业务的缓存。</span></span>
<span class="line"><span style="color:#e1e4e8;">缺点：单机情况下，读写性能较上两种较慢</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">优点：高性能读写，支持三种存储引擎（ddb/rdb/ldb），支持高可用，支持分布式分片集群，支撑了几乎所有淘宝业务的缓存。</span></span>
<span class="line"><span style="color:#24292e;">缺点：单机情况下，读写性能较上两种较慢</span></span></code></pre></div><h1 id="_1-4-redis的应用场景" tabindex="-1">1.4 Redis的应用场景 <a class="header-anchor" href="#_1-4-redis的应用场景" aria-label="Permalink to &quot;1.4 Redis的应用场景&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1）数据高速缓存</span></span>
<span class="line"><span style="color:#e1e4e8;">2）Web会话缓存（session cache）</span></span>
<span class="line"><span style="color:#e1e4e8;">3）排行榜应用（有序集合、sorted set）</span></span>
<span class="line"><span style="color:#e1e4e8;">4）消息队列</span></span>
<span class="line"><span style="color:#e1e4e8;">5）发布订阅</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1）数据高速缓存</span></span>
<span class="line"><span style="color:#24292e;">2）Web会话缓存（session cache）</span></span>
<span class="line"><span style="color:#24292e;">3）排行榜应用（有序集合、sorted set）</span></span>
<span class="line"><span style="color:#24292e;">4）消息队列</span></span>
<span class="line"><span style="color:#24292e;">5）发布订阅</span></span></code></pre></div><h1 id="_1-6-7-redis数据的持久化" tabindex="-1">1.6.7 Redis数据的持久化 <a class="header-anchor" href="#_1-6-7-redis数据的持久化" aria-label="Permalink to &quot;1.6.7 Redis数据的持久化&quot;">​</a></h1><h2 id="_1-6-7-1-rdb持久化" tabindex="-1">1.6.7.1 RDB持久化 <a class="header-anchor" href="#_1-6-7-1-rdb持久化" aria-label="Permalink to &quot;1.6.7.1 RDB持久化&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">可以在指定的时间间隔生成数据集的时间点快照（point-in-time-snapshot）；</span></span>
<span class="line"><span style="color:#e1e4e8;">相当于在一定时间内把当前redis缓存数据库里面的数据拍个照片，存放到磁盘上的永久化文件上（dbfilename），</span></span>
<span class="line"><span style="color:#e1e4e8;">性能比AOF持久化高，突然宕机可能会照成少量的数据丢失</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">可以在指定的时间间隔生成数据集的时间点快照（point-in-time-snapshot）；</span></span>
<span class="line"><span style="color:#24292e;">相当于在一定时间内把当前redis缓存数据库里面的数据拍个照片，存放到磁盘上的永久化文件上（dbfilename），</span></span>
<span class="line"><span style="color:#24292e;">性能比AOF持久化高，突然宕机可能会照成少量的数据丢失</span></span></code></pre></div><h2 id="_1-6-7-2-rdb持久的优点" tabindex="-1">1.6.7.2 RDB持久的优点 <a class="header-anchor" href="#_1-6-7-2-rdb持久的优点" aria-label="Permalink to &quot;1.6.7.2 RDB持久的优点&quot;">​</a></h2><ul><li><p>1）RDB是一种表示某个即时点的Redis数据的紧凑文件。RDB文件适合用于备份。例如，你可能想要每小时归档最近24小时的RDB文件，每天保存近30天的RDB快照。这允许你很容易的恢复不同版本的数据集以容灾。</p></li><li><p>2）RDB非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心。</p></li><li><p>3）RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作。</p></li><li><p>4）RDB在重启保存了大数据集的实例时比AOF要快。</p></li></ul><h2 id="_1-6-7-3-rdb的缺点" tabindex="-1">1.6.7.3 RDB的缺点 <a class="header-anchor" href="#_1-6-7-3-rdb的缺点" aria-label="Permalink to &quot;1.6.7.3 RDB的缺点&quot;">​</a></h2><ul><li><p>1）当你需要在Redis停止工作(例如停电)时最小化数据丢失，RDB可能不太好。你可以配置不同的保存点(save point)来保存RDB文件(例如，至少5分钟和对数据集100次写之后，但是你可以有多个保存点)。然而，你通常每隔5分钟或更久创建一个RDB快照，所以一旦Redis因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。</p></li><li><p>2）RDB需要经常调用fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且CPU性能不够强大的话，Redis会停止服务客户端几毫秒甚至一秒。AOF也需要fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。</p></li></ul><h2 id="_1-6-7-4-aof持久化" tabindex="-1">1.6.7.4 AOF持久化 <a class="header-anchor" href="#_1-6-7-4-aof持久化" aria-label="Permalink to &quot;1.6.7.4 AOF持久化&quot;">​</a></h2><p>记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中命令全部以Redis协议的格式来保存，新命令会被追加到文件末尾。因为每执行一条写操作，都要对磁盘上写一次，所以性能比较低，安全性最好，实时记录</p><h2 id="_1-6-7-5-aof持久化的优点" tabindex="-1">1.6.7.5 AOF持久化的优点 <a class="header-anchor" href="#_1-6-7-5-aof持久化的优点" aria-label="Permalink to &quot;1.6.7.5 AOF持久化的优点&quot;">​</a></h2><ul><li><p>1）使用AOF Redis会更具有可持久性(durable)：你可以有很多不同的fsync策略：没有fsync，每秒fsync，每次请求时fsync。使用默认的每秒fsync策略，写性能也仍然很不错(fsync是由后台线程完成的，主线程继续努力地执行写请求)，即便你也就仅仅只损失一秒钟的写数据。</p></li><li><p>2）AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof工具也可以很轻易的修复。</p></li><li><p>3）当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。</p></li><li><p>4）AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。你也可以轻易的导出一个AOF文件。例如，即使你不小心错误地使用FLUSHALL命令清空一切，如果此时并没有执行重写，你仍然可以保存你的数据集，你只要停止服务器，删除最后一条命令，然后重启Redis就可以。</p></li></ul><h2 id="_1-6-7-6-aof的缺点" tabindex="-1">1.6.7.6 AOF的缺点 <a class="header-anchor" href="#_1-6-7-6-aof的缺点" aria-label="Permalink to &quot;1.6.7.6 AOF的缺点&quot;">​</a></h2><ul><li><p>1）对同样的数据集，AOF文件通常要大于等价的RDB文件。</p></li><li><p>2）AOF可能比RDB慢，这取决于准确的fsync策略。通常fsync设置为每秒一次的话性能仍然很高，如果关闭fsync，即使在很高的负载下也和RDB一样的快。不过，即使在很大的写负载情况下，RDB还是能提供能好的最大延迟保证。</p></li><li><p>3）在过去，我们经历了一些针对特殊命令(例如，像BRPOPLPUSH这样的阻塞命令)的罕见bug，导致在数据加载时无法恢复到保存时的样子。这些bug很罕见，我们也在测试套件中进行了测试，自动随机创造复杂的数据集，然后加载它们以检查一切是否正常，但是，这类bug几乎不可能出现在RDB持久化中。为了说得更清楚一点：Redis AOF是通过递增地更新一个已经存在的状态，像MySQL或者MongoDB一样，而RDB快照是一次又一次地从头开始创造一切，概念上更健壮。但是，1)要注意Redis每次重写AOF时都是以当前数据集中的真实数据从头开始，相对于一直追加的AOF文件(或者一次重写读取老的AOF文件而不是读内存中的数据)对bug的免疫力更强。2)我们还没有收到一份用户在真实世界中检测到崩溃的报告。</p></li></ul><h2 id="_1-6-7-7-rdb和aof的选择" tabindex="-1">1.6.7.7 RDB和AOF的选择 <a class="header-anchor" href="#_1-6-7-7-rdb和aof的选择" aria-label="Permalink to &quot;1.6.7.7 RDB和AOF的选择&quot;">​</a></h2><p>一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户单独使用AOF，但是我们并不鼓励这样，因为时常进行RDB快照非常方便于数据库备份，启动速度也较之快，还避免了AOF引擎的bug</p><h2 id="_1-6-7-8-快照的工作方式" tabindex="-1">1.6.7.8 快照的工作方式 <a class="header-anchor" href="#_1-6-7-8-快照的工作方式" aria-label="Permalink to &quot;1.6.7.8 快照的工作方式&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"> 默认情况下，Redis保存数据集快照到磁盘，名为dump.rdb的二进制文件。</span></span>
<span class="line"><span style="color:#e1e4e8;"> </span></span>
<span class="line"><span style="color:#e1e4e8;"> 你可以设置让Redis在N秒内至少有M次数据集改动时保存数据集，或者你也可以手动调用SAVE或者BGSAVE命令。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">例如，这个配置会让Redis在每个60秒内至少有1000次键改动时自动转储数据集到磁盘：</span></span>
<span class="line"><span style="color:#e1e4e8;">#配置文件里面加上</span></span>
<span class="line"><span style="color:#e1e4e8;">save 60 1000</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"> 默认情况下，Redis保存数据集快照到磁盘，名为dump.rdb的二进制文件。</span></span>
<span class="line"><span style="color:#24292e;"> </span></span>
<span class="line"><span style="color:#24292e;"> 你可以设置让Redis在N秒内至少有M次数据集改动时保存数据集，或者你也可以手动调用SAVE或者BGSAVE命令。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">例如，这个配置会让Redis在每个60秒内至少有1000次键改动时自动转储数据集到磁盘：</span></span>
<span class="line"><span style="color:#24292e;">#配置文件里面加上</span></span>
<span class="line"><span style="color:#24292e;">save 60 1000</span></span></code></pre></div><h2 id="_1-6-7-9-redis配置" tabindex="-1">1.6.7.9 Redis配置 <a class="header-anchor" href="#_1-6-7-9-redis配置" aria-label="Permalink to &quot;1.6.7.9 Redis配置&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">#60S内有1000次改写就拍照</span></span>
<span class="line"><span style="color:#e1e4e8;">save 60 1000 </span></span>
<span class="line"><span style="color:#e1e4e8;">高级配置</span></span>
<span class="line"><span style="color:#e1e4e8;">stop-writes-on-bgsave-error yes</span></span>
<span class="line"><span style="color:#e1e4e8;">rdbcompression yes </span></span>
<span class="line"><span style="color:#e1e4e8;">rdbchecksum yes</span></span>
<span class="line"><span style="color:#e1e4e8;">dbfilename dump.rdb</span></span>
<span class="line"><span style="color:#e1e4e8;">dir ./ </span></span>
<span class="line"><span style="color:#e1e4e8;">以上配置分别表示：</span></span>
<span class="line"><span style="color:#e1e4e8;">后台备份进程出错时,主进程停不停止写入? 主进程不停止容易造成数据不一致 </span></span>
<span class="line"><span style="color:#e1e4e8;">导出的rdb文件是否压缩 如果rdb的大小很大的话建议这么做</span></span>
<span class="line"><span style="color:#e1e4e8;">导入rbd恢复时数据时,要不要检验rdb的完整性 验证版本是不是一致</span></span>
<span class="line"><span style="color:#e1e4e8;">导出来的rdb文件名</span></span>
<span class="line"><span style="color:#e1e4e8;">rdb的放置路径</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">#60S内有1000次改写就拍照</span></span>
<span class="line"><span style="color:#24292e;">save 60 1000 </span></span>
<span class="line"><span style="color:#24292e;">高级配置</span></span>
<span class="line"><span style="color:#24292e;">stop-writes-on-bgsave-error yes</span></span>
<span class="line"><span style="color:#24292e;">rdbcompression yes </span></span>
<span class="line"><span style="color:#24292e;">rdbchecksum yes</span></span>
<span class="line"><span style="color:#24292e;">dbfilename dump.rdb</span></span>
<span class="line"><span style="color:#24292e;">dir ./ </span></span>
<span class="line"><span style="color:#24292e;">以上配置分别表示：</span></span>
<span class="line"><span style="color:#24292e;">后台备份进程出错时,主进程停不停止写入? 主进程不停止容易造成数据不一致 </span></span>
<span class="line"><span style="color:#24292e;">导出的rdb文件是否压缩 如果rdb的大小很大的话建议这么做</span></span>
<span class="line"><span style="color:#24292e;">导入rbd恢复时数据时,要不要检验rdb的完整性 验证版本是不是一致</span></span>
<span class="line"><span style="color:#24292e;">导出来的rdb文件名</span></span>
<span class="line"><span style="color:#24292e;">rdb的放置路径</span></span></code></pre></div>`,35);function d(h,y,b,u,g,v){const s=e("center");return n(),l("div",null,[p(s,null,{default:o(()=>[c("redis 缓存数据库")]),_:1}),r])}const R=a(t,[["render",d]]);export{m as __pageData,R as default};
