import{_ as e,o as r,c as s,R as t}from"./chunks/framework.zUbWieqp.js";const g=JSON.parse('{"title":"1.kubernetes简介","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/k8s/1-kubernetes简介.md","filePath":"guide/container/k8s/1-kubernetes简介.md","lastUpdated":1734344767000}'),n={name:"guide/container/k8s/1-kubernetes简介.md"},a=t(`<p>K8S官网：<a href="https://kubernetes.io/" target="_blank" rel="noreferrer">https://kubernetes.io/</a></p><p>K8S中文文档：<a href="https://kubernetes.io/zh-cn/docs/home/" target="_blank" rel="noreferrer">https://kubernetes.io/zh-cn/docs/home/</a></p><p>文档概览：<a href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noreferrer">https://kubernetes.io/zh/docs/home/</a></p><p>标准化词汇表：<a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-kubelet" target="_blank" rel="noreferrer">https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-kubelet</a> （查询各种关键词、技术术语的相关解释）</p><p>k8s中文社区：<a href="https://www.kubernetes.org.cn/" target="_blank" rel="noreferrer">https://www.kubernetes.org.cn/</a></p><p>k8s中文社区的文档：<a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noreferrer">http://docs.kubernetes.org.cn/</a></p><hr><p><a href="https://kubernetes.io/zh/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noreferrer">kubectl 备忘单 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/reference/kubectl/kubectl/" target="_blank" rel="noreferrer">kubectl | Kubernetes</a><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#drain" target="_blank" rel="noreferrer">Kubectl Reference Docs</a><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noreferrer">使用 RBAC 鉴权 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/" target="_blank" rel="noreferrer">节点 cordon| Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/safely-drain-node/" target="_blank" rel="noreferrer">驱逐 确保 PodDisruptionBudget 的前提下安全地清空一个节点 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/" target="_blank" rel="noreferrer">升级 kubeadm 集群 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/" target="_blank" rel="noreferrer">为 Kubernetes 运行 etcd 集群 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/" target="_blank" rel="noreferrer">网络策略 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#nodeport" target="_blank" rel="noreferrer">服务 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/" target="_blank" rel="noreferrer">Ingress | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noreferrer">Deployments | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector" target="_blank" rel="noreferrer">将 Pod 分配给节点 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" rel="noreferrer">污点和容忍度 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/" target="_blank" rel="noreferrer">Pod 拓扑扩展约束 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noreferrer">Init 容器 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noreferrer">持久卷 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" target="_blank" rel="noreferrer">持久卷 pvc| Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/persistent-volumes/#%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%8E%9F%E5%A7%8B%E5%9D%97%E8%AE%BE%E5%A4%87%E8%B7%AF%E5%BE%84%E7%9A%84-pod-%E8%A7%84%E7%BA%A6" target="_blank" rel="noreferrer">持久卷 pod pvc | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/#emptydir" target="_blank" rel="noreferrer">卷 volumeMounts | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume" target="_blank" rel="noreferrer">配置 Pod 以使用 PersistentVolume 作为存储 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/volumes/#hostpath" target="_blank" rel="noreferrer">卷 - hostPath | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/storage/storage-classes/#%E5%85%81%E8%AE%B8%E5%8D%B7%E6%89%A9%E5%B1%95" target="_blank" rel="noreferrer">存储类 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/debug-application-cluster/debug-service/" target="_blank" rel="noreferrer">调试 Service | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/logging/" target="_blank" rel="noreferrer">日志架构 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/debug-application-cluster/debug-cluster/" target="_blank" rel="noreferrer">集群故障排查 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-volume-storage/" target="_blank" rel="noreferrer">emptyDir 配置 Pod 以使用卷进行存储 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noreferrer">配置 Pod 使用 ConfigMap | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/inject-data-application/distribute-credentials-secure/" target="_blank" rel="noreferrer">使用 Secret 安全地分发凭证 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noreferrer">Pod 与 Service 的 DNS | Kubernetes</a><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noreferrer">安装 kubeadm | Kubernetes</a><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noreferrer">为 Pod 或容器配置安全性上下文 | Kubernetes</a><a href="https://kubernetes.io/zh/docs/concepts/policy/pod-security-policy/" target="_blank" rel="noreferrer">Pod 安全策略 | Kubernetes</a></p><hr><h1 id="_1-kubernetes简介" tabindex="-1">1.kubernetes简介 <a class="header-anchor" href="#_1-kubernetes简介" aria-label="Permalink to &quot;1.kubernetes简介&quot;">​</a></h1><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">#下载源码</span></span>
<span class="line"><span style="color:#B392F0;">git</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">clone</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">git@github.com:kubernetes/kubernetes.git</span></span>
<span class="line"><span style="color:#B392F0;">git</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">checkout</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-b</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">v1.25</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">remotes/origin/release-1.25</span></span>
<span class="line"><span style="color:#79B8FF;">cd</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">kubernetes</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">#下载源码</span></span>
<span class="line"><span style="color:#6F42C1;">git</span><span style="color:#24292E;"> </span><span style="color:#032F62;">clone</span><span style="color:#24292E;"> </span><span style="color:#032F62;">git@github.com:kubernetes/kubernetes.git</span></span>
<span class="line"><span style="color:#6F42C1;">git</span><span style="color:#24292E;"> </span><span style="color:#032F62;">checkout</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-b</span><span style="color:#24292E;"> </span><span style="color:#032F62;">v1.25</span><span style="color:#24292E;"> </span><span style="color:#032F62;">remotes/origin/release-1.25</span></span>
<span class="line"><span style="color:#005CC5;">cd</span><span style="color:#24292E;"> </span><span style="color:#032F62;">kubernetes</span></span></code></pre></div><h2 id="_1-1-kubernetes是什么" tabindex="-1">1.1 Kubernetes是什么 <a class="header-anchor" href="#_1-1-kubernetes是什么" aria-label="Permalink to &quot;1.1 Kubernetes是什么&quot;">​</a></h2><p><strong>Kubernetes</strong>是一个可移植、可扩展的“分布式开源平台&quot;，这个平台主要是用来管理我们运行的容器化应用，只不过这个平台它是一个分布式的，那<strong>Kubernetes</strong>这个分布式平台是如何实现的呢。<strong>Kubernetes</strong>是将多个0S节点组织在一起，构建出一个庞大的虚拟资源池，而后对用户提供操作该集群的接口，用户就可以通过<strong>Kubernetes</strong>提供的对应接口对容器进行增删查改等操作。所以对于用户而言，它无需关心<strong>Kubernetes</strong>底层是如何对容器进行的创建、又是如何调度到对应的节点的，它只需要专注于自己的业务逻辑代码开发即可;</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202312200919507.png" alt="image-20231219223630003"></p><p>当我们需要使用<strong>Kubernetes</strong>交付应用时，仅需要通过<strong>yaml</strong>文件的方式来描述对应容器的状态，<strong>Kubernetes</strong>则会按照yaml文件中所描述的容器状态信息；进行容器的&quot;自动化&quot;创建。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202312200920184.png" alt="image-20231219223944449"></p><p>Kubernetes会时刻监控着容器的状态，如果有容器故障，则会尝试重启容器，使其能容器运行的状态能达到用户所期望的值</p><h2 id="_1-2-为什么需要kubernetes" tabindex="-1">1.2 为什么需要Kubernetes <a class="header-anchor" href="#_1-2-为什么需要kubernetes" aria-label="Permalink to &quot;1.2 为什么需要Kubernetes&quot;">​</a></h2><p>目前使用容器打包和运行应用程序，已经是业界主流的一种方式，在生产环境中，我们需要管理运行应用程序的容器，同时还要确保它不会停机,</p><p>例：一个容器发生故障，需要重新拉起该容器。如果系统能自动为其处理，那么容器的管理会不会更加的容易</p><p>这就是Kubernetes需要解决的问题！Kubernetes它可以轻松的实现应用的扩展、服务发现、负载均衡、容器的故障转移、以及容器编排等。</p><ul><li>垂直扩容：新的服务器节点能够很容易的进行增加和删除。</li><li>水平扩容：容器实例能通过副本控制器进行轻松的扩容，</li><li>缩容弹性伸缩：能根据容器的资源使用情况，进行自动的扩缩容</li><li>服务发现和负载均衡：Kubernetes为容器提供负载均衡功能进行流量调度，从而使得应用运行更加稳定。</li><li>存储编排：Kubernetes允许自动挂载各种存储类系统，例如本地存储、NFS、GFS、Ceph、公共云存储等。</li><li>自动部署和回滚：如果应用部署过程中出现错误，可以实现自动回滚</li><li>自动完成装箱计算：Kubernetes允许指定每个容器所需的CPU和内存资源，能够更好的管理容器的资源使用。</li><li>自我修复：Kubernetes 会重新启动失败的容器、替换容器、对运行状况检查不响应的容器进行杀死</li><li>密钥与配置管理：Kubernetes允许你存储和管理敏感信息，例如密码、令牌和SSh 密钥。可以在不重建容器镜像的情况下，部署和更新密钥</li></ul><h2 id="_1-3-kubernetes不是什么" tabindex="-1">1.3 Kubernetes不是什么 <a class="header-anchor" href="#_1-3-kubernetes不是什么" aria-label="Permalink to &quot;1.3 Kubernetes不是什么&quot;">​</a></h2><p><strong>Kubernetes</strong>不是传统的、包罗万象的PaaS（平台即服务）系统。它提供了PaaS产品共有的一些普遍适用的功能,例如部署、扩展、负载均衡、日志记录和监视。<strong>Kubernetes</strong>默认解决方案都是可选和可插拔的。但在重要的地方保留了用户的选择和灵活性。</p><p>Kubernetes:</p><ul><li>不限制支持的应用程序类型：如果只要应用程序可以在容器中运行，那么它应该可以在 Kubernetes上很好地运行。</li><li>不部署源代码，也不构建你的应用程序：CI/CD工作流取决于组织的文化和偏好以及技术要求。</li><li>不提供应用程序级别的服务作为内置服务：例如中间件（例如，消息中间件）、数据处理框架（例如，Spark）、数据库（例如,mysqL）、缓存、集群存储系统(例如，Ceph）。但这些组件都可以在 Kubernetes 上运行</li><li>不要求日志记录、监视或警报解决方案它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。</li><li>不提供或不要求配置语言/系统：它提供了声明性API，该声明性API可以由任意形式的声明性规范所构成。RESTfuL；不提供也不采用任何的机器配置、维护、管理或自我修复系统</li></ul><h2 id="_1-4-kubernetes优势" tabindex="-1">1.4 Kubernetes优势 <a class="header-anchor" href="#_1-4-kubernetes优势" aria-label="Permalink to &quot;1.4 Kubernetes优势&quot;">​</a></h2><p><strong>优势：</strong></p><ol><li><strong>微服务架构支持</strong>：Kubernetes非常适合部署和管理基于微服务的应用程序，每个服务可以独立运行在Pod中，并通过Service进行发现和通信。</li><li><strong>自动化部署与扩展</strong>：自动化的滚动更新、回滚以及水平扩展（HPA）功能使得应用程序的发布过程更加快速、可靠且无需人工干预。</li><li><strong>资源调度与优化</strong>：Kubernetes能够高效地跨集群节点调度容器，根据资源需求动态分配和调整容器的位置，从而最大化硬件资源利用率。</li><li><strong>容错性和高可用性</strong>：它提供了自我修复机制，当容器或节点出现问题时，会自动重新调度并恢复工作负载，保证应用的持续可用。</li><li><strong>网络管理</strong>：内置的服务发现和负载均衡机制，简化了服务间的通信，同时支持Ingress控制器对外提供统一入口和路由策略。</li><li><strong>存储集成</strong>：支持多种存储插件，方便为容器提供持久化存储解决方案，满足不同应用场景的数据持久化需求。</li><li><strong>安全与隔离</strong>：通过Namespace实现多租户隔离，使用RBAC等安全策略来控制用户权限，确保集群内资源的安全访问。</li><li><strong>可观测性与监控</strong>：集成Prometheus、Grafana等工具以实现资源和应用性能的实时监控，便于问题排查和性能优化。</li></ol><p><strong>适应场景：</strong></p><ul><li><strong>云原生应用</strong>：Kubernetes是云原生技术栈的核心组成部分，适合部署在公有云、私有云或者混合云环境下的现代应用程序。</li><li><strong>大规模分布式系统</strong>：对于需要处理高并发、快速响应市场变化的大规模业务场景，K8s能轻松应对扩缩容需求。</li><li><strong>持续集成/持续部署(CI/CD)</strong>：结合Jenkins、GitOps等工具，Kubernetes可以构建端到端的自动化部署流水线。</li><li><strong>边缘计算与物联网(IoT)</strong>：尽管初期主要针对数据中心设计，但随着轻量级版本的发展，如K3s等，也在逐渐适用于边缘计算设备上的部署和管理。</li></ul><p><strong>特点：</strong></p><ul><li><strong>声明式配置</strong>：采用YAML文件描述目标状态，Kubernetes会自动将实际状态调整至期望状态。</li><li><strong>可移植性</strong>：跨平台兼容性强，能在各种基础设施上运行，保持一致的管理和操作体验。</li><li><strong>社区生态丰富</strong>：拥有庞大的开源社区支持，周边工具链完善，包括CI/CD工具、日志与监控系统、服务网格等。</li></ul><h2 id="_1-5-kubernetes集群角色" tabindex="-1">1.5 Kubernetes集群角色 <a class="header-anchor" href="#_1-5-kubernetes集群角色" aria-label="Permalink to &quot;1.5 Kubernetes集群角色&quot;">​</a></h2><p>Kubernetes集群需要建立在多个物理主机上，将多个物理主机的资源抽象出来，组织成一个平台，而后进行统一管理，当然它需要多个物理主机，不一定必须是物理机，也可以是虚拟机VM等等；所以从这个角度来说，Kubernetes是一个集群，但是在Kubernetes集群内部，这些节点又被划分成了两类角色;</p><ul><li>一类角色为主节点，叫<strong>Master</strong>，负责管理集群;</li><li>一类角色为工作节点，叫<strong>Node</strong>，负责运行应用；</li></ul><p>这也就意味着我们将来运行的所有容器，都应该运行在Node节点，而Master负责管理有多少个Node节点，同时还负责管理每个Node节点应该运行哪个容器或哪些容器，的控制中心，因此在Kubernetes中Master被称之为<strong>Control plane</strong>控制平面，而Node就是我们的<strong>dataplane</strong>叫数据平面;</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202312200920876.png" alt="image-20231219225024388"></p><p>Registry：Kubernetes主要是在Node上运行容器化应用，那么容器化应用需要依托镜像，而镜像又来自于Registry，但Registry并不是Kubernetes集群的组成部分，但我们必须要有一个私有的Registry,当然也可以使用公共的镜像仓库;</p><p>CLient：无论客户端是通过API接口，还是WebUI接口、异或者CLI接口与Master交互，其实都是向Master发送请求，比如客户端申请创建容器、删除容器等，都是由Master负责在Node节点上对容器进行增删改查，而这些操作必须要通过Master，由Master控制着完成的，虽然我们将其称Master，但它并非是一个组件，而是由多个组件组成的;</p><h1 id="_2-kubernetes集群组件" tabindex="-1">2.Kubernetes集群组件 <a class="header-anchor" href="#_2-kubernetes集群组件" aria-label="Permalink to &quot;2.Kubernetes集群组件&quot;">​</a></h1><p>通过创建一个Pod或者DepLoyment资源来了解Kubernetes集群组件以及之间的关系。</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202312200920952.png" alt="image-20231219225248703"></p><h2 id="_2-1-master节点组件" tabindex="-1">2.1 Master节点组件 <a class="header-anchor" href="#_2-1-master节点组件" aria-label="Permalink to &quot;2.1 Master节点组件&quot;">​</a></h2><p>集群的控制节点，负责整个集群的管理和控制，kubernetes的所有的命令基本都是发给Master，由它来负责具体的执行过程</p><h3 id="_2-1-1-kube-apiserver" tabindex="-1">2.1.1 kube-APIServer <a class="header-anchor" href="#_2-1-1-kube-apiserver" aria-label="Permalink to &quot;2.1.1 kube-APIServer&quot;">​</a></h3><p>Kubernetes API主要提供前端请求接入，然后验证客户端身份，以及客户端提交的请求。所有的组件都必须通过APIServer进行交互;---&gt;(<code>资源增删改查的入口</code>)</p><h3 id="_2-1-2-kube-scheduler" tabindex="-1">2.1.2 Kube-Scheduler <a class="header-anchor" href="#_2-1-2-kube-scheduler" aria-label="Permalink to &quot;2.1.2 Kube-Scheduler&quot;">​</a></h3><p>负责监视<strong>APIServer</strong>新创建，但未指定运行至哪个节点的Pod，然后选择合适的节点让<strong>Pod</strong>在上面运行;调度决策考虑的因素有很多，其中有<strong>Pod</strong>亲和性、反亲和、节点亲和、数据位置、等---&gt;<code>负责资源调度（Pod调度）</code></p><h3 id="_2-1-3-kube-controllmanager" tabindex="-1">2.1.3 Kube-ControllManager <a class="header-anchor" href="#_2-1-3-kube-controllmanager" aria-label="Permalink to &quot;2.1.3 Kube-ControllManager&quot;">​</a></h3><p>控制器通过<strong>APIServer</strong>监控集群当前运行的容器状态，当控制器监控到运行的容器状态不符合期望状态时，控制器会致力于将当前状态转变为期望的状态，简单来说就是自动调节当前系统运行状态；控制循环的例子：房间里的温度自动调节器。当你设置了温度，告诉了温度自动调节器你的<strong>期望状态 (DesiredState)</strong>。房间的实际温度是**当前状态 (Current State)**通过对设备的控制，温度自动调节器让其当前状态接近期望状态。---&gt;<code>资源对象的大总管</code></p><p>这些控制器包括:</p><ul><li>节点控制器：（NodeControLler）：负责在节点出现故障时进行通知和响应;</li><li>副本控制器（ReplicaSetController）：监视容器运行的副本，时刻让其维持期望状态;</li><li>任务控制器（JobcontrolLer）：监测一次性任务的Job对象，然后创建Pods来运行这些任务直至完成；</li><li>...</li></ul><h2 id="_2-2node节点组件" tabindex="-1">2.2Node节点组件 <a class="header-anchor" href="#_2-2node节点组件" aria-label="Permalink to &quot;2.2Node节点组件&quot;">​</a></h2><p>Node是集群的工作负载节点，默认情况kubelet会向Master注册自己，一旦Node被纳入集群管理范围，kubelet会定时向Master汇报自身的情报，包括操作系统，Docker版本，机器资源情况等。</p><p>如果Node超过指定时间不上报信息，会被Master判断为“失联”，标记为Not Ready，随后Master会触发Pod转移</p><h3 id="_2-2-1-kube-kubelet" tabindex="-1">2.2.1 Kube-kubelet <a class="header-anchor" href="#_2-2-1-kube-kubelet" aria-label="Permalink to &quot;2.2.1 Kube-kubelet&quot;">​</a></h3><p><strong>kubelet</strong> 是集群中每个<strong>Node</strong>节点上运行的代理程序，用于接收<strong>APIServer</strong>提供给它的<strong>PodSpecs</strong>，确保这些<strong>PodSpecs</strong>中描述的容器处于运行状态且健康，主要作用就是管理容器的启动、停止、销毁、重建等；---&gt;<code>Pod的管家，与Master通信</code></p><h3 id="_2-2-2-kube-kubeproxy" tabindex="-1">2.2.2 Kube-kubeproxy <a class="header-anchor" href="#_2-2-2-kube-kubeproxy" aria-label="Permalink to &quot;2.2.2 Kube-kubeproxy&quot;">​</a></h3><p><strong>kube-proxy</strong>是集群中每个节点上运行的网络代理，它主要维护每台节点上的<strong>Iptables、IPVS</strong>规则创建和删除，这些规则允许从集群内部或集群外部与<strong>Pod</strong>进行网络通信；</p><p>kube-proxy负责实现容器的负载均衡，然后将指定的流量调度到对应的容器，通过iptables 或 ipvs规则来实现;---&gt;<code>实现kubernetes Service的通信与负载均衡机制的重要组件</code></p><h3 id="_2-2-3-containerruntime" tabindex="-1">2.2.3 ContainerRuntime <a class="header-anchor" href="#_2-2-3-containerruntime" aria-label="Permalink to &quot;2.2.3 ContainerRuntime&quot;">​</a></h3><p>容器运行环境是负责运行容器的软件，<strong>Kubernetes</strong>支持容器运行时,比如<strong>Docker</strong>、<strong>Containerd</strong>等;</p><h2 id="_2-3附加组件" tabindex="-1">2.3附加组件 <a class="header-anchor" href="#_2-3附加组件" aria-label="Permalink to &quot;2.3附加组件&quot;">​</a></h2><h3 id="_2-3-1-coredns" tabindex="-1">2.3.1 CoreDNS <a class="header-anchor" href="#_2-3-1-coredns" aria-label="Permalink to &quot;2.3.1 CoreDNS&quot;">​</a></h3><p>每创建一个内部负载均衡，则自动创建一条对应的DNS记录，这样就可以让Pod通过域名的方式访问对应的负载均衡；因为k8s分配的负载均衡IP不稳定，删除和添加都会发生变化，但如果分配一个稳定的DNS名称,则无需关系负载均衡的IP;</p><h3 id="_2-3-2-network" tabindex="-1">2.3.2 network <a class="header-anchor" href="#_2-3-2-network" aria-label="Permalink to &quot;2.3.2 network&quot;">​</a></h3><p>网络插件，为每个Pod分配一个IP地址，确保多个不同节点的Pod能够直接通信，而无需经过NAT地址转换等；</p><h3 id="_2-3-3-dashboard" tabindex="-1">2.3.3 Dashboard <a class="header-anchor" href="#_2-3-3-dashboard" aria-label="Permalink to &quot;2.3.3 Dashboard&quot;">​</a></h3><p>为Kubernetes提供图形界面，通过图形界面管理Kubernetes;</p><h2 id="_2-4-组件流程图" tabindex="-1">2.4 组件流程图 <a class="header-anchor" href="#_2-4-组件流程图" aria-label="Permalink to &quot;2.4 组件流程图&quot;">​</a></h2><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202405232143178.png" alt="image-20240523214336841"></p><h1 id="_3-总结" tabindex="-1">3. 总结 <a class="header-anchor" href="#_3-总结" aria-label="Permalink to &quot;3. 总结&quot;">​</a></h1><h2 id="控制节点组件" tabindex="-1">控制节点组件 <a class="header-anchor" href="#控制节点组件" aria-label="Permalink to &quot;控制节点组件&quot;">​</a></h2><ul><li>APIServer：APIServer是整个集群的控制中枢（无状态，数据保存在etcd中，看LB调度到哪个节点中的APIServer），提供集群中各个模块之间的数据交换（比如Scheduler和Controller Manager需要进行数据交换，都需要通过APIServer进行连接），并将集群状态和信息存储到分布式键-值（key-value）存储系统Etcd集群中。同时它也是管理集群、资源配额、提供完备的集群安全机制的入口，为集群各类资源对象提供增删改查以及watch 的REST API接口。</li><li>Scheduler：Scheduler是集群Pod的调度中心（有状态，选举机制。无论有多少个节点，工作的只有一个节点），主要是通过调度算法将Pod分配到最佳的Node节点，它通过APIServer监听所有Pod的状态，一旦发现新的未被调度到任何Node节点的Pod（PodSpec.NodeName为空），就会根据一系列策略选择最佳节点进行调度。</li><li>Controller Manager：Controller Manager是集群状态管理器（有状态，选举机制。无论有多少个节点，工作的只有一个节点），以保证Pod或其他资源达到期望值。当集群中某个Pod的副本数或其他资源因故障和错误导致无法正常运行，没有达到设定的值时，Controller Manager会尝试自动修复并使其达到期望状态。</li><li>Etcd：Etcd有CoreOS开发，用于可靠地存储集群的配置数据，是一种持久性、轻量型、分布式的键-值（key-value）数据存储组件，作为Kubernetes集群的持久化存储系统。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># kubectl get leases -n kube-system </span></span>
<span class="line"><span style="color:#B392F0;">NAME</span><span style="color:#E1E4E8;">                      </span><span style="color:#9ECBFF;">HOLDER</span><span style="color:#E1E4E8;">                                              </span><span style="color:#9ECBFF;">AGE</span></span>
<span class="line"><span style="color:#B392F0;">kube-controller-manager</span><span style="color:#E1E4E8;">   </span><span style="color:#9ECBFF;">k8s-master01_acfa3612-ea75-4d65-bf99-89ae2bcfe3c9</span><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">11</span><span style="color:#9ECBFF;">d</span></span>
<span class="line"><span style="color:#B392F0;">kube-scheduler</span><span style="color:#E1E4E8;">            </span><span style="color:#9ECBFF;">k8s-master03_501a1433-ecf5-454a-9f01-5c71e34738d5</span><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">11</span><span style="color:#9ECBFF;">d</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># kubectl get leases -n kube-system </span></span>
<span class="line"><span style="color:#6F42C1;">NAME</span><span style="color:#24292E;">                      </span><span style="color:#032F62;">HOLDER</span><span style="color:#24292E;">                                              </span><span style="color:#032F62;">AGE</span></span>
<span class="line"><span style="color:#6F42C1;">kube-controller-manager</span><span style="color:#24292E;">   </span><span style="color:#032F62;">k8s-master01_acfa3612-ea75-4d65-bf99-89ae2bcfe3c9</span><span style="color:#24292E;">   </span><span style="color:#005CC5;">11</span><span style="color:#032F62;">d</span></span>
<span class="line"><span style="color:#6F42C1;">kube-scheduler</span><span style="color:#24292E;">            </span><span style="color:#032F62;">k8s-master03_501a1433-ecf5-454a-9f01-5c71e34738d5</span><span style="color:#24292E;">   </span><span style="color:#005CC5;">11</span><span style="color:#032F62;">d</span></span></code></pre></div><h2 id="工作节点组件" tabindex="-1">工作节点组件 <a class="header-anchor" href="#工作节点组件" aria-label="Permalink to &quot;工作节点组件&quot;">​</a></h2><ul><li>Kubelet：负责与Master通信协作，管理该节点上的Pod创建、删除、状态报告等操作，对容器进行健康检查及监控，同时负责上报节点和节点上面Pod的状态给APIServer，APIServer再保存在Etcd中。</li><li>Kube-proxy：负责各Pod之间的通信和负载均衡，将指定的流量分发到后端正确的机器上。</li><li>Runtime：负责容器的管理。</li><li>CoreDNS：用于Kubernetes集群内部Service的解析，可以让Pod把Service名称解析成Service的IP，然后通过Service的IP地址进行连接到对应的应用上。</li><li>Calico：符合CNI标准的一个网络插件，它负责给每个Pod分配一个不会重复的IP，并且把每个节点当做一个“路由器”，这样一个节点的Pod就可以通过IP地址访问到其他节点的Pod。</li></ul>`,78),o=[a];function l(p,c,i,u,b,h){return r(),s("div",null,o)}const k=e(n,[["render",l]]);export{g as __pageData,k as default};
