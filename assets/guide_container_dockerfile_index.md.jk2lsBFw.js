import{_ as e,o as s,c as a,R as o}from"./chunks/framework.zUbWieqp.js";const g=JSON.parse('{"title":"1. 什么是Dockerfile","description":"","frontmatter":{},"headers":[],"relativePath":"guide/container/dockerfile/index.md","filePath":"guide/container/dockerfile/index.md","lastUpdated":1729246382000}'),l={name:"guide/container/dockerfile/index.md"},t=o(`<h1 id="_1-什么是dockerfile" tabindex="-1">1. 什么是Dockerfile <a class="header-anchor" href="#_1-什么是dockerfile" aria-label="Permalink to &quot;1. 什么是Dockerfile&quot;">​</a></h1><p>Dockerfile使用DSL(域特定语言)并包含用于生成Docker映像的指令。Dockerfile将定义快速生成镜像的流程。创建应用程序时，您应该按顺序创建Dockerfile，因为Docker守护进程从上到下运行所有指令.</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202406190946737.png" alt="image-20240619094634927"></p><h1 id="_2-dockerfile基本组成" tabindex="-1">2. Dockerfile基本组成 <a class="header-anchor" href="#_2-dockerfile基本组成" aria-label="Permalink to &quot;2. Dockerfile基本组成&quot;">​</a></h1><p><a href="https://docs.docker.com/reference/dockerfile/" target="_blank" rel="noreferrer">官当</a></p><h2 id="_2-1-基本结构" tabindex="-1">2.1 基本结构 <a class="header-anchor" href="#_2-1-基本结构" aria-label="Permalink to &quot;2.1 基本结构&quot;">​</a></h2><p>Dockerfile 由一行行命令语句组成，并且支持以 <code>#</code> 开头的注释行。</p><p>Dockerfile 分为四部分：<code>基础镜像信息</code>、<code>维护者信息</code>、<code>镜像操作指令</code>和<code>容器启动时执行指令</code></p><h2 id="_2-2-指令" tabindex="-1">2.2 指令 <a class="header-anchor" href="#_2-2-指令" aria-label="Permalink to &quot;2.2 指令&quot;">​</a></h2><table><thead><tr><th style="text-align:left;">Instruction</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#add" target="_blank" rel="noreferrer"><code>ADD</code></a></td><td style="text-align:left;">Add local or remote files and directories.能解压</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#arg" target="_blank" rel="noreferrer"><code>ARG</code></a></td><td style="text-align:left;">Use build-time variables.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#cmd" target="_blank" rel="noreferrer"><code>CMD</code></a></td><td style="text-align:left;">Specify default commands.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#copy" target="_blank" rel="noreferrer"><code>COPY</code></a></td><td style="text-align:left;">复制文件或者目录</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#entrypoint" target="_blank" rel="noreferrer"><code>ENTRYPOINT</code></a></td><td style="text-align:left;">Specify default executable.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#env" target="_blank" rel="noreferrer"><code>ENV</code></a></td><td style="text-align:left;">指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#expose" target="_blank" rel="noreferrer"><code>EXPOSE</code></a></td><td style="text-align:left;">服务端容器暴露的端口号</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#from" target="_blank" rel="noreferrer"><code>FROM</code></a></td><td style="text-align:left;">Create a new build stage from a base image.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#healthcheck" target="_blank" rel="noreferrer"><code>HEALTHCHECK</code></a></td><td style="text-align:left;">Check a container&#39;s health on startup.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#label" target="_blank" rel="noreferrer"><code>LABEL</code></a></td><td style="text-align:left;">Add metadata to an image.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#maintainer-deprecated" target="_blank" rel="noreferrer"><code>MAINTAINER</code></a></td><td style="text-align:left;">指定维护者信息</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#onbuild" target="_blank" rel="noreferrer"><code>ONBUILD</code></a></td><td style="text-align:left;">Specify instructions for when the image is used in a build.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#run" target="_blank" rel="noreferrer"><code>RUN</code></a></td><td style="text-align:left;">Execute build commands.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#shell" target="_blank" rel="noreferrer"><code>SHELL</code></a></td><td style="text-align:left;">Set the default shell of an image.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#stopsignal" target="_blank" rel="noreferrer"><code>STOPSIGNAL</code></a></td><td style="text-align:left;">Specify the system call signal for exiting a container.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#user" target="_blank" rel="noreferrer"><code>USER</code></a></td><td style="text-align:left;">Set user and group ID.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#volume" target="_blank" rel="noreferrer"><code>VOLUME</code></a></td><td style="text-align:left;">Create volume mounts.</td></tr><tr><td style="text-align:left;"><a href="https://docs.docker.com/reference/dockerfile/#workdir" target="_blank" rel="noreferrer"><code>WORKDIR</code></a></td><td style="text-align:left;">Change working directory.</td></tr></tbody></table><h3 id="from" tabindex="-1">FROM <a class="header-anchor" href="#from" aria-label="Permalink to &quot;FROM&quot;">​</a></h3><ul><li>语法</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">FROM &lt;image&gt;:&lt;tag&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">FROM &lt;image&gt;:&lt;tag&gt;</span></span></code></pre></div><h3 id="label" tabindex="-1">LABEL <a class="header-anchor" href="#label" aria-label="Permalink to &quot;LABEL&quot;">​</a></h3><p><code>LABEL</code>一般用来添加镜像的 “元数据” ，没有实际作用。常用于声明镜像作者，<code>licensce</code>等信息，写法为<code>&lt;key&gt;=&lt;value&gt;</code>，语法为</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">LABEL com.example.label-with-value=&quot;foo&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">LABEL version=&quot;1.0&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">LABEL description=&quot;This text illustrates \\</span></span>
<span class="line"><span style="color:#e1e4e8;">that label-values can span multiple lines.&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;</span></span>
<span class="line"><span style="color:#24292e;">LABEL com.example.label-with-value=&quot;foo&quot;</span></span>
<span class="line"><span style="color:#24292e;">LABEL version=&quot;1.0&quot;</span></span>
<span class="line"><span style="color:#24292e;">LABEL description=&quot;This text illustrates \\</span></span>
<span class="line"><span style="color:#24292e;">that label-values can span multiple lines.&quot;</span></span></code></pre></div><ul><li>查看</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"># docker image inspect --format=&#39;&#39; myimage</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;,</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;version&quot;: &quot;1.0&quot;,</span></span>
<span class="line"><span style="color:#e1e4e8;">  &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"># docker image inspect --format=&#39;&#39; myimage</span></span>
<span class="line"><span style="color:#24292e;">{</span></span>
<span class="line"><span style="color:#24292e;">  &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;,</span></span>
<span class="line"><span style="color:#24292e;">  &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span></span>
<span class="line"><span style="color:#24292e;">  &quot;version&quot;: &quot;1.0&quot;,</span></span>
<span class="line"><span style="color:#24292e;">  &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h3 id="workdir" tabindex="-1">WORKDIR <a class="header-anchor" href="#workdir" aria-label="Permalink to &quot;WORKDIR&quot;">​</a></h3><p>格式为 <code>WORKDIR /path/to/workdir</code>。</p><p>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录。</p><p>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">WORKDIR /a</span></span>
<span class="line"><span style="color:#9ECBFF;">WORKDIR b</span></span>
<span class="line"><span style="color:#9ECBFF;">WORKDIR c</span></span>
<span class="line"><span style="color:#9ECBFF;">RUN pwd</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">WORKDIR /a</span></span>
<span class="line"><span style="color:#032F62;">WORKDIR b</span></span>
<span class="line"><span style="color:#032F62;">WORKDIR c</span></span>
<span class="line"><span style="color:#032F62;">RUN pwd</span></span></code></pre></div><p>则最终路径为 <code>/a/b/c</code></p><h3 id="env" tabindex="-1">ENV <a class="header-anchor" href="#env" aria-label="Permalink to &quot;ENV&quot;">​</a></h3><p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code>。 指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">ENV</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">PG_MAJOR</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">9.3</span></span>
<span class="line"><span style="color:#B392F0;">ENV</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">PG_VERSION</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">9.3</span><span style="color:#9ECBFF;">.4</span></span>
<span class="line"><span style="color:#B392F0;">RUN</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">curl</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-SL</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">http://example.com/postgres-</span><span style="color:#E1E4E8;">$PG_VERSION</span><span style="color:#9ECBFF;">.tar.xz</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">tar</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-xJC</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">/usr/src/postgress</span><span style="color:#E1E4E8;"> &amp;&amp; </span><span style="color:#B392F0;">…</span></span>
<span class="line"><span style="color:#B392F0;">ENV</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">PATH</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">/usr/local/postgres-</span><span style="color:#E1E4E8;">$PG_MAJOR</span><span style="color:#9ECBFF;">/bin:</span><span style="color:#E1E4E8;">$PATH</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">ENV</span><span style="color:#24292E;"> </span><span style="color:#032F62;">PG_MAJOR</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">9.3</span></span>
<span class="line"><span style="color:#6F42C1;">ENV</span><span style="color:#24292E;"> </span><span style="color:#032F62;">PG_VERSION</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">9.3</span><span style="color:#032F62;">.4</span></span>
<span class="line"><span style="color:#6F42C1;">RUN</span><span style="color:#24292E;"> </span><span style="color:#032F62;">curl</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-SL</span><span style="color:#24292E;"> </span><span style="color:#032F62;">http://example.com/postgres-</span><span style="color:#24292E;">$PG_VERSION</span><span style="color:#032F62;">.tar.xz</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tar</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-xJC</span><span style="color:#24292E;"> </span><span style="color:#032F62;">/usr/src/postgress</span><span style="color:#24292E;"> &amp;&amp; </span><span style="color:#6F42C1;">…</span></span>
<span class="line"><span style="color:#6F42C1;">ENV</span><span style="color:#24292E;"> </span><span style="color:#032F62;">PATH</span><span style="color:#24292E;"> </span><span style="color:#032F62;">/usr/local/postgres-</span><span style="color:#24292E;">$PG_MAJOR</span><span style="color:#032F62;">/bin:</span><span style="color:#24292E;">$PATH</span></span></code></pre></div><h3 id="add" tabindex="-1">ADD <a class="header-anchor" href="#add" aria-label="Permalink to &quot;ADD&quot;">​</a></h3><ul><li>语法</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span>
<span class="line"><span style="color:#24292e;">ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></code></pre></div><p>该命令将复制指定的 <code>&lt;src&gt;</code> 到容器中的 <code>&lt;dest&gt;</code>。 其中 <code>&lt;src&gt;</code> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）</p><h3 id="copy" tabindex="-1">COPY <a class="header-anchor" href="#copy" aria-label="Permalink to &quot;COPY&quot;">​</a></h3><ul><li>语法</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span>
<span class="line"><span style="color:#24292e;">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></code></pre></div><p>复制本地主机的 <code>&lt;src&gt;</code>（为 Dockerfile 所在目录的相对路径）到容器中的 <code>&lt;dest&gt;</code>。</p><p>当使用本地目录为源目录时，推荐使用 <code>COPY</code></p><h3 id="run" tabindex="-1">RUN <a class="header-anchor" href="#run" aria-label="Permalink to &quot;RUN&quot;">​</a></h3><ul><li>在<code>RUN</code>指令执行过程中，产生的中间镜像会被当做缓存在下一次构建时使用，如果不想使用缓存，使其失效，可以在<code>build</code>时添加<code>--no-cache</code></li><li>尽量把所有的<code>RUN</code>指令写到一起，如果是多条<code>shell</code>命令，可以不用每条命令都添加<code>RUN</code>，更好的做法是通过<code>\\</code>换行，通过<code>&amp;&amp;</code>连接多个指令，这样对构建生成的镜像的大小优化是很有帮助的，语法为</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">RUN set -x &amp;&amp; \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    yum install -y epel-release \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    make \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    gcc \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    gcc-c++</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">RUN set -x &amp;&amp; \\</span></span>
<span class="line"><span style="color:#24292e;">    yum install -y epel-release \\</span></span>
<span class="line"><span style="color:#24292e;">    make \\</span></span>
<span class="line"><span style="color:#24292e;">    gcc \\</span></span>
<span class="line"><span style="color:#24292e;">    gcc-c++</span></span></code></pre></div><h3 id="expose" tabindex="-1">EXPOSE <a class="header-anchor" href="#expose" aria-label="Permalink to &quot;EXPOSE&quot;">​</a></h3><p>EXPOSE<code>指令声明了容器在运行时监听指定的网络端口，可以指定端口是监听</code>TCP<code>还是</code>UDP<code>，默认为</code>TCP</p><p><code>EXPOSE</code>指令实际上并不发布端口，即端口限制，它的作用仅仅是作为构建映像的人和运行容器的人之间的一种文档，关于要发布哪些端口。当运行容器时，要实际发布端口，使用<code>docker</code>运行中的-<code>p</code>参数来发布和映射一个或多个端口，或者直接使用<code>-P</code>来自动随机映射<code>EXPOSE</code>声明的端口</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span></span></code></pre></div><h3 id="cmd" tabindex="-1">CMD <a class="header-anchor" href="#cmd" aria-label="Permalink to &quot;CMD&quot;">​</a></h3><p>支持三种格式</p><ul><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> 使用 <code>exec</code> 执行，推荐方式；</li><li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</li></ul><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 <code>CMD</code> 命令。如果指定了多条命令，只有最后一条会被执行。</p><p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令</p><h3 id="entrypoint" tabindex="-1">ENTRYPOINT <a class="header-anchor" href="#entrypoint" aria-label="Permalink to &quot;ENTRYPOINT&quot;">​</a></h3><p>两种格式：</p><ul><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> # exec格式,推荐使用</li><li><code>ENTRYPOINT command param1 param2</code>（shell中执行）。</li></ul><p>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。</p><p>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code>，当指定多个时，只有最后一个起效</p><p>这两种不同的格式有一个很大的区别在于：<code>exec</code>格式可以接受参数，而<code>shell</code>格式是会忽略参数的。<code>shell</code>格式相当于在前面还要再添加<code>/bin/sh -c</code>，所以app启动的进程ID不是1。</p><h3 id="覆盖entrypoint与cmd" tabindex="-1">覆盖<code>Entrypoint</code>与<code>Cmd</code> <a class="header-anchor" href="#覆盖entrypoint与cmd" aria-label="Permalink to &quot;覆盖\`Entrypoint\`与\`Cmd\`&quot;">​</a></h3><p>如果要覆盖默认的<code>Entrypoint</code>与<code>Cmd</code>，需要遵循如下规则：</p><ul><li>如果在容器配置中没有设置 <code>command</code> 或者 <code>args</code>，那么将使用<code>Docker</code>镜像自带的命令及其参数</li><li>如果在容器配置中只设置了 <code>command</code> 但是没有设置 <code>args</code>，那么容器启动时只会执行该命令， <code>Docker</code>镜像中自带的命令及其参数会被忽略</li><li>如果在容器配置中只设置了 <code>args</code>，那么<code>Docker</code>镜像中自带的命令会使用该新参数作为其执行时的参数</li><li>如果在容器配置中同时设置了 <code>command</code> 与 <code>args</code>，那么<code>Docker</code>镜像中自带的命令及其参数会被忽略。 容器启动时只会执行配置中设置的命令，并使用配置中设置的参数作为命令的参数</li></ul><table><thead><tr><th>镜像 Entrypoint</th><th>镜像 Cmd</th><th>容器 command</th><th>容器 args</th><th>命令执行</th></tr></thead><tbody><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td></td><td></td><td><code>[ep-1 foo bar]</code></td></tr><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td><code>[/ep-2]</code></td><td></td><td><code>[ep-2]</code></td></tr><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td></td><td><code>[zoo boo]</code></td><td><code>[ep-1 zoo boo]</code></td></tr><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td><code>[/ep-2]</code></td><td><code>[zoo boo]</code></td><td><code>[ep-2 zoo boo]</code></td></tr></tbody></table><h2 id="_2-3-镜像启动" tabindex="-1">2.3 镜像启动 <a class="header-anchor" href="#_2-3-镜像启动" aria-label="Permalink to &quot;2.3 镜像启动&quot;">​</a></h2><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像。</p><p>基本的格式为 <code>docker build [选项] 路径</code>，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 <code>.dockerignore</code> 文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker build -t images:v1 .</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker build -t images:v1 .</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">❌ 注意</p><p>exec 格式的 ENTRYPOINT 或 CMD 就是它们实际在 docker 镜像中的样子，可用 docker inspect image 查看</p><p><code>exec 格式是一种数组形式</code>，该格式的 ENTRYPOINT 能接收 CMD 或 dock run image 后的参数作为附加参数，相当于是往这个数组中附加元素。</p><p>ENTRYPOINT [&quot;echo&quot;, &quot;Hello&quot;]</p><p>docker run test World and China</p><p>输出</p><p>Hello World and China</p><p>shell 格式可用变量而 exec 格式不一定行</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ENTRYPOINT java $JAVA_OPTS -jar /app.jar</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">docker run -e JAVA_OPTS=&quot;-Xms2G&quot; test</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ENTRYPOINT java $JAVA_OPTS -jar /app.jar</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">docker run -e JAVA_OPTS=&quot;-Xms2G&quot; test</span></span></code></pre></div><p>exec 格式的写法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ENTRYPOINT [&quot;java&quot;, &quot;$JAVA_OPTS&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">docker run -e JAVA_OPTS=&quot;-Xms2G&quot; test</span></span>
<span class="line"><span style="color:#e1e4e8;">Error: Could not find or load main class $JAVA_OPTS</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ENTRYPOINT [&quot;java&quot;, &quot;$JAVA_OPTS&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">docker run -e JAVA_OPTS=&quot;-Xms2G&quot; test</span></span>
<span class="line"><span style="color:#24292e;">Error: Could not find or load main class $JAVA_OPTS</span></span></code></pre></div></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">FROM debian:11</span></span>
<span class="line"><span style="color:#e1e4e8;">ENV TIME_ZOME Asia/Shanghai</span></span>
<span class="line"><span style="color:#e1e4e8;">ENV LANG en_US.utf8</span></span>
<span class="line"><span style="color:#e1e4e8;">ENV DOTNET_ROOT /usr/local/dotnet</span></span>
<span class="line"><span style="color:#e1e4e8;">ENV PATH $PATH:$DOTNET_ROOT</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">ADD dotnet-sdk-8.0.100-linux-x64.tar.gz /usr/local/dotnet</span></span>
<span class="line"><span style="color:#e1e4e8;">ADD node-v16.20.2-linux-x64.tar.gz /usr/local</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">COPY [&quot;sources.list&quot;, &quot;/etc/apt&quot;]</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">RUN echo &quot;\${TIME_ZOME}&quot; &gt; /etc/timezone &amp;&amp; \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    ln -sf /usr/share/zoneinfo/\${TIME_ZOME} /etc/localtime &amp;&amp; \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    ln -sf /usr/local/node-v16.20.2-linux-x64/bin/node /usr/local/bin &amp;&amp; \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    ln -sf /usr/local/node-v16.20.2-linux-x64/bin/npm /usr/local/bin &amp;&amp; \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    apt update &amp;&amp; \\ </span></span>
<span class="line"><span style="color:#e1e4e8;">    apt -y install net-tools libicu-dev &amp;&amp; \\</span></span>
<span class="line"><span style="color:#e1e4e8;">    apt clean</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">FROM debian:11</span></span>
<span class="line"><span style="color:#24292e;">ENV TIME_ZOME Asia/Shanghai</span></span>
<span class="line"><span style="color:#24292e;">ENV LANG en_US.utf8</span></span>
<span class="line"><span style="color:#24292e;">ENV DOTNET_ROOT /usr/local/dotnet</span></span>
<span class="line"><span style="color:#24292e;">ENV PATH $PATH:$DOTNET_ROOT</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">ADD dotnet-sdk-8.0.100-linux-x64.tar.gz /usr/local/dotnet</span></span>
<span class="line"><span style="color:#24292e;">ADD node-v16.20.2-linux-x64.tar.gz /usr/local</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">COPY [&quot;sources.list&quot;, &quot;/etc/apt&quot;]</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">RUN echo &quot;\${TIME_ZOME}&quot; &gt; /etc/timezone &amp;&amp; \\</span></span>
<span class="line"><span style="color:#24292e;">    ln -sf /usr/share/zoneinfo/\${TIME_ZOME} /etc/localtime &amp;&amp; \\</span></span>
<span class="line"><span style="color:#24292e;">    ln -sf /usr/local/node-v16.20.2-linux-x64/bin/node /usr/local/bin &amp;&amp; \\</span></span>
<span class="line"><span style="color:#24292e;">    ln -sf /usr/local/node-v16.20.2-linux-x64/bin/npm /usr/local/bin &amp;&amp; \\</span></span>
<span class="line"><span style="color:#24292e;">    apt update &amp;&amp; \\ </span></span>
<span class="line"><span style="color:#24292e;">    apt -y install net-tools libicu-dev &amp;&amp; \\</span></span>
<span class="line"><span style="color:#24292e;">    apt clean</span></span></code></pre></div><h1 id="_3-自特点缺点" tabindex="-1">3. 自特点缺点 <a class="header-anchor" href="#_3-自特点缺点" aria-label="Permalink to &quot;3. 自特点缺点&quot;">​</a></h1><p>exec 格式要求一个坑一个参数，所以像上面见到的那样无法在中间动态插入参数，比如不能在中间某一个位置上写上 &quot;-Xmx5G -Xms2G&quot;, 这分明是两个参数，只能在后面附加参数</p><p>shell 格式由于命令总是由 &quot;/bin/sh -e&quot; 启动的子进程，它不是 PID 1 超级进程，从而无法收到 Unix 的信号，自然不能收到从 <code>docker stop &lt;container&gt;</code> 发来的 <code>SIGTERM</code> 信号。</p><p>简述一下 <code>docker stop &lt;container&gt;</code> 工作原理，它向容器中的 PID 为 1 进程发送 SIGTERM 信号，并给予 10 秒钟(可用参数 --time) 清理，超时才 -9 强杀，这样可以比较优雅的关闭容器。&quot;/bin/sh -e&quot; 是一个 PID 1 进程，它收到了 SIGTERM 却不会转发给它的子命令，这样就造成了 &quot;/bin/sh -e&quot; 收到 SIGTERM 未作响应被强杀，同时把它的子进程毫无征兆的干掉了。像在 Java 中用 <code>Runtime.addShutdownHook() </code>是捕获不到该信号的。</p><h1 id="_4-增强型shell格式" tabindex="-1">4. 增强型shell格式 <a class="header-anchor" href="#_4-增强型shell格式" aria-label="Permalink to &quot;4. 增强型shell格式&quot;">​</a></h1><p>这里补充一种 ENTRYPOINT 的声明格式，它实质是 shell 格式，为而把它单独列出来关键就在于 shell 的 <code>exec</code> 命令。此 <code>exec</code> 非前面 exec 格式中的 exec, 而是一个结结实实的 shell 命令。</p><blockquote><p>ENTRYPOINT exec command param1 param2 ...</p></blockquote><p>比如：</p><blockquote><p>ENTRYPOINT exec java $JAVA_OPTS -jar /app.jar</p></blockquote><p>它仍然是 shell 格式，所以 inspect 镜像后看到的 ENTRYPOINT 是</p><blockquote><p>ENTRYPOINT [&quot;/bin/sh&quot;, &quot;-c&quot; &quot;exec java $JAVA_OPTS -jar /app.jar&quot;]</p></blockquote><p>然而加了 <code>exec</code> 的绝妙之处在于：</p><p>shell 的内建命令 exec 将并不启动新的shell，而是用要被执行命令替换当前的 shell 进程，并且将老进程的环境清理掉，exec 后的命令不再是 shell 的子进程序，而且 exec 命令后的其它命令将不再执行。从执行效果上可以看到 exec 会把当前的 shell 关闭掉，直接启动它后面的命令。</p><p>虽然它与之后的命令(如上 <code>exec java $JAVA_OPTS -jar /app.jar</code>）还是作为 &quot;/bin/sh&quot; 的第二个参数，但 <code>exec</code> 来了个金蝉脱壳，让这里的 <code>java</code> 进程得已作为一个 PID 1 的超级进程，进行使得这个 java 进程可以收到 SIGTERM 信号。或者理解 <code>exec</code> 为 &quot;/bin/sh&quot; 的子进程，但是借助于 <code>exec</code> 让它后面的进程启动在最顶端。</p><p>另外，由于通过 &quot;/bin/sh&quot; 的搭桥，命令中的变量(如 $JAVA_OPTS) 也会被正确解析，因此 <code>ENTRYPOINT exec command param1 param2 ...</code> 是被推荐的格式。</p><p>注意：exec 只会启动后面的第一个命令，<code>exec ls; top</code> 或 <code>exec ls &amp;&amp; top</code> 只会执行 <code>ls</code> 命令</p>`,80),n=[t];function c(p,r,d,i,u,h){return s(),a("div",null,n)}const m=e(l,[["render",c]]);export{g as __pageData,m as default};
