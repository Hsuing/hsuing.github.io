import{_ as s,o as a,c as n,R as e}from"./chunks/framework.zUbWieqp.js";const _=JSON.parse('{"title":"1. redis的主从复制","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Database/Redis/4-masterslave.md","filePath":"guide/Database/Redis/4-masterslave.md","lastUpdated":1720533756000}'),l={name:"guide/Database/Redis/4-masterslave.md"},p=e(`<h1 id="_1-redis的主从复制" tabindex="-1">1. redis的主从复制 <a class="header-anchor" href="#_1-redis的主从复制" aria-label="Permalink to &quot;1. redis的主从复制&quot;">​</a></h1><ol><li>使用异步复制。</li><li>一个主服务器可以有多个从服务器。</li><li>从服务器也可以有自己的从服务器。</li><li>复制功能不会阻塞主服务器。</li><li>可以通过复制功能来让主服务器免于执行持久化操作，由从服务器去执行持久化操作即可</li></ol><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202406181536335.png" alt="1"></p><h2 id="_1-1-redis-复制功能的几个重要方面" tabindex="-1">1.1 Redis 复制功能的几个重要方面 <a class="header-anchor" href="#_1-1-redis-复制功能的几个重要方面" aria-label="Permalink to &quot;1.1 Redis 复制功能的几个重要方面&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">• Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 一个主服务器可以有多个从服务器。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 复制功能也不会阻塞从服务器： 只要在 redis.conf 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 SORT 命令可以交给附属节点去运行。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">• Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</span></span>
<span class="line"><span style="color:#24292e;">• 一个主服务器可以有多个从服务器。</span></span>
<span class="line"><span style="color:#24292e;">• 不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</span></span>
<span class="line"><span style="color:#24292e;">• 复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</span></span>
<span class="line"><span style="color:#24292e;">• 复制功能也不会阻塞从服务器： 只要在 redis.conf 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</span></span>
<span class="line"><span style="color:#24292e;">• 不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</span></span>
<span class="line"><span style="color:#24292e;">• 你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</span></span>
<span class="line"><span style="color:#24292e;">• 复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 SORT 命令可以交给附属节点去运行。</span></span>
<span class="line"><span style="color:#24292e;">• 可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可</span></span></code></pre></div><h2 id="_1-2-关闭主服务器持久化-复制功能数据更安全" tabindex="-1">1.2 关闭主服务器持久化，复制功能数据更安全 <a class="header-anchor" href="#_1-2-关闭主服务器持久化-复制功能数据更安全" aria-label="Permalink to &quot;1.2 关闭主服务器持久化，复制功能数据更安全&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">• 当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</span></span>
<span class="line"><span style="color:#e1e4e8;">• 1. 假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</span></span>
<span class="line"><span style="color:#e1e4e8;">• 2. 节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</span></span>
<span class="line"><span style="color:#e1e4e8;">• 3. 节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</span></span>
<span class="line"><span style="color:#e1e4e8;">• 无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">• 当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</span></span>
<span class="line"><span style="color:#24292e;">• 为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</span></span>
<span class="line"><span style="color:#24292e;">• 1. 假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</span></span>
<span class="line"><span style="color:#24292e;">• 2. 节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</span></span>
<span class="line"><span style="color:#24292e;">• 3. 节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</span></span>
<span class="line"><span style="color:#24292e;">• 在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</span></span>
<span class="line"><span style="color:#24292e;">• 无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起</span></span></code></pre></div><h1 id="_2-主从复制的原理" tabindex="-1">2. 主从复制的原理 <a class="header-anchor" href="#_2-主从复制的原理" aria-label="Permalink to &quot;2. 主从复制的原理&quot;">​</a></h1><ol><li>从服务器向主服务器发送 SYNC 命令。</li><li>接到 SYNC 命令的主服务器会调用BGSAVE 命令，创建一个 RDB 文件，并使用缓冲区记录接下来执行的所有写命令。</li><li>当主服务器执行完 BGSAVE 命令时，它会向从服务器发送 RDB 文件，而从服务器则会接收并载入这个文件。</li><li>主服务器将缓冲区储存的所有写命令发送给从服务器执行</li></ol><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202406181536767.png" alt="1"></p><h2 id="_2-1-命令传播" tabindex="-1">2.1 命令传播 <a class="header-anchor" href="#_2-1-命令传播" aria-label="Permalink to &quot;2.1 命令传播&quot;">​</a></h2><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202406181535175.png" alt="1"></p><h2 id="_2-2-复制的一致性问题" tabindex="-1">2.2 复制的一致性问题 <a class="header-anchor" href="#_2-2-复制的一致性问题" aria-label="Permalink to &quot;2.2 复制的一致性问题&quot;">​</a></h2><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202406181536939.png" alt="1"></p><ol><li>在读写分离环境下，客户端向主服务器发送写命令 SET n 10086，主服务器在执行这个写命令之后，向客户端返回回复，并将这个写命令传播给从服务器。</li><li>接到回复的客户端继续向从服务器发送读命令 GET n ，并且因为网络状态的原因，客户端的 GET命令比主服务器传播的 SET 命令更快到达了从服务器。</li><li>因为从服务器键 n 的值还未被更新，所以客户端在从服务器读取到的将是一个错误（过期）的 n值</li></ol>`,15),i=[p];function o(t,c,r,d,h,y){return a(),n("div",null,i)}const g=s(l,[["render",o]]);export{_ as __pageData,g as default};
