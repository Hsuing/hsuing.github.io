import{_ as s,o as a,c as o,R as e}from"./chunks/framework.zUbWieqp.js";const h=JSON.parse('{"title":"1. PromQL 操作符","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/Monitor/Prometheus/4-promql_operator.md","filePath":"guide/Linux/Monitor/Prometheus/4-promql_operator.md","lastUpdated":1736763438000}'),l={name:"guide/Linux/Monitor/Prometheus/4-promql_operator.md"},t=e(`<h1 id="_1-promql-操作符" tabindex="-1">1. PromQL 操作符 <a class="header-anchor" href="#_1-promql-操作符" aria-label="Permalink to &quot;1. PromQL 操作符&quot;">​</a></h1><p><a href="https://prometheus.io/docs/prometheus/2.55/querying/operators/" target="_blank" rel="noreferrer">官当</a></p><p>Prometheus 的查询语言支持基本的逻辑和算术运算符。对于两个即时向量之间的运算，<a href="https://prometheus.io/docs/prometheus/2.55/querying/operators/#vector-matching" target="_blank" rel="noreferrer">匹配行为</a> 可以修改</p><h2 id="_1-1-二元操作符" tabindex="-1">1.1 二元操作符 <a class="header-anchor" href="#_1-1-二元操作符" aria-label="Permalink to &quot;1.1 二元操作符&quot;">​</a></h2><p>PromQL 的二元操作符支持基本的逻辑和算术运算，包含<strong>算术类</strong>、<strong>比较类</strong>和<strong>逻辑类</strong>三大类</p><h3 id="_1-算术类二元操作符" tabindex="-1">1.算术类二元操作符 <a class="header-anchor" href="#_1-算术类二元操作符" aria-label="Permalink to &quot;1.算术类二元操作符&quot;">​</a></h3><p>算术类二元操作符有以下几种：</p><ul><li><code>+</code>：加</li><li><code>-</code>：减</li><li><code>*</code>：乘</li><li><code>/</code>：除</li><li><code>%</code>：求余</li><li><code>^</code>：乘方或者求幂</li></ul><p>算术类二元操作符可以使用在标量与标量、向量与标量，以及向量与向量之间。</p><p>比如：标量与标量</p><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031431511.png" alt="image-20250103143128927"></p><p>比如：即时向量与标量</p><p>计算内存</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_memory_MemTotal_bytes/(1024*1024)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_memory_MemTotal_bytes/(1024*1024)</span></span></code></pre></div><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031433914.png" alt="image-20250103143316413"></p><p>比如：向量和向量</p><p>获取内存使用率</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_memory_Active_bytes / node_memory_MemTotal_bytes * 100</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_memory_Active_bytes / node_memory_MemTotal_bytes * 100</span></span></code></pre></div><p><img src="https://nnaigos.oss-cn-hangzhou.aliyuncs.com/imgs/202501031438454.png" alt="image-20250103143803346"></p><p><strong>二元操作符上下文里的向量特指瞬时向量，不包括区间向量。</strong></p><ul><li>标量与标量之间，结果很明显，跟通常的算术运算一致。</li><li>向量与标量之间，相当于把标量跟向量里的每一个标量进行运算，这些计算结果组成了一个新的向量。</li><li>向量与向量之间，会稍微麻烦一些。运算的时候首先会为左边向量里的每一个元素在右边向量里去寻找一个匹配元素（匹配规则后面会讲），然后对这两个匹配元素执行计算，这样每对匹配元素的计算结果组成了一个新的向量。如果没有找到匹配元素，则该元素丢弃。</li></ul><h3 id="_2-比较类二元操作符" tabindex="-1">2.比较类二元操作符 <a class="header-anchor" href="#_2-比较类二元操作符" aria-label="Permalink to &quot;2.比较类二元操作符&quot;">​</a></h3><p>比较类二元操作符有以下几种：</p><ul><li><code>==</code> (equal)</li><li><code>!=</code> (not-equal)</li><li><code>&gt;</code> (greater-than)</li><li><code>&lt;</code> (less-than)</li><li><code>&gt;=</code> (greater-or-equal)</li><li><code>&lt;=</code> (less-or-equal)</li></ul><p>比较类二元操作符同样可以使用在标量与标量、向量与标量，以及向量与向量之间。默认执行的是过滤，也就是保留值。</p><p>也可以通过在运算符后面跟 bool 修饰符来使得返回值 0 和 1，而不是过滤。</p><ul><li>标量与标量之间，必须跟 bool 修饰符，因此结果只可能是 0（false） 或 1（true）。</li><li>向量与标量之间，相当于把向量里的每一个标量跟标量进行比较，结果为真则保留，否则丢弃。如果后面跟了 bool 修饰符，则结果分别为 1 和 0。</li><li>向量与向量之间，运算过程类似于算术类操作符，只不过如果比较结果为真则保留左边的值（包括度量指标和标签这些属性），否则丢弃，没找到匹配也是丢弃。如果后面跟了 bool 修饰符，则保留和丢弃时结果相应为 1 和 0。</li></ul><p>比如：标量与标量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">12 &gt; bool 10</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">12 &gt; bool 10</span></span></code></pre></div><p>比如：即时向量与标量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_load1 &gt; bool 1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_load1 &gt; bool 1</span></span></code></pre></div><p>比如：向量与向量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_memory_MemAvailable_bytes &gt; bool node_memory_MemTotal_bytes</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_memory_MemAvailable_bytes &gt; bool node_memory_MemTotal_bytes</span></span></code></pre></div><h3 id="_3-逻辑类二元操作符" tabindex="-1">3.逻辑类二元操作符 <a class="header-anchor" href="#_3-逻辑类二元操作符" aria-label="Permalink to &quot;3.逻辑类二元操作符&quot;">​</a></h3><p>逻辑操作符仅用于向量与向量之间。</p><ul><li><code>and</code>：交集</li><li><code>or</code>：合集</li><li><code>unless</code>：补集</li></ul><p>具体运算规则如下：</p><ul><li><code>vector1 and vector2</code> 的结果由在 vector2 里有匹配（标签键值对组合相同）元素的 vector1 里的元素组成。</li><li><code>vector1 or vector2</code> 的结果由所有 vector1 里的元素加上在 vector1 里没有匹配（标签键值对组合相同）元素的 vector2 里的元素组成。</li><li><code>vector1 unless vector2</code> 的结果由在 vector2 里没有匹配（标签键值对组合相同）元素的 vector1 里的元素组成。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_cpu_seconds_total{mode=~&quot;idle|user&quot;} and node_cpu_seconds_total{mode=~&quot;system|user&quot;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_cpu_seconds_total{mode=~&quot;idle|user&quot;} and node_cpu_seconds_total{mode=~&quot;system|user&quot;}</span></span></code></pre></div><h3 id="_4-二元操作符优先级" tabindex="-1">4.二元操作符优先级 <a class="header-anchor" href="#_4-二元操作符优先级" aria-label="Permalink to &quot;4.二元操作符优先级&quot;">​</a></h3><p>PromQL 的各类二元操作符运算优先级如下：</p><ol><li><code>^</code></li><li><code>*, /, %</code></li><li><code>+, -</code></li><li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li><li><code>and, unless</code>-&gt;逻辑运算</li><li><code>or</code>-&gt;逻辑运算</li></ol><h5 id="and" tabindex="-1">and <a class="header-anchor" href="#and" aria-label="Permalink to &quot;and&quot;">​</a></h5><p>and逻辑运算会产生一个由vector1的元素组成的新的向量。该向量包含vector1中完全匹配vector2中的元素。表达式示例如下：<code>当多个条件被同时满足时进行显示</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_filesystem_size_bytes{fstype!=&quot;tmpfs&quot;} and node_filesystem_size_bytes != 0 and node_filesystem_size_bytes{mountpoint=&quot;/root-disk&quot;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_filesystem_size_bytes{fstype!=&quot;tmpfs&quot;} and node_filesystem_size_bytes != 0 and node_filesystem_size_bytes{mountpoint=&quot;/root-disk&quot;}</span></span></code></pre></div><h5 id="or" tabindex="-1">or <a class="header-anchor" href="#or" aria-label="Permalink to &quot;or&quot;">​</a></h5><p>or逻辑运算会产生一个新的向量，该向量包含vector1的所有原始元素（标签集+值）的向量，以及vector2中没有与vector1匹配标签集的所有元素。假设判断node_test_metric指标是否存在，如果指标不存在则返回0。在这种情况下，我们可以使用与每个目标关联的up指标进行表达式操作：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">node_filesystem_avail_bytes &gt; 200000 or node_filesystem_avail_bytes &lt; 2500000</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">node_filesystem_avail_bytes &gt; 200000 or node_filesystem_avail_bytes &lt; 2500000</span></span></code></pre></div><h5 id="unless" tabindex="-1">unless <a class="header-anchor" href="#unless" aria-label="Permalink to &quot;unless&quot;">​</a></h5><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">#当第一个值的标签和第二个值的标签不匹配的情况下会输出</span></span>
<span class="line"><span style="color:#e1e4e8;">up{instance=&quot;192.168.1.20:9100&quot;,job=&quot;node&quot;} unless up{instance=&quot;192.168.1.21:9100&quot;,job=&quot;node&quot;}</span></span>
<span class="line"><span style="color:#e1e4e8;"> </span></span>
<span class="line"><span style="color:#e1e4e8;">#当标签相同时则不输出</span></span>
<span class="line"><span style="color:#e1e4e8;">up{instance=&quot;192.168.1.20:9100&quot;,job=&quot;node&quot;} unless up{instance=&quot;192.168.1.20:9100&quot;,job=&quot;node&quot;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">#当第一个值的标签和第二个值的标签不匹配的情况下会输出</span></span>
<span class="line"><span style="color:#24292e;">up{instance=&quot;192.168.1.20:9100&quot;,job=&quot;node&quot;} unless up{instance=&quot;192.168.1.21:9100&quot;,job=&quot;node&quot;}</span></span>
<span class="line"><span style="color:#24292e;"> </span></span>
<span class="line"><span style="color:#24292e;">#当标签相同时则不输出</span></span>
<span class="line"><span style="color:#24292e;">up{instance=&quot;192.168.1.20:9100&quot;,job=&quot;node&quot;} unless up{instance=&quot;192.168.1.20:9100&quot;,job=&quot;node&quot;}</span></span></code></pre></div><h2 id="_1-2-向量匹配" tabindex="-1">1.2 向量匹配 <a class="header-anchor" href="#_1-2-向量匹配" aria-label="Permalink to &quot;1.2 向量匹配&quot;">​</a></h2><p>算术类和比较类操作符都需要在向量之间进行匹配。共有两种匹配类型，<code>one-to-one</code> 和 <code>many-to-one</code> / <code>one-to-many</code></p><h3 id="_1-one-to-one-向量匹配" tabindex="-1">1.One-to-one 向量匹配 <a class="header-anchor" href="#_1-one-to-one-向量匹配" aria-label="Permalink to &quot;1.One-to-one 向量匹配&quot;">​</a></h3><p>这种匹配模式下，两边向量里的元素如果其标签键值对组合相同则为匹配，并且只会有一个匹配元素。可以使用 <code>ignoring</code> 关键词来忽略不参与匹配的标签，或者使用 <code>on</code> 关键词来指定要参与匹配的标签。语法如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">vector expr</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">bin-op</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> ignoring(</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">label list</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">vector expr</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">vector expr</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">bin-op</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> on(</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">label list</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">vector expr</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">vector expr</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">bin-op</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> ignoring(</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">label list</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">vector expr</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">vector expr</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">bin-op</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> on(</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">label list</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">vector expr</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><p>比如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">process_open_fds</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;10.103.236.199&quot;</span><span style="color:#B392F0;">,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">job=&quot;node-exporter-10.103.236.199&quot;}</span><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#B392F0;">/</span></span>
<span class="line"><span style="color:#B392F0;">process_max_fds</span><span style="color:#E1E4E8;">{instance=</span><span style="color:#B392F0;">&quot;10.103.236.199&quot;</span><span style="color:#B392F0;">,</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">job=&quot;node-exporter-10.103.236.199&quot;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">process_open_fds</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;10.103.236.199&quot;</span><span style="color:#6F42C1;">,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">job=&quot;node-exporter-10.103.236.199&quot;}</span><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#6F42C1;">/</span></span>
<span class="line"><span style="color:#6F42C1;">process_max_fds</span><span style="color:#24292E;">{instance=</span><span style="color:#6F42C1;">&quot;10.103.236.199&quot;</span><span style="color:#6F42C1;">,</span><span style="color:#24292E;"> </span><span style="color:#032F62;">job=&quot;node-exporter-10.103.236.199&quot;}</span></span></code></pre></div><p>比如：ignoring</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">node_disk_read_time_seconds_total</span><span style="color:#E1E4E8;">{device=</span><span style="color:#B392F0;">&quot;nvme0n1&quot;</span><span style="color:#B392F0;">}</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">ignoring</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">device</span><span style="color:#E1E4E8;">) </span><span style="color:#9ECBFF;">node_disk_read_time_seconds_total{device=&quot;dm-0&quot;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">node_disk_read_time_seconds_total</span><span style="color:#24292E;">{device=</span><span style="color:#6F42C1;">&quot;nvme0n1&quot;</span><span style="color:#6F42C1;">}</span><span style="color:#24292E;"> </span><span style="color:#032F62;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">ignoring</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">device</span><span style="color:#24292E;">) </span><span style="color:#032F62;">node_disk_read_time_seconds_total{device=&quot;dm-0&quot;}</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">💡 说明</p><p>记住一句话两个向量之间做运算必须两边的标签名和标签值必须匹配才能做计算</p></div><p>比如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">#表达式中使用到了rate()函数，即计算某个时间序列范围内的平均增长率</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">sum</span><span style="color:#E1E4E8;"> (rate(node_cpu_seconds_total{mode</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;idle&quot;}[</span><span style="color:#79B8FF;">5</span><span style="color:#9ECBFF;">m]</span><span style="color:#E1E4E8;">)) </span><span style="color:#B392F0;">by</span><span style="color:#E1E4E8;"> (instance) / sum (</span><span style="color:#B392F0;">rate(node_cpu_seconds_total[5m]</span><span style="color:#E1E4E8;">)) by (</span><span style="color:#B392F0;">instance</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">#表达式中使用到了rate()函数，即计算某个时间序列范围内的平均增长率</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">sum</span><span style="color:#24292E;"> (rate(node_cpu_seconds_total{mode</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;idle&quot;}[</span><span style="color:#005CC5;">5</span><span style="color:#032F62;">m]</span><span style="color:#24292E;">)) </span><span style="color:#6F42C1;">by</span><span style="color:#24292E;"> (instance) / sum (</span><span style="color:#6F42C1;">rate(node_cpu_seconds_total[5m]</span><span style="color:#24292E;">)) by (</span><span style="color:#6F42C1;">instance</span><span style="color:#24292E;">)</span></span></code></pre></div><h3 id="_2-many-to-one-one-to-many-向量匹配" tabindex="-1">2.Many-to-one / one-to-many 向量匹配 <a class="header-anchor" href="#_2-many-to-one-one-to-many-向量匹配" aria-label="Permalink to &quot;2.Many-to-one / one-to-many 向量匹配&quot;">​</a></h3><p>多对一和一对多的匹配模式，可以理解为如果两个瞬时向量数量不一致时可通过。这时就需要使用 <code>group_left</code> 或 <code>group_right</code> 组修饰符来指明哪边匹配元素较多，左边多则用 <code>group_left</code>，右边多则用 <code>group_right</code>。其语法如下：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span></span>
<span class="line"><span style="color:#032F62;">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span></span>
<span class="line"><span style="color:#032F62;">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span></span>
<span class="line"><span style="color:#032F62;">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span></span></code></pre></div><p>比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">sum by (node) ((kube_pod_status_phase{phase=&quot;Running&quot;} == 1) + on(pod) group_left(node) (0 * kube_pod_info{pod_template_hash=&quot;&quot;})) / sum by (node) (kube_node_status_allocatable{resource=&quot;pods&quot;}) * 100 &gt; 90</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">sum by (node) ((kube_pod_status_phase{phase=&quot;Running&quot;} == 1) + on(pod) group_left(node) (0 * kube_pod_info{pod_template_hash=&quot;&quot;})) / sum by (node) (kube_node_status_allocatable{resource=&quot;pods&quot;}) * 100 &gt; 90</span></span></code></pre></div><h2 id="_1-3-聚合操作符" tabindex="-1">1.3 聚合操作符 <a class="header-anchor" href="#_1-3-聚合操作符" aria-label="Permalink to &quot;1.3 聚合操作符&quot;">​</a></h2><p><a href="https://prometheus.io/docs/prometheus/2.55/querying/operators/#aggregation-operators" target="_blank" rel="noreferrer">PromQL</a> 的聚合操作符用来将向量里的元素聚合得更少。总共有下面这些聚合操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>sum</td><td>求和</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>stddev</td><td>标准差</td></tr><tr><td>stdvar</td><td>方差</td></tr><tr><td>count</td><td>元素个数</td></tr><tr><td><code>count_values</code>,支持parameter</td><td>等于某值的元素个数</td></tr><tr><td><code>bottomk</code>，支持parameter</td><td>最小的 k 个元素</td></tr><tr><td><code>topk</code>，支持parameter</td><td>最大的 k 个元素</td></tr><tr><td><code>quantile</code>，支持parameter</td><td>分位数</td></tr><tr><td>limitk(使用limit的开启 --enable-feature=promql-experimental-functions功能)</td><td></td></tr><tr><td>limit_ratio</td><td></td></tr></tbody></table><p>聚合操作符语法如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">aggr-op</span><span style="color:#9ECBFF;">&gt;([parameter,] </span><span style="color:#F97583;">&lt;</span><span style="color:#9ECBFF;">vector expression</span><span style="color:#F97583;">&gt;</span><span style="color:#9ECBFF;">)</span><span style="color:#E1E4E8;"> [without</span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">by (</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">label list</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">)]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">aggr-op</span><span style="color:#032F62;">&gt;([parameter,] </span><span style="color:#D73A49;">&lt;</span><span style="color:#032F62;">vector expression</span><span style="color:#D73A49;">&gt;</span><span style="color:#032F62;">)</span><span style="color:#24292E;"> [without</span><span style="color:#D73A49;">|</span><span style="color:#24292E;">by (</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">label list</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">)]</span></span></code></pre></div><p>其中 <code>without</code> 用来指定不需要保留的标签（也就是这些标签的多个值会被聚合），而 <code>by</code> 正好相反，用来指定需要保留的标签（也就是按这些标签来聚合）</p><h3 id="_1-sum" tabindex="-1">1.sum <a class="header-anchor" href="#_1-sum" aria-label="Permalink to &quot;1.sum&quot;">​</a></h3><p>sum和without是同时存在的</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sum(node_timex_sync_status</span><span style="color:#E1E4E8;">) without (</span><span style="color:#B392F0;">job,mode</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">等价于</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">sum(node_timex_sync_status</span><span style="color:#E1E4E8;">) by (</span><span style="color:#B392F0;">instance</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sum(node_timex_sync_status</span><span style="color:#24292E;">) without (</span><span style="color:#6F42C1;">job,mode</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6F42C1;">等价于</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">sum(node_timex_sync_status</span><span style="color:#24292E;">) by (</span><span style="color:#6F42C1;">instance</span><span style="color:#24292E;">)</span></span></code></pre></div><h3 id="_2-max" tabindex="-1">2.max <a class="header-anchor" href="#_2-max" aria-label="Permalink to &quot;2.max&quot;">​</a></h3><p>返回所有记录的最大值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">max(node_cpu_seconds_total) by (mode)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">max(node_cpu_seconds_total) by (mode)</span></span></code></pre></div><h3 id="_3-avg" tabindex="-1">3.avg <a class="header-anchor" href="#_3-avg" aria-label="Permalink to &quot;3.avg&quot;">​</a></h3><p>avg 函数返回所有记录的平均值。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">avg(node_cpu_seconds_total) by (mode)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">avg(node_cpu_seconds_total) by (mode)</span></span></code></pre></div><p>cpu大于80%</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">100</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">-</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">avg</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">by</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">instance</span><span style="color:#E1E4E8;">)(</span><span style="color:#B392F0;">rate(node_cpu_seconds_total</span><span style="color:#E1E4E8;">{mode=</span><span style="color:#B392F0;">&quot;idle&quot;</span><span style="color:#B392F0;">}[2m]</span><span style="color:#E1E4E8;">)) </span><span style="color:#79B8FF;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> 80</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">100</span><span style="color:#24292E;"> </span><span style="color:#032F62;">-</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">avg</span><span style="color:#24292E;"> </span><span style="color:#032F62;">by</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">instance</span><span style="color:#24292E;">)(</span><span style="color:#6F42C1;">rate(node_cpu_seconds_total</span><span style="color:#24292E;">{mode=</span><span style="color:#6F42C1;">&quot;idle&quot;</span><span style="color:#6F42C1;">}[2m]</span><span style="color:#24292E;">)) </span><span style="color:#005CC5;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> 80</span></span></code></pre></div><h3 id="_4-count" tabindex="-1">4.count <a class="header-anchor" href="#_4-count" aria-label="Permalink to &quot;4.count&quot;">​</a></h3><p>count 函数返回所有记录的计数。</p><p>例如：<code>count(prometheus_http_requests_total)</code> 表示统计所有 HTTP 请求的次数。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">count(prometheus_http_requests_total</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">count(prometheus_http_requests_total</span><span style="color:#24292E;">)</span></span></code></pre></div><h3 id="_5-bottomk-后几条" tabindex="-1">5.bottomk(<strong>后几条</strong>) <a class="header-anchor" href="#_5-bottomk-后几条" aria-label="Permalink to &quot;5.bottomk(**后几条**)&quot;">​</a></h3><p>统计最小的几个值。从最小往下依次增大进行排序</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">bottomk(3,sum(node_cpu_seconds_total</span><span style="color:#E1E4E8;">)by (</span><span style="color:#B392F0;">mode</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">3---&gt;代表是展示几个</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">bottomk(3,sum(node_cpu_seconds_total</span><span style="color:#24292E;">)by (</span><span style="color:#6F42C1;">mode</span><span style="color:#24292E;">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">3---&gt;代表是展示几个</span></span></code></pre></div><h3 id="_6-topk-前几条" tabindex="-1">6.topk(前几条) <a class="header-anchor" href="#_6-topk-前几条" aria-label="Permalink to &quot;6.topk(前几条)&quot;">​</a></h3><p>统计最大的几个值</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">topk(3,sum(node_cpu_seconds_total</span><span style="color:#E1E4E8;">)by (</span><span style="color:#B392F0;">mode</span><span style="color:#E1E4E8;">))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">topk(3,sum(node_cpu_seconds_total</span><span style="color:#24292E;">)by (</span><span style="color:#6F42C1;">mode</span><span style="color:#24292E;">))</span></span></code></pre></div>`,94),n=[t];function p(c,r,i,d,y,u){return a(),o("div",null,n)}const b=s(l,[["render",p]]);export{h as __pageData,b as default};
