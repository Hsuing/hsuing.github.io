import{_ as n,o as e,c as s,R as a}from"./chunks/framework.zUbWieqp.js";const t="/assets/moku.Xjf8Vi0V.png",p="/assets/lianjiechi.zLp9odlQ.png",l="/assets/hexin._IbhsBxP.png",o="/assets/http1.o5tqQJVR.png",i="/assets/http2.wt8jSvZU.png",v=JSON.parse('{"title":"1.nginx模块","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Linux/web/nginx/nginx笔记/2-nginx模块.md","filePath":"guide/Linux/web/nginx/nginx笔记/2-nginx模块.md","lastUpdated":1701684699000}'),c={name:"guide/Linux/web/nginx/nginx笔记/2-nginx模块.md"},r=a('<p><a href="http://nginx.org/en/docs/" target="_blank" rel="noreferrer">nginx官方文档</a><a href="http://www.nginx.cn/doc/" target="_blank" rel="noreferrer">nginx中文文档</a></p><h1 id="_1-nginx模块" tabindex="-1">1.nginx模块 <a class="header-anchor" href="#_1-nginx模块" aria-label="Permalink to &quot;1.nginx模块&quot;">​</a></h1><p>nginx源码的/objs/ngx_modules.c中*ngx_modules[]数组代表了编译进nginx的模块</p><p><img src="'+t+'" alt=""></p><h1 id="_2-nginx连接池" tabindex="-1">2.nginx连接池 <a class="header-anchor" href="#_2-nginx连接池" aria-label="Permalink to &quot;2.nginx连接池&quot;">​</a></h1><p><img src="'+p+`" alt=""></p><p>每个worker进程都有一个独立的ngx_cycle_t这样的一个数据结构</p><p>connections数组：连接池</p><p>官方文档Core_functionality的worker_connections</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Syntax:	worker_connections number;</span></span>
<span class="line"><span style="color:#e1e4e8;">Default:	worker_connections 512;</span></span>
<span class="line"><span style="color:#e1e4e8;">Context:	events</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Syntax:	worker_connections number;</span></span>
<span class="line"><span style="color:#24292e;">Default:	worker_connections 512;</span></span>
<span class="line"><span style="color:#24292e;">Context:	events</span></span></code></pre></div><p>默认512个数组，nginx一般是要处理万，十万，百万级，一般都要修改。</p><p>这些连接不止包括客户端的连接，也包括面向服务器的，所以做反向代理的时候等于消耗两个连接</p><p><img src="`+l+`" alt=""></p><p>每个连接默认对应一个读事件一个写事件。每个连接大概占用96+232字节，worker_connections配置的越大，初始化的时候预分配的内存就越大</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ngx_event_handler_pt handler : 这是一个回调方法，很多第三方模块会把它设置为自己的实现</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">ngx_rbtree_node_t timer : 读写事件超时</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">ngx_queue_t queue : 队列</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">bytes_sent</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ngx_event_handler_pt handler : 这是一个回调方法，很多第三方模块会把它设置为自己的实现</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">ngx_rbtree_node_t timer : 读写事件超时</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">ngx_queue_t queue : 队列</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">bytes_sent</span></span></code></pre></div><h2 id="内存池" tabindex="-1">内存池 <a class="header-anchor" href="#内存池" aria-label="Permalink to &quot;内存池&quot;">​</a></h2><p>连接内存池</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Syntax:	connection_pool_size size;</span></span>
<span class="line"><span style="color:#e1e4e8;">Default:	connection_pool_size 256|512;   #字节，每个连接预分配内存大小，可以分配更大。</span></span>
<span class="line"><span style="color:#e1e4e8;">Context:	http, server</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Syntax:	connection_pool_size size;</span></span>
<span class="line"><span style="color:#24292e;">Default:	connection_pool_size 256|512;   #字节，每个连接预分配内存大小，可以分配更大。</span></span>
<span class="line"><span style="color:#24292e;">Context:	http, server</span></span></code></pre></div><p>请求内存池</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Syntax:	request_pool_size size;</span></span>
<span class="line"><span style="color:#e1e4e8;">Default:	request_pool_size 4k;   #包括head，url</span></span>
<span class="line"><span style="color:#e1e4e8;">Context:	http, server</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Syntax:	request_pool_size size;</span></span>
<span class="line"><span style="color:#24292e;">Default:	request_pool_size 4k;   #包括head，url</span></span>
<span class="line"><span style="color:#24292e;">Context:	http, server</span></span></code></pre></div><p>连接内存池：</p><p>当运行一个tcp连接的时候上面可能会运行多个HTTP请求（keepalive），连接没有关闭，有些内存为连接分配一次就够，连接不关闭就不需要释放。</p><p>请求内存池：</p><p>每个HTTP请求通常会分配4K的内存。 ?减少内存碎片 ?提前预分配了空间，可以减少分配内存的次数</p><h1 id="_3-http模块" tabindex="-1">3.http模块 <a class="header-anchor" href="#_3-http模块" aria-label="Permalink to &quot;3.http模块&quot;">​</a></h1><h2 id="处理http请求头部的流程" tabindex="-1">处理HTTP请求头部的流程 <a class="header-anchor" href="#处理http请求头部的流程" aria-label="Permalink to &quot;处理HTTP请求头部的流程&quot;">​</a></h2><p><img src="`+o+'" alt=""></p><p><img src="'+i+'" alt=""></p>',28),d=[r];function _(h,g,u,x,y,b){return e(),s("div",null,d)}const m=n(c,[["render",_]]);export{v as __pageData,m as default};
